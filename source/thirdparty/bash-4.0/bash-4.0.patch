diff -Nru bash-4.0-orig/arrayfunc.c bash-4.0/arrayfunc.c
--- bash-4.0-orig/arrayfunc.c	2009-01-04 20:32:21.000000000 +0100
+++ bash-4.0/arrayfunc.c	2009-12-08 18:04:02.000000000 +0100
@@ -98,7 +98,7 @@
   oldval = value_cell (var);
   hash = assoc_create (0);
   if (oldval)
-    assoc_insert (hash, "0", oldval);
+    assoc_insert (hash, savestring ("0"), oldval);
 
   FREE (value_cell (var));
   var_setassoc (var, hash);
@@ -604,64 +604,7 @@
     }
 }
 
-/* This function assumes s[i] == '['; returns with s[ret] == ']' if
-   an array subscript is correctly parsed. */
-int
-skipsubscript (s, i)
-     const char *s;
-     int i;
-{
-  int count, c;
-#if defined (HANDLE_MULTIBYTE)
-  mbstate_t state, state_bak;
-  size_t slength, mblength;
-#endif
-
-#if defined (HANDLE_MULTIBYTE)
-  memset (&state, '\0', sizeof (mbstate_t));
-  slength = strlen (s + i);
-#endif
-  
-  count = 1;
-  while (count)
-    {
-      /* Advance one (possibly multibyte) character in S starting at I. */
-#if defined (HANDLE_MULTIBYTE)
-      if (MB_CUR_MAX > 1)
-	{
-	  state_bak = state;
-	  mblength = mbrlen (s + i, slength, &state);
-
-	  if (MB_INVALIDCH (mblength))
-	    {
-	      state = state_bak;
-	      i++;
-	      slength--;
-	    }
-	  else if (MB_NULLWCH (mblength))
-	    return i;
-	  else
-	    {
-	      i += mblength;
-	      slength -= mblength;
-	    }
-	}
-      else
-#endif
-      ++i;
-
-      c = s[i];
-
-      if (c == 0)
-	break;
-      else if (c == '[')
-	count++;
-      else if (c == ']')
-	count--;
-    }
-
-  return i;
-}
+/* skipsubscript moved to subst.c to use private functions. 2009/02/24. */
 
 /* This function is called with SUB pointing to just after the beginning
    `[' of an array subscript and removes the array element to which SUB
diff -Nru bash-4.0-orig/bashline.c bash-4.0/bashline.c
--- bash-4.0-orig/bashline.c	2009-01-08 15:29:24.000000000 +0100
+++ bash-4.0/bashline.c	2009-12-08 18:04:02.000000000 +0100
@@ -3388,7 +3388,6 @@
   Keymap xkmap;		/* unix command executing keymap */
   register int i;
   intmax_t mi;
-  int save_point;
   sh_parser_state_t ps;
   char *cmd, *value, *l;
   SHELL_VAR *v;
@@ -3432,7 +3431,6 @@
   if (v)
     VSETATTR (v, att_exported);
   l = value_cell (v);
-  save_point = rl_point;
   value = inttostr (rl_point, ibuf, sizeof (ibuf));
   v = bind_int_variable ("READLINE_POINT", value);
   if (v)
@@ -3450,7 +3448,7 @@
   if (v && legal_number (value_cell (v), &mi))
     {
       i = mi;
-      if (i != save_point)
+      if (i != rl_point)
 	{
 	  rl_point = i;
 	  if (rl_point > rl_end)
diff -Nru bash-4.0-orig/builtins/alias.c bash-4.0/builtins/alias.c
--- bash-4.0-orig/builtins/alias.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/alias.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,192 @@
+/* alias.c, created from alias.def. */
+#line 42 "./alias.def"
+
+#include <config.h>
+
+#if defined (ALIAS)
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#  include "../bashansi.h"
+#  include "../bashintl.h"
+
+#  include <stdio.h>
+#  include "../shell.h"
+#  include "../alias.h"
+#  include "common.h"
+#  include "bashgetopt.h"
+
+/* Flags for print_alias */
+#define AL_REUSABLE	0x01
+
+static void print_alias __P((alias_t *, int));
+
+extern int posixly_correct;
+
+/* Hack the alias command in a Korn shell way. */
+int
+alias_builtin (list)
+     WORD_LIST *list;
+{
+  int any_failed, offset, pflag, dflags;
+  alias_t **alias_list, *t;
+  char *name, *value;
+
+  dflags = posixly_correct ? 0 : AL_REUSABLE;
+  pflag = 0;
+  reset_internal_getopt ();
+  while ((offset = internal_getopt (list, "p")) != -1)
+    {
+      switch (offset)
+	{
+	case 'p':
+	  pflag = 1;
+	  dflags |= AL_REUSABLE;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+  if (list == 0 || pflag)
+    {
+      if (aliases == 0)
+	return (EXECUTION_SUCCESS);
+
+      alias_list = all_aliases ();
+
+      if (alias_list == 0)
+	return (EXECUTION_SUCCESS);
+
+      for (offset = 0; alias_list[offset]; offset++)
+	print_alias (alias_list[offset], dflags);
+
+      free (alias_list);	/* XXX - Do not free the strings. */
+
+      if (list == 0)
+	return (sh_chkwrite (EXECUTION_SUCCESS));
+    }
+
+  any_failed = 0;
+  while (list)
+    {
+      name = list->word->word;
+
+      for (offset = 0; name[offset] && name[offset] != '='; offset++)
+	;
+
+      if (offset && name[offset] == '=')
+	{
+	  name[offset] = '\0';
+	  value = name + offset + 1;
+
+	  if (legal_alias_name (name, 0) == 0)
+	    {
+	      builtin_error (_("`%s': invalid alias name"), name);
+	      any_failed++;
+	    }
+	  else
+	    add_alias (name, value);
+	}
+      else
+	{
+	  t = find_alias (name);
+	  if (t)
+	    print_alias (t, dflags);
+	  else
+	    {
+	      sh_notfound (name);
+	      any_failed++;
+	    }
+	}
+      list = list->next;
+    }
+
+  return (any_failed ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
+}
+#endif /* ALIAS */
+
+#line 167 "./alias.def"
+
+#if defined (ALIAS)
+/* Remove aliases named in LIST from the aliases database. */
+int
+unalias_builtin (list)
+     register WORD_LIST *list;
+{
+  register alias_t *alias;
+  int opt, aflag;
+
+  aflag = 0;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "a")) != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  aflag = 1;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+  if (aflag)
+    {
+      delete_all_aliases ();
+      return (EXECUTION_SUCCESS);
+    }
+
+  if (list == 0)
+    {
+      builtin_usage ();
+      return (EX_USAGE);
+    }
+
+  aflag = 0;
+  while (list)
+    {
+      alias = find_alias (list->word->word);
+
+      if (alias)
+	remove_alias (alias->name);
+      else
+	{
+	  sh_notfound (list->word->word);
+	  aflag++;
+	}
+
+      list = list->next;
+    }
+
+  return (aflag ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
+}
+
+/* Output ALIAS in such a way as to allow it to be read back in. */
+static void
+print_alias (alias, flags)
+     alias_t *alias;
+     int flags;
+{
+  char *value;
+
+  value = sh_single_quote (alias->value);
+  if (flags & AL_REUSABLE)
+    printf ("alias ");
+  printf ("%s=%s\n", alias->name, value);
+  free (value);
+
+  fflush (stdout);
+}
+#endif /* ALIAS */
diff -Nru bash-4.0-orig/builtins/bind.c bash-4.0/builtins/bind.c
--- bash-4.0-orig/builtins/bind.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/bind.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,278 @@
+/* bind.c, created from bind.def. */
+#line 22 "./bind.def"
+
+#include <config.h>
+
+#line 61 "./bind.def"
+
+#if defined (READLINE)
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+#include <readline/readline.h>
+#include <readline/history.h>
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../bashline.h"
+#include "bashgetopt.h"
+#include "common.h"
+
+static int query_bindings __P((char *));
+static int unbind_command __P((char *));
+
+extern int no_line_editing;
+
+#define BIND_RETURN(x)  do { return_code = x; goto bind_exit; } while (0)
+
+#define LFLAG	0x0001
+#define PFLAG	0x0002
+#define FFLAG	0x0004
+#define VFLAG	0x0008
+#define QFLAG	0x0010
+#define MFLAG	0x0020
+#define RFLAG	0x0040
+#define PPFLAG	0x0080
+#define VVFLAG	0x0100
+#define SFLAG   0x0200
+#define SSFLAG  0x0400
+#define UFLAG	0x0800
+#define XFLAG	0x1000
+
+int
+bind_builtin (list)
+     WORD_LIST *list;
+{
+  int return_code;
+  Keymap kmap, saved_keymap;
+  int flags, opt;
+  char *initfile, *map_name, *fun_name, *unbind_name, *remove_seq, *cmd_seq;
+
+  if (no_line_editing)
+    {
+#if 0
+      builtin_error (_("line editing not enabled"));
+      return (EXECUTION_FAILURE);
+#else
+      builtin_warning (_("line editing not enabled"));
+#endif
+    }
+
+  kmap = saved_keymap = (Keymap) NULL;
+  flags = 0;
+  initfile = map_name = fun_name = unbind_name = remove_seq = (char *)NULL;
+  return_code = EXECUTION_SUCCESS;
+
+  if (bash_readline_initialized == 0)
+    initialize_readline ();
+
+  begin_unwind_frame ("bind_builtin");
+  unwind_protect_var (rl_outstream);
+
+  rl_outstream = stdout;
+
+  reset_internal_getopt ();  
+  while ((opt = internal_getopt (list, "lvpVPsSf:q:u:m:r:x:")) != EOF)
+    {
+      switch (opt)
+	{
+	case 'l':
+	  flags |= LFLAG;
+	  break;
+	case 'v':
+	  flags |= VFLAG;
+	  break;
+	case 'p':
+	  flags |= PFLAG;
+	  break;
+	case 'f':
+	  flags |= FFLAG;
+	  initfile = list_optarg;
+	  break;
+	case 'm':
+	  flags |= MFLAG;
+	  map_name = list_optarg;
+	  break;
+	case 'q':
+	  flags |= QFLAG;
+	  fun_name = list_optarg;
+	  break;
+	case 'u':
+	  flags |= UFLAG;
+	  unbind_name = list_optarg;
+	  break;
+	case 'r':
+	  flags |= RFLAG;
+	  remove_seq = list_optarg;
+	  break;
+	case 'V':
+	  flags |= VVFLAG;
+	  break;
+	case 'P':
+	  flags |= PPFLAG;
+	  break;
+	case 's':
+	  flags |= SFLAG;
+	  break;
+	case 'S':
+	  flags |= SSFLAG;
+	  break;
+	case 'x':
+	  flags |= XFLAG;
+	  cmd_seq = list_optarg;
+	  break;
+	default:
+	  builtin_usage ();
+	  BIND_RETURN (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+  /* First, see if we need to install a special keymap for this
+     command.  Then start on the arguments. */
+
+  if ((flags & MFLAG) && map_name)
+    {
+      kmap = rl_get_keymap_by_name (map_name);
+      if (!kmap)
+	{
+	  builtin_error (_("`%s': invalid keymap name"), map_name);
+	  BIND_RETURN (EXECUTION_FAILURE);
+	}
+    }
+
+  if (kmap)
+    {
+      saved_keymap = rl_get_keymap ();
+      rl_set_keymap (kmap);
+    }
+
+  /* XXX - we need to add exclusive use tests here.  It doesn't make sense
+     to use some of these options together. */
+  /* Now hack the option arguments */
+  if (flags & LFLAG)
+    rl_list_funmap_names ();
+
+  if (flags & PFLAG)
+    rl_function_dumper (1);
+
+  if (flags & PPFLAG)
+    rl_function_dumper (0);
+
+  if (flags & SFLAG)
+    rl_macro_dumper (1);
+
+  if (flags & SSFLAG)
+    rl_macro_dumper (0);
+
+  if (flags & VFLAG)
+    rl_variable_dumper (1);
+
+  if (flags & VVFLAG)
+    rl_variable_dumper (0);
+
+  if ((flags & FFLAG) && initfile)
+    {
+      if (rl_read_init_file (initfile) != 0)
+	{
+	  builtin_error (_("%s: cannot read: %s"), initfile, strerror (errno));
+	  BIND_RETURN (EXECUTION_FAILURE);
+	}
+    }
+
+  if ((flags & QFLAG) && fun_name)
+    return_code = query_bindings (fun_name);
+
+  if ((flags & UFLAG) && unbind_name)
+    return_code = unbind_command (unbind_name);
+
+  if ((flags & RFLAG) && remove_seq)
+    {
+      if (rl_set_key (remove_seq, (rl_command_func_t *)NULL, rl_get_keymap ()) != 0)
+	{
+	  builtin_error (_("`%s': cannot unbind"), remove_seq);
+	  BIND_RETURN (EXECUTION_FAILURE);
+	}
+    }
+
+  if (flags & XFLAG)
+    return_code = bind_keyseq_to_unix_command (cmd_seq);
+
+  /* Process the rest of the arguments as binding specifications. */
+  while (list)
+    {
+      rl_parse_and_bind (list->word->word);
+      list = list->next;
+    }
+
+ bind_exit:
+  if (saved_keymap)
+    rl_set_keymap (saved_keymap);
+
+  run_unwind_frame ("bind_builtin");
+
+  return (sh_chkwrite (return_code));
+}
+
+static int
+query_bindings (name)
+     char *name;
+{
+  rl_command_func_t *function;
+  char **keyseqs;
+  int j;
+
+  function = rl_named_function (name);
+  if (function == 0)
+    {
+      builtin_error (_("`%s': unknown function name"), name);
+      return EXECUTION_FAILURE;
+    }
+
+  keyseqs = rl_invoking_keyseqs (function);
+
+  if (!keyseqs)
+    {
+      printf (_("%s is not bound to any keys.\n"), name);
+      return EXECUTION_FAILURE;
+    }
+
+  printf (_("%s can be invoked via "), name);
+  for (j = 0; j < 5 && keyseqs[j]; j++)
+    printf ("\"%s\"%s", keyseqs[j], keyseqs[j + 1] ? ", " : ".\n");
+  if (keyseqs[j])
+    printf ("...\n");
+  strvec_dispose (keyseqs);
+  return EXECUTION_SUCCESS;
+}
+
+static int
+unbind_command (name)
+     char *name;
+{
+  rl_command_func_t *function;
+
+  function = rl_named_function (name);
+  if (function == 0)
+    {
+      builtin_error (_("`%s': unknown function name"), name);
+      return EXECUTION_FAILURE;
+    }
+
+  rl_unbind_function_in_map (function, rl_get_keymap ());
+  return EXECUTION_SUCCESS;
+}
+#endif /* READLINE */
diff -Nru bash-4.0-orig/builtins/break.c bash-4.0/builtins/break.c
--- bash-4.0-orig/builtins/break.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/break.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,102 @@
+/* break.c, created from break.def. */
+#line 22 "./break.def"
+
+#line 34 "./break.def"
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+
+extern char *this_command_name;
+extern int posixly_correct;
+
+static int check_loop_level __P((void));
+
+/* The depth of while's and until's. */
+int loop_level = 0;
+
+/* Non-zero when a "break" instruction is encountered. */
+int breaking = 0;
+
+/* Non-zero when we have encountered a continue instruction. */
+int continuing = 0;
+
+/* Set up to break x levels, where x defaults to 1, but can be specified
+   as the first argument. */
+int
+break_builtin (list)
+     WORD_LIST *list;
+{
+  intmax_t newbreak;
+
+  if (check_loop_level () == 0)
+    return (EXECUTION_SUCCESS);
+
+  (void)get_numeric_arg (list, 1, &newbreak);
+
+  if (newbreak <= 0)
+    {
+      sh_erange (list->word->word, _("loop count"));
+      breaking = loop_level;
+      return (EXECUTION_FAILURE);
+    }
+
+  if (newbreak > loop_level)
+    newbreak = loop_level;
+
+  breaking = newbreak;
+
+  return (EXECUTION_SUCCESS);
+}
+
+#line 101 "./break.def"
+
+/* Set up to continue x levels, where x defaults to 1, but can be specified
+   as the first argument. */
+int
+continue_builtin (list)
+     WORD_LIST *list;
+{
+  intmax_t newcont;
+
+  if (check_loop_level () == 0)
+    return (EXECUTION_SUCCESS);
+
+  (void)get_numeric_arg (list, 1, &newcont);
+
+  if (newcont <= 0)
+    {
+      sh_erange (list->word->word, _("loop count"));
+      breaking = loop_level;
+      return (EXECUTION_FAILURE);
+    }
+
+  if (newcont > loop_level)
+    newcont = loop_level;
+
+  continuing = newcont;
+
+  return (EXECUTION_SUCCESS);
+}
+
+/* Return non-zero if a break or continue command would be okay.
+   Print an error message if break or continue is meaningless here. */
+static int
+check_loop_level ()
+{
+#if defined (BREAK_COMPLAINS)
+  if (loop_level == 0 && posixly_correct == 0)
+    builtin_error (_("only meaningful in a `for', `while', or `until' loop"));
+#endif /* BREAK_COMPLAINS */
+
+  return (loop_level);
+}
diff -Nru bash-4.0-orig/builtins/builtext.h bash-4.0/builtins/builtext.h
--- bash-4.0-orig/builtins/builtext.h	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/builtext.h	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,188 @@
+/* builtext.h - The list of builtins found in libbuiltins.a. */
+#if defined (ALIAS)
+extern int alias_builtin __P((WORD_LIST *));
+extern char * const alias_doc[];
+#endif /* ALIAS */
+#if defined (ALIAS)
+extern int unalias_builtin __P((WORD_LIST *));
+extern char * const unalias_doc[];
+#endif /* ALIAS */
+#if defined (READLINE)
+extern int bind_builtin __P((WORD_LIST *));
+extern char * const bind_doc[];
+#endif /* READLINE */
+extern int break_builtin __P((WORD_LIST *));
+extern char * const break_doc[];
+extern int continue_builtin __P((WORD_LIST *));
+extern char * const continue_doc[];
+extern int builtin_builtin __P((WORD_LIST *));
+extern char * const builtin_doc[];
+#if defined (DEBUGGER)
+extern int caller_builtin __P((WORD_LIST *));
+extern char * const caller_doc[];
+#endif /* DEBUGGER */
+extern int cd_builtin __P((WORD_LIST *));
+extern char * const cd_doc[];
+extern int pwd_builtin __P((WORD_LIST *));
+extern char * const pwd_doc[];
+extern int colon_builtin __P((WORD_LIST *));
+extern char * const colon_doc[];
+extern int colon_builtin __P((WORD_LIST *));
+extern char * const true_doc[];
+extern int false_builtin __P((WORD_LIST *));
+extern char * const false_doc[];
+extern int command_builtin __P((WORD_LIST *));
+extern char * const command_doc[];
+extern int declare_builtin __P((WORD_LIST *));
+extern char * const declare_doc[];
+extern int declare_builtin __P((WORD_LIST *));
+extern char * const typeset_doc[];
+extern int local_builtin __P((WORD_LIST *));
+extern char * const local_doc[];
+#if defined (V9_ECHO)
+extern int echo_builtin __P((WORD_LIST *));
+extern char * const echo_doc[];
+#endif /* V9_ECHO */
+#if !defined (V9_ECHO)
+extern int echo_builtin __P((WORD_LIST *));
+extern char * const echo_doc[];
+#endif /* !V9_ECHO */
+extern int enable_builtin __P((WORD_LIST *));
+extern char * const enable_doc[];
+extern int eval_builtin __P((WORD_LIST *));
+extern char * const eval_doc[];
+extern int getopts_builtin __P((WORD_LIST *));
+extern char * const getopts_doc[];
+extern int exec_builtin __P((WORD_LIST *));
+extern char * const exec_doc[];
+extern int exit_builtin __P((WORD_LIST *));
+extern char * const exit_doc[];
+extern int logout_builtin __P((WORD_LIST *));
+extern char * const logout_doc[];
+#if defined (HISTORY)
+extern int fc_builtin __P((WORD_LIST *));
+extern char * const fc_doc[];
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+extern int fg_builtin __P((WORD_LIST *));
+extern char * const fg_doc[];
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+extern int bg_builtin __P((WORD_LIST *));
+extern char * const bg_doc[];
+#endif /* JOB_CONTROL */
+extern int hash_builtin __P((WORD_LIST *));
+extern char * const hash_doc[];
+#if defined (HELP_BUILTIN)
+extern int help_builtin __P((WORD_LIST *));
+extern char * const help_doc[];
+#endif /* HELP_BUILTIN */
+#if defined (HISTORY)
+extern int history_builtin __P((WORD_LIST *));
+extern char * const history_doc[];
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+extern int jobs_builtin __P((WORD_LIST *));
+extern char * const jobs_doc[];
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+extern int disown_builtin __P((WORD_LIST *));
+extern char * const disown_doc[];
+#endif /* JOB_CONTROL */
+extern int kill_builtin __P((WORD_LIST *));
+extern char * const kill_doc[];
+extern int let_builtin __P((WORD_LIST *));
+extern char * const let_doc[];
+extern int read_builtin __P((WORD_LIST *));
+extern char * const read_doc[];
+extern int return_builtin __P((WORD_LIST *));
+extern char * const return_doc[];
+extern int set_builtin __P((WORD_LIST *));
+extern char * const set_doc[];
+extern int unset_builtin __P((WORD_LIST *));
+extern char * const unset_doc[];
+extern int export_builtin __P((WORD_LIST *));
+extern char * const export_doc[];
+extern int readonly_builtin __P((WORD_LIST *));
+extern char * const readonly_doc[];
+extern int shift_builtin __P((WORD_LIST *));
+extern char * const shift_doc[];
+extern int source_builtin __P((WORD_LIST *));
+extern char * const source_doc[];
+extern int source_builtin __P((WORD_LIST *));
+extern char * const dot_doc[];
+#if defined (JOB_CONTROL)
+extern int suspend_builtin __P((WORD_LIST *));
+extern char * const suspend_doc[];
+#endif /* JOB_CONTROL */
+extern int test_builtin __P((WORD_LIST *));
+extern char * const test_doc[];
+extern int test_builtin __P((WORD_LIST *));
+extern char * const test_bracket_doc[];
+extern int times_builtin __P((WORD_LIST *));
+extern char * const times_doc[];
+extern int trap_builtin __P((WORD_LIST *));
+extern char * const trap_doc[];
+extern int type_builtin __P((WORD_LIST *));
+extern char * const type_doc[];
+#if !defined (_MINIX)
+extern int ulimit_builtin __P((WORD_LIST *));
+extern char * const ulimit_doc[];
+#endif /* !_MINIX */
+extern int umask_builtin __P((WORD_LIST *));
+extern char * const umask_doc[];
+#if defined (JOB_CONTROL)
+extern int wait_builtin __P((WORD_LIST *));
+extern char * const wait_doc[];
+#endif /* JOB_CONTROL */
+#if !defined (JOB_CONTROL)
+extern int wait_builtin __P((WORD_LIST *));
+extern char * const wait_doc[];
+#endif /* !JOB_CONTROL */
+extern char * const for_doc[];
+extern char * const arith_for_doc[];
+extern char * const select_doc[];
+extern char * const time_doc[];
+extern char * const case_doc[];
+extern char * const if_doc[];
+extern char * const while_doc[];
+extern char * const until_doc[];
+extern char * const coproc_doc[];
+extern char * const function_doc[];
+extern char * const grouping_braces_doc[];
+extern char * const fg_percent_doc[];
+extern char * const arith_doc[];
+extern char * const conditional_doc[];
+extern char * const variable_help_doc[];
+#if defined (PUSHD_AND_POPD)
+extern int pushd_builtin __P((WORD_LIST *));
+extern char * const pushd_doc[];
+#endif /* PUSHD_AND_POPD */
+#if defined (PUSHD_AND_POPD)
+extern int popd_builtin __P((WORD_LIST *));
+extern char * const popd_doc[];
+#endif /* PUSHD_AND_POPD */
+#if defined (PUSHD_AND_POPD)
+extern int dirs_builtin __P((WORD_LIST *));
+extern char * const dirs_doc[];
+#endif /* PUSHD_AND_POPD */
+extern int shopt_builtin __P((WORD_LIST *));
+extern char * const shopt_doc[];
+extern int printf_builtin __P((WORD_LIST *));
+extern char * const printf_doc[];
+#if defined (PROGRAMMABLE_COMPLETION)
+extern int complete_builtin __P((WORD_LIST *));
+extern char * const complete_doc[];
+#endif /* PROGRAMMABLE_COMPLETION */
+#if defined (PROGRAMMABLE_COMPLETION)
+extern int compgen_builtin __P((WORD_LIST *));
+extern char * const compgen_doc[];
+#endif /* PROGRAMMABLE_COMPLETION */
+#if defined (PROGRAMMABLE_COMPLETION)
+extern int compopt_builtin __P((WORD_LIST *));
+extern char * const compopt_doc[];
+#endif /* PROGRAMMABLE_COMPLETION */
+extern int mapfile_builtin __P((WORD_LIST *));
+extern char * const mapfile_doc[];
+extern int mapfile_builtin __P((WORD_LIST *));
+extern char * const readarray_doc[];
diff -Nru bash-4.0-orig/builtins/builtin.c bash-4.0/builtins/builtin.c
--- bash-4.0-orig/builtins/builtin.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/builtin.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,54 @@
+/* builtin.c, created from builtin.def. */
+#line 22 "./builtin.def"
+
+#line 36 "./builtin.def"
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../shell.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+extern char *this_command_name;
+
+/* Run the command mentioned in list directly, without going through the
+   normal alias/function/builtin/filename lookup process. */
+int
+builtin_builtin (list)
+     WORD_LIST *list;
+{
+  sh_builtin_func_t *function;
+  register char *command;
+
+  if (no_options (list))
+    return (EX_USAGE);
+  list = loptend;	/* skip over possible `--' */
+
+  if (list == 0)
+    return (EXECUTION_SUCCESS);
+
+  command = list->word->word;
+#if defined (DISABLED_BUILTINS)
+  function = builtin_address (command);
+#else /* !DISABLED_BUILTINS */
+  function = find_shell_builtin (command);
+#endif /* !DISABLED_BUILTINS */
+
+  if (!function)
+    {
+      sh_notbuiltin (command);
+      return (EXECUTION_FAILURE);
+    }
+  else
+    {
+      this_command_name = command;
+      list = list->next;
+      return ((*function) (list));
+    }
+}
diff -Nru bash-4.0-orig/builtins/builtins.c bash-4.0/builtins/builtins.c
--- bash-4.0-orig/builtins/builtins.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/builtins.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,1995 @@
+/* builtins.c -- the built in shell commands. */
+
+/* This file is manufactured by ./mkbuiltins, and should not be
+   edited by hand.  See the source to mkbuiltins for details. */
+
+/* Copyright (C) 1987-2009 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Bash is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/* The list of shell builtins.  Each element is name, function, flags,
+   long-doc, short-doc.  The long-doc field contains a pointer to an array
+   of help lines.  The function takes a WORD_LIST *; the first word in the
+   list is the first arg to the command.  The list has already had word
+   expansion performed.
+
+   Functions which need to look at only the simple commands (e.g.
+   the enable_builtin ()), should ignore entries where
+   (array[i].function == (sh_builtin_func_t *)NULL).  Such entries are for
+   the list of shell reserved control structures, like `if' and `while'.
+   The end of the list is denoted with a NULL name field. */
+
+#include "../builtins.h"
+#include "builtext.h"
+#include "bashintl.h"
+
+struct builtin static_shell_builtins[] = {
+#if defined (ALIAS)
+  { "alias", alias_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | ASSIGNMENT_BUILTIN | POSIX_BUILTIN, alias_doc,
+     N_("alias [-p] [name[=value] ... ]"), (char *)NULL },
+#endif /* ALIAS */
+#if defined (ALIAS)
+  { "unalias", unalias_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, unalias_doc,
+     N_("unalias [-a] name [name ...]"), (char *)NULL },
+#endif /* ALIAS */
+#if defined (READLINE)
+  { "bind", bind_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, bind_doc,
+     N_("bind [-lpvsPVS] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"), (char *)NULL },
+#endif /* READLINE */
+  { "break", break_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, break_doc,
+     N_("break [n]"), (char *)NULL },
+  { "continue", continue_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, continue_doc,
+     N_("continue [n]"), (char *)NULL },
+  { "builtin", builtin_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, builtin_doc,
+     N_("builtin [shell-builtin [arg ...]]"), (char *)NULL },
+#if defined (DEBUGGER)
+  { "caller", caller_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, caller_doc,
+     N_("caller [expr]"), (char *)NULL },
+#endif /* DEBUGGER */
+  { "cd", cd_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, cd_doc,
+     N_("cd [-L|-P] [dir]"), (char *)NULL },
+  { "pwd", pwd_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, pwd_doc,
+     N_("pwd [-LP]"), (char *)NULL },
+  { ":", colon_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, colon_doc,
+     N_(":"), (char *)NULL },
+  { "true", colon_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, true_doc,
+     N_("true"), (char *)NULL },
+  { "false", false_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, false_doc,
+     N_("false"), (char *)NULL },
+  { "command", command_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, command_doc,
+     N_("command [-pVv] command [arg ...]"), (char *)NULL },
+  { "declare", declare_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | ASSIGNMENT_BUILTIN, declare_doc,
+     N_("declare [-aAfFilrtux] [-p] [name[=value] ...]"), (char *)NULL },
+  { "typeset", declare_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | ASSIGNMENT_BUILTIN, typeset_doc,
+     N_("typeset [-aAfFilrtux] [-p] name[=value] ..."), (char *)NULL },
+  { "local", local_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | ASSIGNMENT_BUILTIN, local_doc,
+     N_("local [option] name[=value] ..."), (char *)NULL },
+#if defined (V9_ECHO)
+  { "echo", echo_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, echo_doc,
+     N_("echo [-neE] [arg ...]"), (char *)NULL },
+#endif /* V9_ECHO */
+#if !defined (V9_ECHO)
+  { "echo", echo_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, echo_doc,
+     N_("echo [-n] [arg ...]"), (char *)NULL },
+#endif /* !V9_ECHO */
+  { "enable", enable_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, enable_doc,
+     N_("enable [-a] [-dnps] [-f filename] [name ...]"), (char *)NULL },
+  { "eval", eval_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, eval_doc,
+     N_("eval [arg ...]"), (char *)NULL },
+  { "getopts", getopts_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, getopts_doc,
+     N_("getopts optstring name [arg]"), (char *)NULL },
+  { "exec", exec_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, exec_doc,
+     N_("exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"), (char *)NULL },
+  { "exit", exit_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, exit_doc,
+     N_("exit [n]"), (char *)NULL },
+  { "logout", logout_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, logout_doc,
+     N_("logout [n]"), (char *)NULL },
+#if defined (HISTORY)
+  { "fc", fc_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, fc_doc,
+     N_("fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"), (char *)NULL },
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+  { "fg", fg_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, fg_doc,
+     N_("fg [job_spec]"), (char *)NULL },
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+  { "bg", bg_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, bg_doc,
+     N_("bg [job_spec ...]"), (char *)NULL },
+#endif /* JOB_CONTROL */
+  { "hash", hash_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, hash_doc,
+     N_("hash [-lr] [-p pathname] [-dt] [name ...]"), (char *)NULL },
+#if defined (HELP_BUILTIN)
+  { "help", help_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, help_doc,
+     N_("help [-ds] [pattern ...]"), (char *)NULL },
+#endif /* HELP_BUILTIN */
+#if defined (HISTORY)
+  { "history", history_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, history_doc,
+     N_("history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"), (char *)NULL },
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+  { "jobs", jobs_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, jobs_doc,
+     N_("jobs [-lnprs] [jobspec ...] or jobs -x command [args]"), (char *)NULL },
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+  { "disown", disown_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, disown_doc,
+     N_("disown [-h] [-ar] [jobspec ...]"), (char *)NULL },
+#endif /* JOB_CONTROL */
+  { "kill", kill_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, kill_doc,
+     N_("kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"), (char *)NULL },
+  { "let", let_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, let_doc,
+     N_("let arg [arg ...]"), (char *)NULL },
+  { "read", read_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, read_doc,
+     N_("read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"), (char *)NULL },
+  { "return", return_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, return_doc,
+     N_("return [n]"), (char *)NULL },
+  { "set", set_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, set_doc,
+     N_("set [--abefhkmnptuvxBCHP] [-o option-name] [arg ...]"), (char *)NULL },
+  { "unset", unset_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, unset_doc,
+     N_("unset [-f] [-v] [name ...]"), (char *)NULL },
+  { "export", export_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN | ASSIGNMENT_BUILTIN, export_doc,
+     N_("export [-fn] [name[=value] ...] or export -p"), (char *)NULL },
+  { "readonly", readonly_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN | ASSIGNMENT_BUILTIN, readonly_doc,
+     N_("readonly [-af] [name[=value] ...] or readonly -p"), (char *)NULL },
+  { "shift", shift_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, shift_doc,
+     N_("shift [n]"), (char *)NULL },
+  { "source", source_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, source_doc,
+     N_("source filename [arguments]"), (char *)NULL },
+  { ".", source_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, dot_doc,
+     N_(". filename [arguments]"), (char *)NULL },
+#if defined (JOB_CONTROL)
+  { "suspend", suspend_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, suspend_doc,
+     N_("suspend [-f]"), (char *)NULL },
+#endif /* JOB_CONTROL */
+  { "test", test_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, test_doc,
+     N_("test [expr]"), (char *)NULL },
+  { "[", test_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, test_bracket_doc,
+     N_("[ arg... ]"), (char *)NULL },
+  { "times", times_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, times_doc,
+     N_("times"), (char *)NULL },
+  { "trap", trap_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | SPECIAL_BUILTIN, trap_doc,
+     N_("trap [-lp] [[arg] signal_spec ...]"), (char *)NULL },
+  { "type", type_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, type_doc,
+     N_("type [-afptP] name [name ...]"), (char *)NULL },
+#if !defined (_MINIX)
+  { "ulimit", ulimit_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, ulimit_doc,
+     N_("ulimit [-SHacdefilmnpqrstuvx] [limit]"), (char *)NULL },
+#endif /* !_MINIX */
+  { "umask", umask_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, umask_doc,
+     N_("umask [-p] [-S] [mode]"), (char *)NULL },
+#if defined (JOB_CONTROL)
+  { "wait", wait_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, wait_doc,
+     N_("wait [id]"), (char *)NULL },
+#endif /* JOB_CONTROL */
+#if !defined (JOB_CONTROL)
+  { "wait", wait_builtin, BUILTIN_ENABLED | STATIC_BUILTIN | POSIX_BUILTIN, wait_doc,
+     N_("wait [pid]"), (char *)NULL },
+#endif /* !JOB_CONTROL */
+  { "for", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, for_doc,
+     N_("for NAME [in WORDS ... ] ; do COMMANDS; done"), (char *)NULL },
+  { "for ((", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, arith_for_doc,
+     N_("for (( exp1; exp2; exp3 )); do COMMANDS; done"), (char *)NULL },
+  { "select", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, select_doc,
+     N_("select NAME [in WORDS ... ;] do COMMANDS; done"), (char *)NULL },
+  { "time", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, time_doc,
+     N_("time [-p] pipeline"), (char *)NULL },
+  { "case", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, case_doc,
+     N_("case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"), (char *)NULL },
+  { "if", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, if_doc,
+     N_("if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"), (char *)NULL },
+  { "while", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, while_doc,
+     N_("while COMMANDS; do COMMANDS; done"), (char *)NULL },
+  { "until", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, until_doc,
+     N_("until COMMANDS; do COMMANDS; done"), (char *)NULL },
+  { "coproc", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, coproc_doc,
+     N_("coproc [NAME] command [redirections]"), (char *)NULL },
+  { "function", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, function_doc,
+     N_("function name { COMMANDS ; } or name () { COMMANDS ; }"), (char *)NULL },
+  { "{ ... }", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, grouping_braces_doc,
+     N_("{ COMMANDS ; }"), (char *)NULL },
+  { "%", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, fg_percent_doc,
+     N_("job_spec [&]"), (char *)NULL },
+  { "(( ... ))", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, arith_doc,
+     N_("(( expression ))"), (char *)NULL },
+  { "[[ ... ]]", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, conditional_doc,
+     N_("[[ expression ]]"), (char *)NULL },
+  { "variables", (sh_builtin_func_t *)0x0, BUILTIN_ENABLED | STATIC_BUILTIN, variable_help_doc,
+     N_("variables - Names and meanings of some shell variables"), (char *)NULL },
+#if defined (PUSHD_AND_POPD)
+  { "pushd", pushd_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, pushd_doc,
+     N_("pushd [-n] [+N | -N | dir]"), (char *)NULL },
+#endif /* PUSHD_AND_POPD */
+#if defined (PUSHD_AND_POPD)
+  { "popd", popd_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, popd_doc,
+     N_("popd [-n] [+N | -N]"), (char *)NULL },
+#endif /* PUSHD_AND_POPD */
+#if defined (PUSHD_AND_POPD)
+  { "dirs", dirs_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, dirs_doc,
+     N_("dirs [-clpv] [+N] [-N]"), (char *)NULL },
+#endif /* PUSHD_AND_POPD */
+  { "shopt", shopt_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, shopt_doc,
+     N_("shopt [-pqsu] [-o] [optname ...]"), (char *)NULL },
+  { "printf", printf_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, printf_doc,
+     N_("printf [-v var] format [arguments]"), (char *)NULL },
+#if defined (PROGRAMMABLE_COMPLETION)
+  { "complete", complete_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, complete_doc,
+     N_("complete [-abcdefgjksuv] [-pr] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"), (char *)NULL },
+#endif /* PROGRAMMABLE_COMPLETION */
+#if defined (PROGRAMMABLE_COMPLETION)
+  { "compgen", compgen_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, compgen_doc,
+     N_("compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"), (char *)NULL },
+#endif /* PROGRAMMABLE_COMPLETION */
+#if defined (PROGRAMMABLE_COMPLETION)
+  { "compopt", compopt_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, compopt_doc,
+     N_("compopt [-o|+o option] [name ...]"), (char *)NULL },
+#endif /* PROGRAMMABLE_COMPLETION */
+  { "mapfile", mapfile_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, mapfile_doc,
+     N_("mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"), (char *)NULL },
+  { "readarray", mapfile_builtin, BUILTIN_ENABLED | STATIC_BUILTIN, readarray_doc,
+     N_("readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"), (char *)NULL },
+  { (char *)0x0, (sh_builtin_func_t *)0x0, 0, (char **)0x0, (char *)0x0 }
+};
+
+struct builtin *shell_builtins = static_shell_builtins;
+struct builtin *current_builtin;
+
+int num_shell_builtins =
+	sizeof (static_shell_builtins) / sizeof (struct builtin) - 1;
+#if defined (ALIAS)
+char * const alias_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Define or display aliases.\n\
+    \n\
+    Without arguments, `alias' prints the list of aliases in the reusable\n\
+    form `alias NAME=VALUE' on standard output.\n\
+    \n\
+    Otherwise, an alias is defined for each NAME whose VALUE is given.\n\
+    A trailing space in VALUE causes the next word to be checked for\n\
+    alias substitution when the alias is expanded.\n\
+    \n\
+    Options:\n\
+      -p	Print all defined aliases in a reusable format\n\
+    \n\
+    Exit Status:\n\
+    alias returns true unless a NAME is supplied for which no alias has been\n\
+    defined."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* ALIAS */
+#if defined (ALIAS)
+char * const unalias_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Remove each NAME from the list of defined aliases.\n\
+    \n\
+    Options:\n\
+      -a	remove all alias definitions.\n\
+    \n\
+    Return success unless a NAME is not an existing alias."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* ALIAS */
+#if defined (READLINE)
+char * const bind_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Set Readline key bindings and variables.\n\
+    \n\
+    Bind a key sequence to a Readline function or a macro, or set a\n\
+    Readline variable.  The non-option argument syntax is equivalent to\n\
+    that found in ~/.inputrc, but must be passed as a single argument:\n\
+    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n\
+    \n\
+    Options:\n\
+      -m  keymap         Use KEYMAP as the keymap for the duration of this\n\
+                         command.  Acceptable keymap names are emacs,\n\
+                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n\
+                         vi-command, and vi-insert.\n\
+      -l                 List names of functions.\n\
+      -P                 List function names and bindings.\n\
+      -p                 List functions and bindings in a form that can be\n\
+                         reused as input.\n\
+      -S                 List key sequences that invoke macros and their values\n\
+      -s                 List key sequences that invoke macros and their values\n\
+                         in a form that can be reused as input.\n\
+      -V                 List variable names and values\n\
+      -v                 List variable names and values in a form that can\n\
+                         be reused as input.\n\
+      -q  function-name  Query about which keys invoke the named function.\n\
+      -u  function-name  Unbind all keys which are bound to the named function.\n\
+      -r  keyseq         Remove the binding for KEYSEQ.\n\
+      -f  filename       Read key bindings from FILENAME.\n\
+      -x  keyseq:shell-command	Cause SHELL-COMMAND to be executed when\n\
+    				KEYSEQ is entered.\n\
+    \n\
+    Exit Status:\n\
+    bind returns 0 unless an unrecognized option is given or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* READLINE */
+char * const break_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Exit for, while, or until loops.\n\
+    \n\
+    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n\
+    loops.\n\
+    \n\
+    Exit Status:\n\
+    The exit status is 0 unless N is not greater than or equal to 1."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const continue_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Resume for, while, or until loops.\n\
+    \n\
+    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n\
+    If N is specified, resumes the Nth enclosing loop.\n\
+    \n\
+    Exit Status:\n\
+    The exit status is 0 unless N is not greater than or equal to 1."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const builtin_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute shell builtins.\n\
+    \n\
+    Execute SHELL-BUILTIN with arguments ARGs without performing command\n\
+    lookup.  This is useful when you wish to reimplement a shell builtin\n\
+    as a shell function, but need to execute the builtin within the function.\n\
+    \n\
+    Exit Status:\n\
+    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n\
+    not a shell builtin.."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (DEBUGGER)
+char * const caller_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Return the context of the current subroutine call.\n\
+    \n\
+    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n\
+    \"$line $subroutine $filename\"; this extra information can be used to\n\
+    provide a stack trace.\n\
+    \n\
+    The value of EXPR indicates how many call frames to go back before the\n\
+    current one; the top frame is frame 0.\n\
+    \n\
+    Exit Status:\n\
+    Returns 0 unless the shell is not executing a shell function or EXPR\n\
+    is invalid."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* DEBUGGER */
+char * const cd_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Change the shell working directory.\n\
+    \n\
+    Change the current directory to DIR.  The default DIR is the value of the\n\
+    HOME shell variable.\n\
+    \n\
+    The variable CDPATH defines the search path for the directory containing\n\
+    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n\
+    A null directory name is the same as the current directory.  If DIR begins\n\
+    with a slash (/), then CDPATH is not used.\n\
+    \n\
+    If the directory is not found, and the shell option `cdable_vars' is set,\n\
+    the word is assumed to be  a variable name.  If that variable has a value,\n\
+    its value is used for DIR.\n\
+    \n\
+    Options:\n\
+        -L	force symbolic links to be followed\n\
+        -P	use the physical directory structure without following symbolic\n\
+    	links\n\
+    \n\
+    The default is to follow symbolic links, as if `-L' were specified.\n\
+    \n\
+    Exit Status:\n\
+    Returns 0 if the directory is changed; non-zero otherwise."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const pwd_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Print the name of the current working directory.\n\
+    \n\
+    Options:\n\
+      -L	print the value of $PWD if it names the current working\n\
+    	directory\n\
+      -P	print the physical directory, without any symbolic links\n\
+    \n\
+    By default, `pwd' behaves as if `-L' were specified.\n\
+    \n\
+    Exit Status:\n\
+    Returns 0 unless an invalid option is given or the current directory\n\
+    cannot be read."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const colon_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Null command.\n\
+    \n\
+    No effect; the command does nothing.\n\
+    \n\
+    Exit Status:\n\
+    Always succeeds."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const true_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Return a successful result.\n\
+    \n\
+    Exit Status:\n\
+    Always succeeds."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const false_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Return an unsuccessful result.\n\
+    \n\
+    Exit Status:\n\
+    Always fails."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const command_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute a simple command or display information about commands.\n\
+    \n\
+    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n\
+    information about the specified COMMANDs.  Can be used to invoke commands\n\
+    on disk when a function with the same name exists.\n\
+    \n\
+    Options:\n\
+      -p	use a default value for PATH that is guaranteed to find all of\n\
+    	the standard utilities\n\
+      -v	print a description of COMMAND similar to the `type' builtin\n\
+      -V	print a more verbose description of each COMMAND\n\
+    \n\
+    Exit Status:\n\
+    Returns exit status of COMMAND, or failure if COMMAND is not found."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const declare_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Set variable values and attributes.\n\
+    \n\
+    Declare variables and give them attributes.  If no NAMEs are given,\n\
+    display the attributes and values of all variables.\n\
+    \n\
+    Options:\n\
+      -f	restrict action or display to function names and definitions\n\
+      -F	restrict display to function names only (plus line number and\n\
+    	source file when debugging)\n\
+      -p	display the attributes and value of each NAME\n\
+    \n\
+    Options which set attributes:\n\
+      -a	to make NAMEs indexed arrays (if supported)\n\
+      -A	to make NAMEs associative arrays (if supported)\n\
+      -i	to make NAMEs have the `integer' attribute\n\
+      -l	to convert NAMEs to lower case on assignment\n\
+      -r	to make NAMEs readonly\n\
+      -t	to make NAMEs have the `trace' attribute\n\
+      -u	to convert NAMEs to upper case on assignment\n\
+      -x	to make NAMEs export\n\
+    \n\
+    Using `+' instead of `-' turns off the given attribute.\n\
+    \n\
+    Variables with the integer attribute have arithmetic evaluation (see\n\
+    the `let' command) performed when the variable is assigned a value.\n\
+    \n\
+    When used in a function, `declare' makes NAMEs local, as with the `local'\n\
+    command.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is supplied or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const typeset_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Set variable values and attributes.\n\
+    \n\
+    Obsolete.  See `help declare'."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const local_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Define local variables.\n\
+    \n\
+    Create a local variable called NAME, and give it VALUE.  OPTION can\n\
+    be any option accepted by `declare'.\n\
+    \n\
+    Local variables can only be used within a function; they are visible\n\
+    only to the function where they are defined and its children.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is supplied, an error occurs,\n\
+    or the shell is not executing a function."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (V9_ECHO)
+char * const echo_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Write arguments to the standard output.\n\
+    \n\
+    Display the ARGs on the standard output followed by a newline.\n\
+    \n\
+    Options:\n\
+      -n	do not append a newline\n\
+      -e	enable interpretation of the following backslash escapes\n\
+      -E	explicitly suppress interpretation of backslash escapes\n\
+    \n\
+    `echo' interprets the following backslash-escaped characters:\n\
+      \\a	alert (bell)\n\
+      \\b	backspace\n\
+      \\c	suppress further output\n\
+      \\e	escape character\n\
+      \\f	form feed\n\
+      \\n	new line\n\
+      \\r	carriage return\n\
+      \\t	horizontal tab\n\
+      \\v	vertical tab\n\
+      \\\\	backslash\n\
+      \\0nnn	the character whose ASCII code is NNN (octal).  NNN can be\n\
+    	0 to 3 octal digits\n\
+      \\xHH	the eight-bit character whose value is HH (hexadecimal).  HH\n\
+    	can be one or two hex digits\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless a write error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* V9_ECHO */
+#if !defined (V9_ECHO)
+char * const echo_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Write arguments to the standard output.\n\
+    \n\
+    Display the ARGs on the standard output followed by a newline.\n\
+    \n\
+    Options:\n\
+      -n	do not append a newline\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless a write error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* !V9_ECHO */
+char * const enable_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Enable and disable shell builtins.\n\
+    \n\
+    Enables and disables builtin shell commands.  Disabling allows you to\n\
+    execute a disk command which has the same name as a shell builtin\n\
+    without using a full pathname.\n\
+    \n\
+    Options:\n\
+      -a	print a list of builtins showing whether or not each is enabled\n\
+      -n	disable each NAME or display a list of disabled builtins\n\
+      -p	print the list of builtins in a reusable format\n\
+      -s	print only the names of Posix `special' builtins\n\
+    \n\
+    Options controlling dynamic loading:\n\
+      -f	Load builtin NAME from shared object FILENAME\n\
+      -d	Remove a builtin loaded with -f\n\
+    \n\
+    Without options, each NAME is enabled.\n\
+    \n\
+    To use the `test' found in $PATH instead of the shell builtin\n\
+    version, type `enable -n test'.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless NAME is not a shell builtin or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const eval_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute arguments as a shell command.\n\
+    \n\
+    Combine ARGs into a single string, use the result as input to the shell,\n\
+    and execute the resulting commands.\n\
+    \n\
+    Exit Status:\n\
+    Returns exit status of command or success if command is null."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const getopts_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Parse option arguments.\n\
+    \n\
+    Getopts is used by shell procedures to parse positional parameters\n\
+    as options.\n\
+    \n\
+    OPTSTRING contains the option letters to be recognized; if a letter\n\
+    is followed by a colon, the option is expected to have an argument,\n\
+    which should be separated from it by white space.\n\
+    \n\
+    Each time it is invoked, getopts will place the next option in the\n\
+    shell variable $name, initializing name if it does not exist, and\n\
+    the index of the next argument to be processed into the shell\n\
+    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n\
+    a shell script is invoked.  When an option requires an argument,\n\
+    getopts places that argument into the shell variable OPTARG.\n\
+    \n\
+    getopts reports errors in one of two ways.  If the first character\n\
+    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n\
+    this mode, no error messages are printed.  If an invalid option is\n\
+    seen, getopts places the option character found into OPTARG.  If a\n\
+    required argument is not found, getopts places a ':' into NAME and\n\
+    sets OPTARG to the option character found.  If getopts is not in\n\
+    silent mode, and an invalid option is seen, getopts places '?' into\n\
+    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n\
+    is placed in NAME, OPTARG is unset, and a diagnostic message is\n\
+    printed.\n\
+    \n\
+    If the shell variable OPTERR has the value 0, getopts disables the\n\
+    printing of error messages, even if the first character of\n\
+    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n\
+    \n\
+    Getopts normally parses the positional parameters ($0 - $9), but if\n\
+    more arguments are given, they are parsed instead.\n\
+    \n\
+    Exit Status:\n\
+    Returns success if an option is found; fails if the end of options is\n\
+    encountered or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const exec_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Replace the shell with the given command.\n\
+    \n\
+    Execute COMMAND, replacing this shell with the specified program.\n\
+    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n\
+    any redirections take effect in the current shell.\n\
+    \n\
+    Options:\n\
+      -a name	pass NAME as the zeroth argument to COMMAND\n\
+      -c		execute COMMAND with an empty environment\n\
+      -l		place a dash in the zeroth argument to COMMAND\n\
+    \n\
+    If the command cannot be executed, a non-interactive shell exits, unless\n\
+    the shell option `execfail' is set.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless COMMAND is not found or a redirection error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const exit_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Exit the shell.\n\
+    \n\
+    Exits the shell with a status of N.  If N is omitted, the exit status\n\
+    is that of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const logout_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Exit a login shell.\n\
+    \n\
+    Exits a login shell with exit status N.  Returns an error if not executed\n\
+    in a login shell."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (HISTORY)
+char * const fc_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display or execute commands from the history list.\n\
+    \n\
+    fc is used to list or edit and re-execute commands from the history list.\n\
+    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n\
+    string, which means the most recent command beginning with that\n\
+    string.\n\
+    \n\
+    Options:\n\
+      -e ENAME	select which editor to use.  Default is FCEDIT, then EDITOR,\n\
+    		then vi\n\
+      -l 	list lines instead of editing\n\
+      -n	omit line numbers when listing\n\
+      -r	reverse the order of the lines (newest listed first)\n\
+    \n\
+    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n\
+    re-executed after the substitution OLD=NEW is performed.\n\
+    \n\
+    A useful alias to use with this is r='fc -s', so that typing `r cc'\n\
+    runs the last command beginning with `cc' and typing `r' re-executes\n\
+    the last command.\n\
+    \n\
+    Exit Status:\n\
+    Returns success or status of executed command; non-zero if an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+char * const fg_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Move job to the foreground.\n\
+    \n\
+    Place the job identified by JOB_SPEC in the foreground, making it the\n\
+    current job.  If JOB_SPEC is not present, the shell's notion of the\n\
+    current job is used.\n\
+    \n\
+    Exit Status:\n\
+    Status of command placed in foreground, or failure if an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+char * const bg_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Move jobs to the background.\n\
+    \n\
+    Place the jobs identified by each JOB_SPEC in the background, as if they\n\
+    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n\
+    of the current job is used.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless job control is not enabled or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+char * const hash_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Remember or display program locations.\n\
+    \n\
+    Determine and remember the full pathname of each command NAME.  If\n\
+    no arguments are given, information about remembered commands is displayed.\n\
+    \n\
+    Options:\n\
+      -d		forget the remembered location of each NAME\n\
+      -l		display in a format that may be reused as input\n\
+      -p pathname	use PATHNAME is the full pathname of NAME\n\
+      -r		forget all remembered locations\n\
+      -t		print the remembered location of each NAME, preceding\n\
+    		each location with the corresponding NAME if multiple\n\
+    		NAMEs are given\n\
+    Arguments:\n\
+      NAME		Each NAME is searched for in $PATH and added to the list\n\
+    		of remembered commands.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless NAME is not found or an invalid option is given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (HELP_BUILTIN)
+char * const help_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display information about builtin commands.\n\
+    \n\
+    Displays brief summaries of builtin commands.  If PATTERN is\n\
+    specified, gives detailed help on all commands matching PATTERN,\n\
+    otherwise the list of help topics is printed.\n\
+    \n\
+    Options:\n\
+      -d	output short description for each topic\n\
+      -m	display usage in pseudo-manpage format\n\
+      -s	output only a short usage synopsis for each topic matching\n\
+    	PATTERN\n\
+    \n\
+    Arguments:\n\
+      PATTERN	Pattern specifiying a help topic\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless PATTERN is not found or an invalid option is given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* HELP_BUILTIN */
+#if defined (HISTORY)
+char * const history_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display or manipulate the history list.\n\
+    \n\
+    Display the history list with line numbers, prefixing each modified\n\
+    entry with a `*'.  An argument of N lists only the last N entries.\n\
+    \n\
+    Options:\n\
+      -c	clear the history list by deleting all of the entries\n\
+      -d offset	delete the history entry at offset OFFSET.\n\
+    \n\
+      -a	append history lines from this session to the history file\n\
+      -n	read all history lines not already read from the history file\n\
+      -r	read the history file and append the contents to the history\n\
+    	list\n\
+      -w	write the current history to the history file\n\
+    	and append them to the history list\n\
+    \n\
+      -p	perform history expansion on each ARG and display the result\n\
+    	without storing it in the history list\n\
+      -s	append the ARGs to the history list as a single entry\n\
+    \n\
+    If FILENAME is given, it is used as the history file.  Otherwise,\n\
+    if $HISTFILE has a value, that is used, else ~/.bash_history.\n\
+    \n\
+    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n\
+    as a format string for strftime(3) to print the time stamp associated\n\
+    with each displayed history entry.  No time stamps are printed otherwise.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* HISTORY */
+#if defined (JOB_CONTROL)
+char * const jobs_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display status of jobs.\n\
+    \n\
+    Lists the active jobs.  JOBSPEC restricts output to that job.\n\
+    Without options, the status of all active jobs is displayed.\n\
+    \n\
+    Options:\n\
+      -l	lists process IDs in addition to the normal information\n\
+      -n	list only processes that have changed status since the last\n\
+    	notification\n\
+      -p	lists process IDs only\n\
+      -r	restrict output to running jobs\n\
+      -s	restrict output to stopped jobs\n\
+    \n\
+    If -x is supplied, COMMAND is run after all job specifications that\n\
+    appear in ARGS have been replaced with the process ID of that job's\n\
+    process group leader.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given or an error occurs.\n\
+    If -x is used, returns the exit status of COMMAND."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+#if defined (JOB_CONTROL)
+char * const disown_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Remove jobs from current shell.\n\
+    \n\
+    Removes each JOBSPEC argument from the table of active jobs.  Without\n\
+    any JOBSPECs, the shell uses its notion of the current job.\n\
+    \n\
+    Options:\n\
+      -a	remove all jobs if JOBSPEC is not supplied\n\
+      -h	mark each JOBSPEC so that SIGHUP is not sent to the job if the\n\
+    	shell receives a SIGHUP\n\
+      -r	remove only running jobs\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option or JOBSPEC is given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+char * const kill_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Send a signal to a job.\n\
+    \n\
+    Send the processes identified by PID or JOBSPEC the signal named by\n\
+    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n\
+    SIGTERM is assumed.\n\
+    \n\
+    Options:\n\
+      -s sig	SIG is a signal name\n\
+      -n sig	SIG is a signal number\n\
+      -l	list the signal names; if arguments follow `-l' they are\n\
+    	assumed to be signal numbers for which names should be listed\n\
+    \n\
+    Kill is a shell builtin for two reasons: it allows job IDs to be used\n\
+    instead of process IDs, and allows processes to be killed if the limit\n\
+    on processes that you can create is reached.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const let_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Evaluate arithmetic expressions.\n\
+    \n\
+    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n\
+    fixed-width integers with no check for overflow, though division by 0\n\
+    is trapped and flagged as an error.  The following list of operators is\n\
+    grouped into levels of equal-precedence operators.  The levels are listed\n\
+    in order of decreasing precedence.\n\
+    \n\
+    	id++, id--	variable post-increment, post-decrement\n\
+    	++id, --id	variable pre-increment, pre-decrement\n\
+    	-, +		unary minus, plus\n\
+    	!, ~		logical and bitwise negation\n\
+    	**		exponentiation\n\
+    	*, /, %		multiplication, division, remainder\n\
+    	+, -		addition, subtraction\n\
+    	<<, >>		left and right bitwise shifts\n\
+    	<=, >=, <, >	comparison\n\
+    	==, !=		equality, inequality\n\
+    	&		bitwise AND\n\
+    	^		bitwise XOR\n\
+    	|		bitwise OR\n\
+    	&&		logical AND\n\
+    	||		logical OR\n\
+    	expr ? expr : expr\n\
+    			conditional operator\n\
+    	=, *=, /=, %=,\n\
+    	+=, -=, <<=, >>=,\n\
+    	&=, ^=, |=	assignment\n\
+    \n\
+    Shell variables are allowed as operands.  The name of the variable\n\
+    is replaced by its value (coerced to a fixed-width integer) within\n\
+    an expression.  The variable need not have its integer attribute\n\
+    turned on to be used in an expression.\n\
+    \n\
+    Operators are evaluated in order of precedence.  Sub-expressions in\n\
+    parentheses are evaluated first and may override the precedence\n\
+    rules above.\n\
+    \n\
+    Exit Status:\n\
+    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise.."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const read_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Read a line from the standard input and split it into fields.\n\
+    \n\
+    Reads a single line from the standard input, or from file descriptor FD\n\
+    if the -u option is supplied.  The line is split into fields as with word\n\
+    splitting, and the first word is assigned to the first NAME, the second\n\
+    word to the second NAME, and so on, with any leftover words assigned to\n\
+    the last NAME.  Only the characters found in $IFS are recognized as word\n\
+    delimiters.\n\
+    \n\
+    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n\
+    \n\
+    Options:\n\
+      -a array	assign the words read to sequential indices of the array\n\
+    		variable ARRAY, starting at zero\n\
+      -d delim	continue until the first character of DELIM is read, rather\n\
+    		than newline\n\
+      -e		use Readline to obtain the line in an interactive shell\n\
+      -i text	Use TEXT as the initial text for Readline\n\
+      -n nchars	return after reading NCHARS characters rather than waiting\n\
+    		for a newline\n\
+      -p prompt	output the string PROMPT without a trailing newline before\n\
+    		attempting to read\n\
+      -r		do not allow backslashes to escape any characters\n\
+      -s		do not echo input coming from a terminal\n\
+      -t timeout	time out and return failure if a complete line of input is\n\
+    		not read withint TIMEOUT seconds.  The value of the TMOUT\n\
+    		variable is the default timeout.  TIMEOUT may be a\n\
+    		fractional number.  If TIMEOUT is 0, read returns success only\n\
+    		if input is available on the specified file descriptor.  The\n\
+    		exit status is greater than 128 if the timeout is exceeded\n\
+      -u fd		read from file descriptor FD instead of the standard input\n\
+    \n\
+    Exit Status:\n\
+    The return code is zero, unless end-of-file is encountered, read times out,\n\
+    or an invalid file descriptor is supplied as the argument to -u."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const return_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Return from a shell function.\n\
+    \n\
+    Causes a function or sourced script to exit with the return value\n\
+    specified by N.  If N is omitted, the return status is that of the\n\
+    last command executed within the function or script.\n\
+    \n\
+    Exit Status:\n\
+    Returns N, or failure if the shell is not executing a function or script."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const set_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Set or unset values of shell options and positional parameters.\n\
+    \n\
+    Change the value of shell attributes and positional parameters, or\n\
+    display the names and values of shell variables.\n\
+    \n\
+    Options:\n\
+      -a  Mark variables which are modified or created for export.\n\
+      -b  Notify of job termination immediately.\n\
+      -e  Exit immediately if a command exits with a non-zero status.\n\
+      -f  Disable file name generation (globbing).\n\
+      -h  Remember the location of commands as they are looked up.\n\
+      -k  All assignment arguments are placed in the environment for a\n\
+          command, not just those that precede the command name.\n\
+      -m  Job control is enabled.\n\
+      -n  Read commands but do not execute them.\n\
+      -o option-name\n\
+          Set the variable corresponding to option-name:\n\
+              allexport    same as -a\n\
+              braceexpand  same as -B\n\
+              emacs        use an emacs-style line editing interface\n\
+              errexit      same as -e\n\
+              errtrace     same as -E\n\
+              functrace    same as -T\n\
+              hashall      same as -h\n\
+              histexpand   same as -H\n\
+              history      enable command history\n\
+              ignoreeof    the shell will not exit upon reading EOF\n\
+              interactive-comments\n\
+                           allow comments to appear in interactive commands\n\
+              keyword      same as -k\n\
+              monitor      same as -m\n\
+              noclobber    same as -C\n\
+              noexec       same as -n\n\
+              noglob       same as -f\n\
+              nolog        currently accepted but ignored\n\
+              notify       same as -b\n\
+              nounset      same as -u\n\
+              onecmd       same as -t\n\
+              physical     same as -P\n\
+              pipefail     the return value of a pipeline is the status of\n\
+                           the last command to exit with a non-zero status,\n\
+                           or zero if no command exited with a non-zero status\n\
+              posix        change the behavior of bash where the default\n\
+                           operation differs from the Posix standard to\n\
+                           match the standard\n\
+              privileged   same as -p\n\
+              verbose      same as -v\n\
+              vi           use a vi-style line editing interface\n\
+              xtrace       same as -x\n\
+      -p  Turned on whenever the real and effective user ids do not match.\n\
+          Disables processing of the $ENV file and importing of shell\n\
+          functions.  Turning this option off causes the effective uid and\n\
+          gid to be set to the real uid and gid.\n\
+      -t  Exit after reading and executing one command.\n\
+      -u  Treat unset variables as an error when substituting.\n\
+      -v  Print shell input lines as they are read.\n\
+      -x  Print commands and their arguments as they are executed.\n\
+      -B  the shell will perform brace expansion\n\
+      -C  If set, disallow existing regular files to be overwritten\n\
+          by redirection of output.\n\
+      -E  If set, the ERR trap is inherited by shell functions.\n\
+      -H  Enable ! style history substitution.  This flag is on\n\
+          by default when the shell is interactive.\n\
+      -P  If set, do not follow symbolic links when executing commands\n\
+          such as cd which change the current directory.\n\
+      -T  If set, the DEBUG trap is inherited by shell functions.\n\
+      -   Assign any remaining arguments to the positional parameters.\n\
+          The -x and -v options are turned off.\n\
+    \n\
+    Using + rather than - causes these flags to be turned off.  The\n\
+    flags can also be used upon invocation of the shell.  The current\n\
+    set of flags may be found in $-.  The remaining n ARGs are positional\n\
+    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n\
+    ARGs are given, all shell variables are printed.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const unset_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Unset values and attributes of shell variables and functions.\n\
+    \n\
+    For each NAME, remove the corresponding variable or function.\n\
+    \n\
+    Options:\n\
+      -f	treat each NAME as a shell function\n\
+      -v	treat each NAME as a shell variable\n\
+    \n\
+    Without options, unset first tries to unset a variable, and if that fails,\n\
+    tries to unset a function.\n\
+    \n\
+    Some variables cannot be unset; also see `readonly'.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given or a NAME is read-only."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const export_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Set export attribute for shell variables.\n\
+    \n\
+    Marks each NAME for automatic export to the environment of subsequently\n\
+    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n\
+    \n\
+    Options:\n\
+      -f	refer to shell functions\n\
+      -n	remove the export property from each NAME\n\
+      -p	display a list of all exported variables and functions\n\
+    \n\
+    An argument of `--' disables further option processing.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given or NAME is invalid."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const readonly_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Mark shell variables as unchangeable.\n\
+    \n\
+    Mark each NAME as read-only; the values of these NAMEs may not be\n\
+    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n\
+    before marking as read-only.\n\
+    \n\
+    Options:\n\
+      -a	refer to indexed array variables\n\
+      -A	refer to associative array variables\n\
+      -f	refer to shell functions\n\
+      -p	display a list of all readonly variables and functions\n\
+    \n\
+    An argument of `--' disables further option processing.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given or NAME is invalid."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const shift_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Shift positional parameters.\n\
+    \n\
+    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n\
+    not given, it is assumed to be 1.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless N is negative or greater than $#."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const source_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute commands from a file in the current shell.\n\
+    \n\
+    Read and execute commands from FILENAME in the current shell.  The\n\
+    entries in $PATH are used to find the directory containing FILENAME.\n\
+    If any ARGUMENTS are supplied, they become the positional parameters\n\
+    when FILENAME is executed.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed in FILENAME; fails if\n\
+    FILENAME cannot be read."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const dot_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute commands from a file in the current shell.\n\
+    \n\
+    Read and execute commands from FILENAME in the current shell.  The\n\
+    entries in $PATH are used to find the directory containing FILENAME.\n\
+    If any ARGUMENTS are supplied, they become the positional parameters\n\
+    when FILENAME is executed.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed in FILENAME; fails if\n\
+    FILENAME cannot be read."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (JOB_CONTROL)
+char * const suspend_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Suspend shell execution.\n\
+    \n\
+    Suspend the execution of this shell until it receives a SIGCONT signal.\n\
+    Unless forced, login shells cannot be suspended.\n\
+    \n\
+    Options:\n\
+      -f	force the suspend, even if the shell is a login shell\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless job control is not enabled or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+char * const test_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Evaluate conditional expression.\n\
+    \n\
+    Exits with a status of 0 (true) or 1 (false) depending on\n\
+    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n\
+    expressions are often used to examine the status of a file.  There\n\
+    are string operators as well, and numeric comparison operators.\n\
+    \n\
+    File operators:\n\
+    \n\
+      -a FILE        True if file exists.\n\
+      -b FILE        True if file is block special.\n\
+      -c FILE        True if file is character special.\n\
+      -d FILE        True if file is a directory.\n\
+      -e FILE        True if file exists.\n\
+      -f FILE        True if file exists and is a regular file.\n\
+      -g FILE        True if file is set-group-id.\n\
+      -h FILE        True if file is a symbolic link.\n\
+      -L FILE        True if file is a symbolic link.\n\
+      -k FILE        True if file has its `sticky' bit set.\n\
+      -p FILE        True if file is a named pipe.\n\
+      -r FILE        True if file is readable by you.\n\
+      -s FILE        True if file exists and is not empty.\n\
+      -S FILE        True if file is a socket.\n\
+      -t FD          True if FD is opened on a terminal.\n\
+      -u FILE        True if the file is set-user-id.\n\
+      -w FILE        True if the file is writable by you.\n\
+      -x FILE        True if the file is executable by you.\n\
+      -O FILE        True if the file is effectively owned by you.\n\
+      -G FILE        True if the file is effectively owned by your group.\n\
+      -N FILE        True if the file has been modified since it was last read.\n\
+    \n\
+      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n\
+                       modification date).\n\
+    \n\
+      FILE1 -ot FILE2  True if file1 is older than file2.\n\
+    \n\
+      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n\
+    \n\
+    String operators:\n\
+    \n\
+      -z STRING      True if string is empty.\n\
+    \n\
+      -n STRING\n\
+         STRING      True if string is not empty.\n\
+    \n\
+      STRING1 = STRING2\n\
+                     True if the strings are equal.\n\
+      STRING1 != STRING2\n\
+                     True if the strings are not equal.\n\
+      STRING1 < STRING2\n\
+                     True if STRING1 sorts before STRING2 lexicographically.\n\
+      STRING1 > STRING2\n\
+                     True if STRING1 sorts after STRING2 lexicographically.\n\
+    \n\
+    Other operators:\n\
+    \n\
+      -o OPTION      True if the shell option OPTION is enabled.\n\
+      ! EXPR         True if expr is false.\n\
+      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n\
+      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n\
+    \n\
+      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n\
+                     -lt, -le, -gt, or -ge.\n\
+    \n\
+    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n\
+    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n\
+    than ARG2.\n\
+    \n\
+    Exit Status:\n\
+    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n\
+    false or an invalid argument is given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const test_bracket_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Evaluate conditional expression.\n\
+    \n\
+    This is a synonym for the \"test\" builtin, but the last argument must\n\
+    be a literal `]', to match the opening `['."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const times_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display process times.\n\
+    \n\
+    Prints the accumulated user and system times for the shell and all of its\n\
+    child processes.\n\
+    \n\
+    Exit Status:\n\
+    Always succeeds."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const trap_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Trap signals and other events.\n\
+    \n\
+    Defines and activates handlers to be run when the shell receives signals\n\
+    or other conditions.\n\
+    \n\
+    ARG is a command to be read and executed when the shell receives the\n\
+    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n\
+    is supplied) or `-', each specified signal is reset to its original\n\
+    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n\
+    shell and by the commands it invokes.\n\
+    \n\
+    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\n\
+    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.\n\
+    \n\
+    If no arguments are supplied, trap prints the list of commands associated\n\
+    with each signal.\n\
+    \n\
+    Options:\n\
+      -l	print a list of signal names and their corresponding numbers\n\
+      -p	display the trap commands associated with each SIGNAL_SPEC\n\
+    \n\
+    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n\
+    Signal names are case insensitive and the SIG prefix is optional.  A\n\
+    signal may be sent to the shell with \"kill -signal $$\".\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless a SIGSPEC is invalid or an invalid option is given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const type_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display information about command type.\n\
+    \n\
+    For each NAME, indicate how it would be interpreted if used as a\n\
+    command name.\n\
+    \n\
+    Options:\n\
+      -a	display all locations containing an executable named NAME;\n\
+    	includes aliases, builtins, and functions, if and only if\n\
+    	the `-p' option is not also used\n\
+      -f	suppress shell function lookup\n\
+      -P	force a PATH search for each NAME, even if it is an alias,\n\
+    	builtin, or function, and returns the name of the disk file\n\
+    	that would be executed\n\
+      -p	returns either the name of the disk file that would be executed,\n\
+    	or nothing if `type -t NAME' would not return `file'.\n\
+      -t	output a single word which is one of `alias', `keyword',\n\
+    	`function', `builtin', `file' or `', if NAME is an alias, shell\n\
+    	reserved word, shell function, shell builtin, disk file, or not\n\
+    	found, respectively\n\
+    \n\
+    Arguments:\n\
+      NAME	Command name to be interpreted.\n\
+    \n\
+    Exit Status:\n\
+    Returns success if all of the NAMEs are found; fails if any are not found."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if !defined (_MINIX)
+char * const ulimit_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Modify shell resource limits.\n\
+    \n\
+    Provides control over the resources available to the shell and processes\n\
+    it creates, on systems that allow such control.\n\
+    \n\
+    Options:\n\
+      -S	use the `soft' resource limit\n\
+      -H	use the `hard' resource limit\n\
+      -a	all current limits are reported\n\
+      -b	the socket buffer size\n\
+      -c	the maximum size of core files created\n\
+      -d	the maximum size of a process's data segment\n\
+      -e	the maximum scheduling priority (`nice')\n\
+      -f	the maximum size of files written by the shell and its children\n\
+      -i	the maximum number of pending signals\n\
+      -l	the maximum size a process may lock into memory\n\
+      -m	the maximum resident set size\n\
+      -n	the maximum number of open file descriptors\n\
+      -p	the pipe buffer size\n\
+      -q	the maximum number of bytes in POSIX message queues\n\
+      -r	the maximum real-time scheduling priority\n\
+      -s	the maximum stack size\n\
+      -t	the maximum amount of cpu time in seconds\n\
+      -u	the maximum number of user processes\n\
+      -v	the size of virtual memory\n\
+      -x	the maximum number of file locks\n\
+    \n\
+    If LIMIT is given, it is the new value of the specified resource; the\n\
+    special LIMIT values `soft', `hard', and `unlimited' stand for the\n\
+    current soft limit, the current hard limit, and no limit, respectively.\n\
+    Otherwise, the current value of the specified resource is printed.  If\n\
+    no option is given, then -f is assumed.\n\
+    \n\
+    Values are in 1024-byte increments, except for -t, which is in seconds,\n\
+    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n\
+    number of processes.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is supplied or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* !_MINIX */
+char * const umask_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display or set file mode mask.\n\
+    \n\
+    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n\
+    the current value of the mask.\n\
+    \n\
+    If MODE begins with a digit, it is interpreted as an octal number;\n\
+    otherwise it is a symbolic mode string like that accepted by chmod(1).\n\
+    \n\
+    Options:\n\
+      -p	if MODE is omitted, output in a form that may be reused as input\n\
+      -S	makes the output symbolic; otherwise an octal number is output\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless MODE is invalid or an invalid option is given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (JOB_CONTROL)
+char * const wait_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Wait for job completion and return exit status.\n\
+    \n\
+    Waits for the process identified by ID, which may be a process ID or a\n\
+    job specification, and reports its termination status.  If ID is not\n\
+    given, waits for all currently active child processes, and the return\n\
+    status is zero.  If ID is a a job specification, waits for all processes\n\
+    in the job's pipeline.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of ID; fails if ID is invalid or an invalid option is\n\
+    given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* JOB_CONTROL */
+#if !defined (JOB_CONTROL)
+char * const wait_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Wait for process completion and return exit status.\n\
+    \n\
+    Waits for the specified process and reports its termination status.  If\n\
+    PID is not given, all currently active child processes are waited for,\n\
+    and the return code is zero.  PID must be a process ID.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of ID; fails if ID is invalid or an invalid option is\n\
+    given."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* !JOB_CONTROL */
+char * const for_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute commands for each member in a list.\n\
+    \n\
+    The `for' loop executes a sequence of commands for each member in a\n\
+    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n\
+    assumed.  For each element in WORDS, NAME is set to that element, and\n\
+    the COMMANDS are executed.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const arith_for_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Arithmetic for loop.\n\
+    \n\
+    Equivalent to\n\
+    	(( EXP1 ))\n\
+    	while (( EXP2 )); do\n\
+    		COMMANDS\n\
+    		(( EXP3 ))\n\
+    	done\n\
+    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n\
+    omitted, it behaves as if it evaluates to 1.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const select_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Select words from a list and execute commands.\n\
+    \n\
+    The WORDS are expanded, generating a list of words.  The\n\
+    set of expanded words is printed on the standard error, each\n\
+    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n\
+    is assumed.  The PS3 prompt is then displayed and a line read\n\
+    from the standard input.  If the line consists of the number\n\
+    corresponding to one of the displayed words, then NAME is set\n\
+    to that word.  If the line is empty, WORDS and the prompt are\n\
+    redisplayed.  If EOF is read, the command completes.  Any other\n\
+    value read causes NAME to be set to null.  The line read is saved\n\
+    in the variable REPLY.  COMMANDS are executed after each selection\n\
+    until a break command is executed.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const time_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Report time consumed by pipeline's execution.\n\
+    \n\
+    Execute PIPELINE and print a summary of the real time, user CPU time,\n\
+    and system CPU time spent executing PIPELINE when it terminates.\n\
+    \n\
+    Options:\n\
+      -p	print the timing summary in the portable Posix format\n\
+    \n\
+    The value of the TIMEFORMAT variable is used as the output format.\n\
+    \n\
+    Exit Status:\n\
+    The return status is the return status of PIPELINE."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const case_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute commands based on pattern matching.\n\
+    \n\
+    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n\
+    `|' is used to separate multiple patterns.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const if_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute commands based on conditional.\n\
+    \n\
+    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n\
+    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n\
+    executed in turn, and if its exit status is zero, the corresponding\n\
+    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n\
+    the `else COMMANDS' list is executed, if present.  The exit status of the\n\
+    entire construct is the exit status of the last command executed, or zero\n\
+    if no condition tested true.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const while_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute commands as long as a test succeeds.\n\
+    \n\
+    Expand and execute COMMANDS as long as the final command in the\n\
+    `while' COMMANDS has an exit status of zero.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const until_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute commands as long as a test does not succeed.\n\
+    \n\
+    Expand and execute COMMANDS as long as the final command in the\n\
+    `until' COMMANDS has an exit status which is not zero.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const coproc_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Create a coprocess named NAME.\n\
+    \n\
+    Execute COMMAND asynchronously, with the standard output and standard\n\
+    input of the command connected via a pipe to file descriptors assigned\n\
+    to indices 0 and 1 of an array variable NAME in the executing shell.\n\
+    The default NAME is \"COPROC\".\n\
+    \n\
+    Exit Status:\n\
+    Returns the exit status of COMMAND."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const function_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Define shell function.\n\
+    \n\
+    Create a shell function named NAME.  When invoked as a simple command,\n\
+    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n\
+    the arguments are passed to the function as $1...$n, and the function's\n\
+    name is in $FUNCNAME.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless NAME is readonly."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const grouping_braces_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Group commands as a unit.\n\
+    \n\
+    Run a set of commands in a group.  This is one way to redirect an\n\
+    entire set of commands.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the last command executed."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const fg_percent_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Resume job in foreground.\n\
+    \n\
+    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n\
+    stopped or background job.  JOB_SPEC can specify either a job name\n\
+    or a job number.  Following JOB_SPEC with a `&' places the job in\n\
+    the background, as if the job specification had been supplied as an\n\
+    argument to `bg'.\n\
+    \n\
+    Exit Status:\n\
+    Returns the status of the resumed job."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const arith_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Evaluate arithmetic expression.\n\
+    \n\
+    The EXPRESSION is evaluated according to the rules for arithmetic\n\
+    evaluation.  Equivalent to \"let EXPRESSION\".\n\
+    \n\
+    Exit Status:\n\
+    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const conditional_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Execute conditional command.\n\
+    \n\
+    Returns a status of 0 or 1 depending on the evaluation of the conditional\n\
+    expression EXPRESSION.  Expressions are composed of the same primaries used\n\
+    by the `test' builtin, and may be combined using the following operators:\n\
+    \n\
+      ( EXPRESSION )	Returns the value of EXPRESSION\n\
+      ! EXPRESSION		True if EXPRESSION is false; else false\n\
+      EXPR1 && EXPR2	True if both EXPR1 and EXPR2 are true; else false\n\
+      EXPR1 || EXPR2	True if either EXPR1 or EXPR2 is true; else false\n\
+    \n\
+    When the `==' and `!=' operators are used, the string to the right of\n\
+    the operator is used as a pattern and pattern matching is performed.\n\
+    When the `=~' operator is used, the string to the right of the operator\n\
+    is matched as a regular expression.\n\
+    \n\
+    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n\
+    determine the expression's value.\n\
+    \n\
+    Exit Status:\n\
+    0 or 1 depending on value of EXPRESSION."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const variable_help_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Common shell variable names and usage.\n\
+    \n\
+    BASH_VERSION	Version information for this Bash.\n\
+    CDPATH	A colon-separated list of directories to search\n\
+    		for directories given as arguments to `cd'.\n\
+    GLOBIGNORE	A colon-separated list of patterns describing filenames to\n\
+    		be ignored by pathname expansion.\n\
+    HISTFILE	The name of the file where your command history is stored.\n\
+    HISTFILESIZE	The maximum number of lines this file can contain.\n\
+    HISTSIZE	The maximum number of history lines that a running\n\
+    		shell can access.\n\
+    HOME	The complete pathname to your login directory.\n\
+    HOSTNAME	The name of the current host.\n\
+    HOSTTYPE	The type of CPU this version of Bash is running under.\n\
+    IGNOREEOF	Controls the action of the shell on receipt of an EOF\n\
+    		character as the sole input.  If set, then the value\n\
+    		of it is the number of EOF characters that can be seen\n\
+    		in a row on an empty line before the shell will exit\n\
+    		(default 10).  When unset, EOF signifies the end of input.\n\
+    MACHTYPE	A string describing the current system Bash is running on.\n\
+    MAILCHECK	How often, in seconds, Bash checks for new mail.\n\
+    MAILPATH	A colon-separated list of filenames which Bash checks\n\
+    		for new mail.\n\
+    OSTYPE	The version of Unix this version of Bash is running on.\n\
+    PATH	A colon-separated list of directories to search when\n\
+    		looking for commands.\n\
+    PROMPT_COMMAND	A command to be executed before the printing of each\n\
+    		primary prompt.\n\
+    PS1		The primary prompt string.\n\
+    PS2		The secondary prompt string.\n\
+    PWD		The full pathname of the current directory.\n\
+    SHELLOPTS	A colon-separated list of enabled shell options.\n\
+    TERM	The name of the current terminal type.\n\
+    TIMEFORMAT	The output format for timing statistics displayed by the\n\
+    		`time' reserved word.\n\
+    auto_resume	Non-null means a command word appearing on a line by\n\
+    		itself is first looked for in the list of currently\n\
+    		stopped jobs.  If found there, that job is foregrounded.\n\
+    		A value of `exact' means that the command word must\n\
+    		exactly match a command in the list of stopped jobs.  A\n\
+    		value of `substring' means that the command word must\n\
+    		match a substring of the job.  Any other value means that\n\
+    		the command must be a prefix of a stopped job.\n\
+    histchars	Characters controlling history expansion and quick\n\
+    		substitution.  The first character is the history\n\
+    		substitution character, usually `!'.  The second is\n\
+    		the `quick substitution' character, usually `^'.  The\n\
+    		third is the `history comment' character, usually `#'.\n\
+    HISTIGNORE	A colon-separated list of patterns used to decide which\n\
+    		commands should be saved on the history list.\n\
+"),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (PUSHD_AND_POPD)
+char * const pushd_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Add directories to stack.\n\
+    \n\
+    Adds a directory to the top of the directory stack, or rotates\n\
+    the stack, making the new top of the stack the current working\n\
+    directory.  With no arguments, exchanges the top two directories.\n\
+    \n\
+    Options:\n\
+      -n	Suppresses the normal change of directory when adding\n\
+    	directories to the stack, so only the stack is manipulated.\n\
+    \n\
+    Arguments:\n\
+      +N	Rotates the stack so that the Nth directory (counting\n\
+    	from the left of the list shown by `dirs', starting with\n\
+    	zero) is at the top.\n\
+    \n\
+      -N	Rotates the stack so that the Nth directory (counting\n\
+    	from the right of the list shown by `dirs', starting with\n\
+    	zero) is at the top.\n\
+    \n\
+      dir	Adds DIR to the directory stack at the top, making it the\n\
+    	new current working directory.\n\
+    \n\
+    The `dirs' builtin displays the directory stack.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid argument is supplied or the directory\n\
+    change fails."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* PUSHD_AND_POPD */
+#if defined (PUSHD_AND_POPD)
+char * const popd_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Remove directories from stack.\n\
+    \n\
+    Removes entries from the directory stack.  With no arguments, removes\n\
+    the top directory from the stack, and changes to the new top directory.\n\
+    \n\
+    Options:\n\
+      -n	Suppresses the normal change of directory when removing\n\
+    	directories from the stack, so only the stack is manipulated.\n\
+    \n\
+    Arguments:\n\
+      +N	Removes the Nth entry counting from the left of the list\n\
+    	shown by `dirs', starting with zero.  For example: `popd +0'\n\
+    	removes the first directory, `popd +1' the second.\n\
+    \n\
+      -N	Removes the Nth entry counting from the right of the list\n\
+    	shown by `dirs', starting with zero.  For example: `popd -0'\n\
+    	removes the last directory, `popd -1' the next to last.\n\
+    \n\
+    The `dirs' builtin displays the directory stack.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid argument is supplied or the directory\n\
+    change fails."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* PUSHD_AND_POPD */
+#if defined (PUSHD_AND_POPD)
+char * const dirs_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display directory stack.\n\
+    \n\
+    Display the list of currently remembered directories.  Directories\n\
+    find their way onto the list with the `pushd' command; you can get\n\
+    back up through the list with the `popd' command.\n\
+    \n\
+    Options:\n\
+      -c	clear the directory stack by deleting all of the elements\n\
+      -l	do not print tilde-prefixed versions of directories relative\n\
+    	to your home directory\n\
+      -p	print the directory stack with one entry per line\n\
+      -v	print the directory stack with one entry per line prefixed\n\
+    	with its position in the stack\n\
+    \n\
+    Arguments:\n\
+      +N	Displays the Nth entry counting from the left of the list shown by\n\
+    	dirs when invoked without options, starting with zero.\n\
+    \n\
+      -N	Displays the Nth entry counting from the right of the list shown by\n\
+    	dirs when invoked without options, starting with zero.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is supplied or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* PUSHD_AND_POPD */
+char * const shopt_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Set and unset shell options.\n\
+    \n\
+    Change the setting of each shell option OPTNAME.  Without any option\n\
+    arguments, list all shell options with an indication of whether or not each\n\
+    is set.\n\
+    \n\
+    Options:\n\
+      -o	restrict OPTNAMEs to those defined for use with `set -o'\n\
+      -p	print each shell option with an indication of its status\n\
+      -q	suppress output\n\
+      -s	enable (set) each OPTNAME\n\
+      -u	disable (unset) each OPTNAME\n\
+    \n\
+    Exit Status:\n\
+    Returns success if OPTNAME is enabled; fails if an invalid option is\n\
+    given or OPTNAME is disabled."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const printf_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Formats and prints ARGUMENTS under control of the FORMAT.\n\
+    \n\
+    Options:\n\
+      -v var	assign the output to shell variable VAR rather than\n\
+    		display it on the standard output\n\
+    \n\
+    FORMAT is a character string which contains three types of objects: plain\n\
+    characters, which are simply copied to standard output; character escape\n\
+    sequences, which are converted and copied to the standard output; and\n\
+    format specifications, each of which causes printing of the next successive\n\
+    argument.\n\
+    \n\
+    In addition to the standard format specifications described in printf(1)\n\
+    and printf(3), printf interprets:\n\
+    \n\
+      %b	expand backslash escape sequences in the corresponding argument\n\
+      %q	quote the argument in a way that can be reused as shell input\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given or a write or assignment\n\
+    error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#if defined (PROGRAMMABLE_COMPLETION)
+char * const complete_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Specify how arguments are to be completed by Readline.\n\
+    \n\
+    For each NAME, specify how arguments are to be completed.  If no options\n\
+    are supplied, existing completion specifications are printed in a way that\n\
+    allows them to be reused as input.\n\
+    \n\
+    Options:\n\
+      -p	print existing completion specifications in a reusable format\n\
+      -r	remove a completion specification for each NAME, or, if no\n\
+    	NAMEs are supplied, all completion specifications\n\
+    \n\
+    When completion is attempted, the actions are applied in the order the\n\
+    uppercase-letter options are listed above.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is supplied or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* PROGRAMMABLE_COMPLETION */
+#if defined (PROGRAMMABLE_COMPLETION)
+char * const compgen_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Display possible completions depending on the options.\n\
+    \n\
+    Intended to be used from within a shell function generating possible\n\
+    completions.  If the optional WORD argument is supplied, matches against\n\
+    WORD are generated.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is supplied or an error occurs."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* PROGRAMMABLE_COMPLETION */
+#if defined (PROGRAMMABLE_COMPLETION)
+char * const compopt_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Modify or display completion options.\n\
+    \n\
+    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n\
+    the completion currently begin executed.  If no OPTIONs are givenm, print\n\
+    the completion options for each NAME or the current completion specification.\n\
+    \n\
+    Options:\n\
+    	-o option	Set completion option OPTION for each NAME\n\
+    \n\
+    Using `+o' instead of `-o' turns off the specified option.\n\
+    \n\
+    Arguments:\n\
+    \n\
+    Each NAME refers to a command for which a completion specification must\n\
+    have previously been defined using the `complete' builtin.  If no NAMEs\n\
+    are supplied, compopt must be called by a function currently generating\n\
+    completions, and the options for that currently-executing completion\n\
+    generator are modified.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is supplied or NAME does not\n\
+    have a completion specification defined."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+#endif /* PROGRAMMABLE_COMPLETION */
+char * const mapfile_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Read lines from the standard input into an array variable.\n\
+    \n\
+    Read lines from the standard input into the array variable ARRAY, or from\n\
+    file descriptor FD if the -u option is supplied.  The variable MAPFILE is\n\
+    the default ARRAY.\n\
+    \n\
+    Options:\n\
+      -n count	Copy at most COUNT lines.  If COUNT is 0, all lines are copied.\n\
+      -O origin	Begin assigning to ARRAY at index ORIGIN.  The default index is 0.\n\
+      -s count 	Discard the first COUNT lines read.\n\
+      -t		Remove a trailing newline from each line read.\n\
+      -u fd		Read lines from file descriptor FD instead of the standard input.\n\
+      -C callback	Evaluate CALLBACK each time QUANTUM lines are read.\n\
+      -c quantum	Specify the number of lines read between each call to CALLBACK.\n\
+    \n\
+    Arguments:\n\
+      ARRAY		Array variable name to use for file data.\n\
+    \n\
+    If -C is supplied without -c, the default quantum is 5000.  When\n\
+    CALLBACK is evaluated, it is supplied the index of the next array\n\
+    element to be assigned as an additional argument.\n\
+    \n\
+    If not supplied with an explicit origin, mapfile will clear ARRAY before\n\
+    assigning to it.\n\
+    \n\
+    Exit Status:\n\
+    Returns success unless an invalid option is given or ARRAY is readonly."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
+char * const readarray_doc[] = {
+#if defined (HELP_BUILTIN)
+N_("Read lines from a file into an array variable.\n\
+    \n\
+    A synonym for `mapfile'."),
+#endif /* HELP_BUILTIN */
+  (char *)NULL
+};
diff -Nru bash-4.0-orig/builtins/caller.c bash-4.0/builtins/caller.c
--- bash-4.0-orig/builtins/caller.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/caller.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,118 @@
+/* caller.c, created from caller.def. */
+#line 22 "./caller.def"
+
+#line 40 "./caller.def"
+
+#include <config.h>
+#include <stdio.h>
+#include "chartypes.h"
+#include "bashtypes.h"
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <errno.h>
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+#include "builtext.h"
+#include "bashgetopt.h"
+
+#ifdef LOADABLE_BUILTIN
+#  include "builtins.h"
+#endif
+
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+int
+caller_builtin (list)
+     WORD_LIST *list;
+{
+#if !defined (ARRAY_VARS)
+  printf ("1 NULL\n");
+  return (EXECUTION_FAILURE);
+#else
+  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
+  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
+  char *funcname_s, *source_s, *lineno_s;
+  intmax_t num;
+
+  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
+  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
+  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
+
+  if (bash_lineno_a == 0 || array_empty (bash_lineno_a))
+    return (EXECUTION_FAILURE);
+
+  if (bash_source_a == 0 || array_empty (bash_source_a))
+    return (EXECUTION_FAILURE);
+
+ if (no_options (list))
+    return (EX_USAGE);
+  list = loptend;       /* skip over possible `--' */
+
+  /* If there is no argument list, then give short form: line filename. */
+  if (list == 0)
+    {
+      lineno_s = array_reference (bash_lineno_a, 0);
+      source_s = array_reference (bash_source_a, 1);
+      printf("%s %s\n", lineno_s ? lineno_s : "NULL", source_s ? source_s : "NULL");
+      return (EXECUTION_SUCCESS);
+    }
+  
+  if (funcname_a == 0 || array_empty (funcname_a))
+    return (EXECUTION_FAILURE);
+
+  if (legal_number (list->word->word, &num))
+    {
+      lineno_s = array_reference (bash_lineno_a, num);
+      source_s = array_reference (bash_source_a, num+1);
+      funcname_s = array_reference (funcname_a, num+1);
+
+      if (lineno_s == NULL|| source_s == NULL || funcname_s == NULL)
+	return (EXECUTION_FAILURE);
+
+      printf("%s %s %s\n", lineno_s, funcname_s, source_s);
+    }
+  else
+    {
+      sh_invalidnum (list->word->word);
+      builtin_usage ();
+      return (EXECUTION_FAILURE);
+    }
+
+  return (EXECUTION_SUCCESS);
+#endif
+}
+
+#ifdef LOADABLE_BUILTIN
+static char *caller_doc[] = {
+N_("Returns the context of the current subroutine call.\n\
+    \n\
+    Without EXPR, returns "$line $filename".  With EXPR, returns\n\
+    "$line $subroutine $filename"; this extra information can be used to\n\
+    provide a stack trace.\n\
+    \n\
+    The value of EXPR indicates how many call frames to go back before the\n\
+    current one; the top frame is frame 0."),
+  (char *)NULL
+};
+
+struct builtin caller_struct = {
+	"caller",
+	caller_builtin,
+	BUILTIN_ENABLED,
+	caller_doc,
+	"caller [EXPR]",
+	0
+};
+
+#endif /* LOADABLE_BUILTIN */
diff -Nru bash-4.0-orig/builtins/cd.c bash-4.0/builtins/cd.c
--- bash-4.0-orig/builtins/cd.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/cd.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,453 @@
+/* cd.c, created from cd.def. */
+#line 22 "./cd.def"
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashtypes.h"
+#include "posixdir.h"
+#include "posixstat.h"
+#ifndef _MINIX
+#include <sys/param.h>
+#endif
+
+#include <stdio.h>
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include <errno.h>
+#include <tilde/tilde.h>
+
+#include "../shell.h"
+#include "../flags.h"
+#include "maxpath.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+extern int posixly_correct;
+extern int array_needs_making;
+extern const char * const bash_getcwd_errstr;
+
+static int bindpwd __P((int));
+static void setpwd __P((char *));
+static char *resetpwd __P((char *));
+static int change_to_directory __P((char *, int));
+
+/* Change this to 1 to get cd spelling correction by default. */
+int cdspelling = 0;
+
+int cdable_vars;
+
+#line 97 "./cd.def"
+
+/* Just set $PWD, don't change OLDPWD.  Used by `pwd -P' in posix mode. */
+static void
+setpwd (dirname)
+     char *dirname;
+{
+  int old_anm;
+  SHELL_VAR *tvar;
+
+  old_anm = array_needs_making;
+  tvar = bind_variable ("PWD", dirname ? dirname : "", 0);
+  if (old_anm == 0 && array_needs_making && exported_p (tvar))
+    {
+      update_export_env_inplace ("PWD=", 4, dirname ? dirname : "");
+      array_needs_making = 0;
+    }
+}
+
+static int
+bindpwd (no_symlinks)
+     int no_symlinks;
+{
+  char *dirname, *pwdvar;
+  int old_anm, r;
+  SHELL_VAR *tvar;
+
+  r = sh_chkwrite (EXECUTION_SUCCESS);
+
+#define tcwd the_current_working_directory
+  dirname = tcwd ? (no_symlinks ? sh_physpath (tcwd, 0) : tcwd)
+  		 : get_working_directory ("cd");
+#undef tcwd
+
+  old_anm = array_needs_making;
+  pwdvar = get_string_value ("PWD");
+
+  tvar = bind_variable ("OLDPWD", pwdvar, 0);
+  if (old_anm == 0 && array_needs_making && exported_p (tvar))
+    {
+      update_export_env_inplace ("OLDPWD=", 7, pwdvar);
+      array_needs_making = 0;
+    }
+
+  setpwd (dirname);
+
+  if (dirname && dirname != the_current_working_directory)
+    free (dirname);
+
+  return (r);
+}
+
+/* Call get_working_directory to reset the value of
+   the_current_working_directory () */
+static char *
+resetpwd (caller)
+     char *caller;
+{
+  char *tdir;
+      
+  FREE (the_current_working_directory);
+  the_current_working_directory = (char *)NULL;
+  tdir = get_working_directory (caller);
+  return (tdir);
+}
+
+#define LCD_DOVARS	0x001
+#define LCD_DOSPELL	0x002
+#define LCD_PRINTPATH	0x004
+#define LCD_FREEDIRNAME	0x010
+
+/* This builtin is ultimately the way that all user-visible commands should
+   change the current working directory.  It is called by cd_to_string (),
+   so the programming interface is simple, and it handles errors and
+   restrictions properly. */
+int
+cd_builtin (list)
+     WORD_LIST *list;
+{
+  char *dirname, *cdpath, *path, *temp;
+  int path_index, no_symlinks, opt, lflag;
+
+#if defined (RESTRICTED_SHELL)
+  if (restricted)
+    {
+      sh_restricted ((char *)NULL);
+      return (EXECUTION_FAILURE);
+    }
+#endif /* RESTRICTED_SHELL */
+
+  no_symlinks = no_symbolic_links;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "LP")) != -1)
+    {
+      switch (opt)
+	{
+	case 'P':
+	  no_symlinks = 1;
+	  break;
+	case 'L':
+	  no_symlinks = 0;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EXECUTION_FAILURE);
+	}
+    }
+  list = loptend;
+
+  lflag = (cdable_vars ? LCD_DOVARS : 0) |
+	  ((interactive && cdspelling) ? LCD_DOSPELL : 0);
+
+  if (list == 0)
+    {
+      /* `cd' without arguments is equivalent to `cd $HOME' */
+      dirname = get_string_value ("HOME");
+
+      if (dirname == 0)
+	{
+	  builtin_error (_("HOME not set"));
+	  return (EXECUTION_FAILURE);
+	}
+      lflag = 0;
+    }
+  else if (list->word->word[0] == '-' && list->word->word[1] == '\0')
+    {
+      /* This is `cd -', equivalent to `cd $OLDPWD' */
+      dirname = get_string_value ("OLDPWD");
+
+      if (dirname == 0)
+	{
+	  builtin_error (_("OLDPWD not set"));
+	  return (EXECUTION_FAILURE);
+	}
+#if 0
+      lflag = interactive ? LCD_PRINTPATH : 0;
+#else
+      lflag = LCD_PRINTPATH;		/* According to SUSv3 */
+#endif
+    }
+  else if (absolute_pathname (list->word->word))
+    dirname = list->word->word;
+  else if (privileged_mode == 0 && (cdpath = get_string_value ("CDPATH")))
+    {
+      dirname = list->word->word;
+
+      /* Find directory in $CDPATH. */
+      path_index = 0;
+      while (path = extract_colon_unit (cdpath, &path_index))
+	{
+	  /* OPT is 1 if the path element is non-empty */
+	  opt = path[0] != '\0';
+	  temp = sh_makepath (path, dirname, MP_DOTILDE);
+	  free (path);
+
+	  if (change_to_directory (temp, no_symlinks))
+	    {
+	      /* POSIX.2 says that if a nonempty directory from CDPATH
+		 is used to find the directory to change to, the new
+		 directory name is echoed to stdout, whether or not
+		 the shell is interactive. */
+	      if (opt && (path = no_symlinks ? temp : the_current_working_directory))
+		printf ("%s\n", path);
+
+	      free (temp);
+#if 0
+	      /* Posix.2 says that after using CDPATH, the resultant
+		 value of $PWD will not contain `.' or `..'. */
+	      return (bindpwd (posixly_correct || no_symlinks));
+#else
+	      return (bindpwd (no_symlinks));
+#endif
+	    }
+	  else
+	    free (temp);
+	}
+
+      /* POSIX.2 says that if `.' does not appear in $CDPATH, we don't
+	 try the current directory, so we just punt now with an error
+	 message if POSIXLY_CORRECT is non-zero.  The check for cdpath[0]
+	 is so we don't mistakenly treat a CDPATH value of "" as not
+	 specifying the current directory. */
+      if (posixly_correct && cdpath[0])
+	{
+	  builtin_error ("%s: %s", dirname, strerror (ENOENT));
+	  return (EXECUTION_FAILURE);
+	}
+    }
+  else
+    dirname = list->word->word;
+
+  /* When we get here, DIRNAME is the directory to change to.  If we
+     chdir successfully, just return. */
+  if (change_to_directory (dirname, no_symlinks))
+    {
+      if (lflag & LCD_PRINTPATH)
+	printf ("%s\n", dirname);
+      return (bindpwd (no_symlinks));
+    }
+
+  /* If the user requests it, then perhaps this is the name of
+     a shell variable, whose value contains the directory to
+     change to. */
+  if (lflag & LCD_DOVARS)
+    {
+      temp = get_string_value (dirname);
+      if (temp && change_to_directory (temp, no_symlinks))
+	{
+	  printf ("%s\n", temp);
+	  return (bindpwd (no_symlinks));
+	}
+    }
+
+  /* If the user requests it, try to find a directory name similar in
+     spelling to the one requested, in case the user made a simple
+     typo.  This is similar to the UNIX 8th and 9th Edition shells. */
+  if (lflag & LCD_DOSPELL)
+    {
+      temp = dirspell (dirname);
+      if (temp && change_to_directory (temp, no_symlinks))
+	{
+	  printf ("%s\n", temp);
+	  return (bindpwd (no_symlinks));
+	}
+      else
+	FREE (temp);
+    }
+
+  builtin_error ("%s: %s", dirname, strerror (errno));
+  return (EXECUTION_FAILURE);
+}
+
+#line 344 "./cd.def"
+
+/* Non-zero means that pwd always prints the physical directory, without
+   symbolic links. */
+static int verbatim_pwd;
+
+/* Print the name of the current working directory. */
+int
+pwd_builtin (list)
+     WORD_LIST *list;
+{
+  char *directory;
+  int opt, pflag;
+
+  verbatim_pwd = no_symbolic_links;
+  pflag = 0;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "LP")) != -1)
+    {
+      switch (opt)
+	{
+	case 'P':
+	  verbatim_pwd = pflag = 1;
+	  break;
+	case 'L':
+	  verbatim_pwd = 0;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EXECUTION_FAILURE);
+	}
+    }
+  list = loptend;
+
+#define tcwd the_current_working_directory
+
+  directory = tcwd ? (verbatim_pwd ? sh_physpath (tcwd, 0) : tcwd)
+		   : get_working_directory ("pwd");
+
+  /* Try again using getcwd() if canonicalization fails (for instance, if
+     the file system has changed state underneath bash). */
+  if ((tcwd && directory == 0) ||
+      (posixly_correct && same_file (".", tcwd, (struct stat *)0, (struct stat *)0) == 0))
+    directory = resetpwd ("pwd");
+
+#undef tcwd
+
+  if (directory)
+    {
+      printf ("%s\n", directory);
+      /* This is dumb but posix-mandated. */
+      if (posixly_correct && pflag)
+	setpwd (directory);
+      if (directory != the_current_working_directory)
+	free (directory);
+      return (sh_chkwrite (EXECUTION_SUCCESS));
+    }
+  else
+    return (EXECUTION_FAILURE);
+}
+
+/* Do the work of changing to the directory NEWDIR.  Handle symbolic
+   link following, etc.  This function *must* return with
+   the_current_working_directory either set to NULL (in which case
+   getcwd() will eventually be called), or set to a string corresponding
+   to the working directory.  Return 1 on success, 0 on failure. */
+
+static int
+change_to_directory (newdir, nolinks)
+     char *newdir;
+     int nolinks;
+{
+  char *t, *tdir;
+  int err, canon_failed, r, ndlen, dlen;
+
+  tdir = (char *)NULL;
+
+  if (the_current_working_directory == 0)
+    {
+      t = get_working_directory ("chdir");
+      FREE (t);
+    }
+
+  t = make_absolute (newdir, the_current_working_directory);
+
+  /* TDIR is either the canonicalized absolute pathname of NEWDIR
+     (nolinks == 0) or the absolute physical pathname of NEWDIR
+     (nolinks != 0). */
+  tdir = nolinks ? sh_physpath (t, 0)
+		 : sh_canonpath (t, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);
+
+  ndlen = strlen (newdir);
+  dlen = strlen (t);
+
+  /* Use the canonicalized version of NEWDIR, or, if canonicalization
+     failed, use the non-canonical form. */
+  canon_failed = 0;
+  if (tdir && *tdir)
+    free (t);
+  else
+    {
+      FREE (tdir);
+      tdir = t;
+      canon_failed = 1;
+    }
+
+  /* In POSIX mode, if we're resolving symlinks logically and sh_canonpath
+     returns NULL (because it checks the path, it will return NULL if the
+     resolved path doesn't exist), fail immediately. */
+  if (posixly_correct && nolinks == 0 && canon_failed && (errno != ENAMETOOLONG || ndlen > PATH_MAX))
+    {
+#if defined ENAMETOOLONG
+      if (errno != ENOENT && errno != ENAMETOOLONG)
+#else
+      if (errno != ENOENT)
+#endif
+	errno = ENOTDIR;
+      free (tdir);
+      return (0);
+    }
+
+  /* If the chdir succeeds, update the_current_working_directory. */
+  if (chdir (nolinks ? newdir : tdir) == 0)
+    {
+      /* If canonicalization failed, but the chdir succeeded, reset the
+	 shell's idea of the_current_working_directory. */
+      if (canon_failed)
+	{
+	  t = resetpwd ("cd");
+	  if (t == 0)
+	    set_working_directory (tdir);
+	}
+      else
+	set_working_directory (tdir);
+
+      free (tdir);
+      return (1);
+    }
+
+  /* We failed to change to the appropriate directory name.  If we tried
+     what the user passed (nolinks != 0), punt now. */
+  if (nolinks)
+    {
+      free (tdir);
+      return (0);
+    }
+
+  err = errno;
+
+  /* We're not in physical mode (nolinks == 0), but we failed to change to
+     the canonicalized directory name (TDIR).  Try what the user passed
+     verbatim. If we succeed, reinitialize the_current_working_directory. */
+  if (chdir (newdir) == 0)
+    {
+      t = resetpwd ("cd");
+      if (t == 0)
+	set_working_directory (tdir);
+      else
+	free (t);
+
+      r = 1;
+    }
+  else
+    {
+      errno = err;
+      r = 0;
+    }
+
+  free (tdir);
+  return r;
+}
diff -Nru bash-4.0-orig/builtins/colon.c bash-4.0/builtins/colon.c
--- bash-4.0-orig/builtins/colon.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/colon.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,24 @@
+/* colon.c, created from colon.def. */
+#line 22 "./colon.def"
+
+#line 34 "./colon.def"
+
+#line 43 "./colon.def"
+
+#line 52 "./colon.def"
+
+/* Return a successful result. */
+int
+colon_builtin (ignore)
+     char *ignore;
+{
+  return (0);
+}
+
+/* Return an unsuccessful result. */
+int
+false_builtin (ignore)
+     char *ignore;
+{
+  return (1);
+}
diff -Nru bash-4.0-orig/builtins/command.c bash-4.0/builtins/command.c
--- bash-4.0-orig/builtins/command.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/command.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,178 @@
+/* command.c, created from command.def. */
+#line 22 "./command.def"
+
+#line 41 "./command.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+
+#include "../shell.h"
+#include "../execute_cmd.h"
+#include "../flags.h"
+#include "bashgetopt.h"
+#include "common.h"
+
+#if defined (_CS_PATH) && defined (HAVE_CONFSTR) && !HAVE_DECL_CONFSTR
+extern size_t confstr __P((int, char *, size_t));
+#endif
+
+extern int subshell_environment;
+
+static void restore_path __P((char *));
+static char *get_standard_path __P((void));
+
+/* Run the commands mentioned in LIST without paying attention to shell
+   functions. */
+int
+command_builtin (list)
+     WORD_LIST *list;
+{
+  int result, verbose, use_standard_path, opt;
+  char *old_path, *standard_path;
+  COMMAND *command;
+
+  verbose = use_standard_path = 0;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "pvV")) != -1)
+    {
+      switch (opt)
+	{
+	case 'p':
+	  use_standard_path = 1;
+	  break;
+	case 'V':
+	  verbose = CDESC_SHORTDESC|CDESC_ABSPATH;	/* look in common.h for constants */
+	  break;
+	case 'v':
+	  verbose = CDESC_REUSABLE;	/* ditto */
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  if (list == 0)
+    return (EXECUTION_SUCCESS);
+
+  if (verbose)
+    {
+      int found, any_found;
+
+      for (any_found = 0; list; list = list->next)
+	{
+	  found = describe_command (list->word->word, verbose);
+
+	  if (found == 0 && verbose != CDESC_REUSABLE)
+	    sh_notfound (list->word->word);
+
+	  any_found += found;
+	}
+      return (any_found ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+    }
+
+#if defined (RESTRICTED_SHELL)
+  if (use_standard_path && restricted)
+    {
+      sh_restricted ("-p");
+      return (EXECUTION_FAILURE);
+    }
+#endif
+
+  begin_unwind_frame ("command_builtin");
+
+  /* We don't want this to be reparsed (consider command echo 'foo &'), so
+     just make a simple_command structure and call execute_command with it. */
+  if (use_standard_path)
+    {      
+      old_path = get_string_value ("PATH");
+      /* If old_path is NULL, $PATH is unset.  If so, we want to make sure
+	 it's unset after this command completes. */
+      if (old_path)
+	old_path = savestring (old_path);
+      add_unwind_protect ((Function *)restore_path, old_path);
+
+      standard_path = get_standard_path ();
+      bind_variable ("PATH", standard_path ? standard_path : "", 0);
+      FREE (standard_path);
+    }
+
+#define COMMAND_BUILTIN_FLAGS (CMD_NO_FUNCTIONS | CMD_INHIBIT_EXPANSION | CMD_COMMAND_BUILTIN)
+
+  command = make_bare_simple_command ();
+  command->value.Simple->words = (WORD_LIST *)copy_word_list (list);
+  command->value.Simple->redirects = (REDIRECT *)NULL;
+  command->flags |= COMMAND_BUILTIN_FLAGS;
+  command->value.Simple->flags |= COMMAND_BUILTIN_FLAGS;
+#if 0
+  /* This breaks for things like ( cd /tmp ; command z ababa ; echo next )
+     or $(command echo a ; command echo b;) or even
+     { command echo a; command echo b; } & */
+  /* If we're in a subshell, see if we can get away without forking
+     again, since we've already forked to run this builtin. */
+  if (subshell_environment)
+    {
+      command->flags |= CMD_NO_FORK;
+      command->value.Simple->flags |= CMD_NO_FORK;
+    }
+#endif
+  add_unwind_protect ((char *)dispose_command, command);
+  result = execute_command (command);
+
+  run_unwind_frame ("command_builtin");
+
+  return (result);
+}
+
+/* Restore the value of the $PATH variable after replacing it when
+   executing `command -p'. */
+static void
+restore_path (var)
+     char *var;
+{
+  if (var)
+    {
+      bind_variable ("PATH", var, 0);
+      free (var);
+    }
+  else
+    unbind_variable ("PATH");
+}
+
+/* Return a value for PATH that is guaranteed to find all of the standard
+   utilities.  This uses Posix.2 configuration variables, if present.  It
+   uses a value defined in config.h as a last resort. */
+static char *
+get_standard_path ()
+{
+#if defined (_CS_PATH) && defined (HAVE_CONFSTR)
+  char *p;
+  size_t len;
+
+  len = (size_t)confstr (_CS_PATH, (char *)NULL, (size_t)0);
+  if (len > 0)
+    {
+      p = (char *)xmalloc (len + 2);
+      *p = '\0';
+      confstr (_CS_PATH, p, len);
+      return (p);
+    }
+  else
+    return (savestring (STANDARD_UTILS_PATH));
+#else /* !_CS_PATH || !HAVE_CONFSTR  */
+#  if defined (CS_PATH)
+  return (savestring (CS_PATH));
+#  else
+  return (savestring (STANDARD_UTILS_PATH));
+#  endif /* !CS_PATH */
+#endif /* !_CS_PATH || !HAVE_CONFSTR */
+}
diff -Nru bash-4.0-orig/builtins/complete.c bash-4.0/builtins/complete.c
--- bash-4.0-orig/builtins/complete.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/complete.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,752 @@
+/* complete.c, created from complete.def. */
+#line 22 "./complete.def"
+
+#line 44 "./complete.def"
+
+#include <config.h>
+
+#include <stdio.h>
+
+#include "../bashtypes.h"
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../builtins.h"
+#include "../pcomplete.h"
+#include "../bashline.h"
+
+#include "common.h"
+#include "bashgetopt.h"
+
+#include <readline/readline.h>
+
+#define STRDUP(x)       ((x) ? savestring (x) : (char *)NULL)
+
+/* Structure containing all the non-action (binary) options; filled in by
+   build_actions(). */
+struct _optflags {
+  int pflag;
+  int rflag;
+  int Eflag;
+};
+
+static int find_compact __P((char *));
+static int find_compopt __P((char *));
+
+static int build_actions __P((WORD_LIST *, struct _optflags *, unsigned long *, unsigned long *));
+
+static int remove_cmd_completions __P((WORD_LIST *));
+
+static int print_one_completion __P((char *, COMPSPEC *));
+static int print_compitem __P((BUCKET_CONTENTS *));
+static void print_compopts __P((const char *, COMPSPEC *, int));
+static void print_all_completions __P((void));
+static int print_cmd_completions __P((WORD_LIST *));
+
+static char *Garg, *Warg, *Parg, *Sarg, *Xarg, *Farg, *Carg;
+
+static const struct _compacts {
+  const char * const actname;
+  int actflag;
+  int actopt;
+} compacts[] = {
+  { "alias",     CA_ALIAS,     'a' },
+  { "arrayvar",  CA_ARRAYVAR,   0 },
+  { "binding",   CA_BINDING,    0 },
+  { "builtin",   CA_BUILTIN,   'b' },
+  { "command",   CA_COMMAND,   'c' },
+  { "directory", CA_DIRECTORY, 'd' },
+  { "disabled",  CA_DISABLED,   0 },
+  { "enabled",   CA_ENABLED,    0 },
+  { "export",    CA_EXPORT,    'e' },
+  { "file",      CA_FILE,      'f' },
+  { "function",  CA_FUNCTION,   0 },
+  { "helptopic", CA_BUILTIN,  0 },	/* for now */
+  { "hostname",  CA_HOSTNAME,   0 },
+  { "group",     CA_GROUP,     'g' },
+  { "job",       CA_JOB,       'j' },
+  { "keyword",   CA_KEYWORD,   'k' },
+  { "running",   CA_RUNNING,    0 },
+  { "service",   CA_SERVICE,   's' },
+  { "setopt",    CA_SETOPT,     0 },
+  { "shopt",     CA_SHOPT,      0 },
+  { "signal",    CA_SIGNAL,     0 },
+  { "stopped",   CA_STOPPED,    0 },
+  { "user",      CA_USER,      'u' },
+  { "variable",  CA_VARIABLE,  'v' },
+  { (char *)NULL, 0, 0 },
+};
+
+/* This should be a STRING_INT_ALIST */
+const static struct _compopt {
+  const char * const optname;
+  int optflag;
+} compopts[] = {
+  { "bashdefault", COPT_BASHDEFAULT },
+  { "default",	COPT_DEFAULT },
+  { "dirnames", COPT_DIRNAMES },
+  { "filenames",COPT_FILENAMES},
+  { "nospace",	COPT_NOSPACE },
+  { "plusdirs", COPT_PLUSDIRS },
+  { (char *)NULL, 0 },
+};
+
+static int
+find_compact (name)
+     char *name;
+{
+  register int i;
+
+  for (i = 0; compacts[i].actname; i++)
+    if (STREQ (name, compacts[i].actname))
+      return i;
+  return -1;
+}
+
+static int
+find_compopt (name)
+     char *name;
+{
+  register int i;
+
+  for (i = 0; compopts[i].optname; i++)
+    if (STREQ (name, compopts[i].optname))
+      return i;
+  return -1;
+}
+
+/* Build the actions and compspec options from the options specified in LIST.
+   ACTP is a pointer to an unsigned long in which to place the bitmap of
+   actions.  OPTP is a pointer to an unsigned long in which to place the
+   btmap of compspec options (arguments to `-o').  PP, if non-null, gets 1
+   if -p is supplied; RP, if non-null, gets 1 if -r is supplied.
+   If either is null, the corresponding option generates an error.
+   This also sets variables corresponding to options that take arguments as
+   a side effect; the caller should ensure that those variables are set to
+   NULL before calling build_actions.  Return value:
+   	EX_USAGE = bad option
+   	EXECUTION_SUCCESS = some options supplied
+   	EXECUTION_FAILURE = no options supplied
+*/
+
+static int
+build_actions (list, flagp, actp, optp)
+     WORD_LIST *list;
+     struct _optflags *flagp;
+     unsigned long *actp, *optp;
+{
+  int opt, ind, opt_given;
+  unsigned long acts, copts;
+
+  acts = copts = (unsigned long)0L;
+  opt_given = 0;
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "abcdefgjko:prsuvA:G:W:P:S:X:F:C:E")) != -1)
+    {
+      opt_given = 1;
+      switch (opt)
+	{
+	case 'r':
+	  if (flagp)
+	    {
+	      flagp->rflag = 1;
+	      break;
+	    }
+	  else
+	    {
+	      sh_invalidopt ("-r");
+	      builtin_usage ();
+	      return (EX_USAGE);
+	    }
+
+	case 'p':
+	  if (flagp)
+	    {
+	      flagp->pflag = 1;
+	      break;
+	    }
+	  else
+	    {
+	      sh_invalidopt ("-p");
+	      builtin_usage ();
+	      return (EX_USAGE);
+	    }
+
+	case 'a':
+	  acts |= CA_ALIAS;
+	  break;
+	case 'b':
+	  acts |= CA_BUILTIN;
+	  break;
+	case 'c':
+	  acts |= CA_COMMAND;
+	  break;
+	case 'd':
+	  acts |= CA_DIRECTORY;
+	  break;
+	case 'e':
+	  acts |= CA_EXPORT;
+	  break;
+	case 'f':
+	  acts |= CA_FILE;
+	  break;
+	case 'g':
+	  acts |= CA_GROUP;
+	  break;
+	case 'j':
+	  acts |= CA_JOB;
+	  break;
+	case 'k':
+	  acts |= CA_KEYWORD;
+	  break;
+	case 's':
+	  acts |= CA_SERVICE;
+	  break;
+	case 'u':
+	  acts |= CA_USER;
+	  break;
+	case 'v':
+	  acts |= CA_VARIABLE;
+	  break;
+	case 'o':
+	  ind = find_compopt (list_optarg);
+	  if (ind < 0)
+	    {
+	      sh_invalidoptname (list_optarg);
+	      return (EX_USAGE);
+	    }
+	  copts |= compopts[ind].optflag;
+	  break;
+	case 'A':
+	  ind = find_compact (list_optarg);
+	  if (ind < 0)
+	    {
+	      builtin_error (_("%s: invalid action name"), list_optarg);
+	      return (EX_USAGE);
+	    }
+	  acts |= compacts[ind].actflag;
+	  break;
+	case 'C':
+	  Carg = list_optarg;
+	  break;
+	case 'E':
+	  if (flagp)
+	    {
+	      flagp->Eflag = 1;
+	      break;
+	    }
+	  else
+	    {
+	      sh_invalidopt ("-E");
+	      builtin_usage ();
+	      return (EX_USAGE);
+	    }
+	case 'F':
+	  Farg = list_optarg;
+	  break;
+	case 'G':
+	  Garg = list_optarg;
+	  break;
+	case 'P':
+	  Parg = list_optarg;
+	  break;
+	case 'S':
+	  Sarg = list_optarg;
+	  break;
+	case 'W':
+	  Warg = list_optarg;
+	  break;
+	case 'X':
+	  Xarg = list_optarg;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  *actp = acts;
+  *optp = copts;
+
+  return (opt_given ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+}
+
+/* Add, remove, and display completion specifiers. */
+int
+complete_builtin (list)
+     WORD_LIST *list;
+{
+  int opt_given, rval;
+  unsigned long acts, copts;
+  COMPSPEC *cs;
+  struct _optflags oflags;
+  WORD_LIST *l, *wl;
+
+  if (list == 0)
+    {
+      print_all_completions ();
+      return (EXECUTION_SUCCESS);
+    }
+
+  opt_given = oflags.pflag = oflags.rflag = oflags.Eflag = 0;
+
+  acts = copts = (unsigned long)0L;
+  Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;
+  cs = (COMPSPEC *)NULL;
+
+  /* Build the actions from the arguments.  Also sets the [A-Z]arg variables
+     as a side effect if they are supplied as options. */
+  rval = build_actions (list, &oflags, &acts, &copts);
+  if (rval == EX_USAGE)
+    return (rval);
+  opt_given = rval != EXECUTION_FAILURE;
+
+  list = loptend;
+
+  wl = oflags.Eflag ? make_word_list (make_bare_word ("_EmptycmD_"), (WORD_LIST *)NULL) : 0;
+
+  /* -p overrides everything else */
+  if (oflags.pflag || (list == 0 && opt_given == 0))
+    {
+      if (wl)
+	{
+	  rval = print_cmd_completions (wl);
+	  dispose_words (wl);
+	  return rval;
+	}
+      else if (list == 0)
+	{
+	  print_all_completions ();
+	  return (EXECUTION_SUCCESS);
+	}
+      return (print_cmd_completions (list));
+    }
+
+  /* next, -r overrides everything else. */
+  if (oflags.rflag)
+    {
+      if (wl)
+	{
+	  rval = remove_cmd_completions (wl);
+	  dispose_words (wl);
+	  return rval;
+	}
+      else if (list == 0)
+	{
+	  progcomp_flush ();
+	  return (EXECUTION_SUCCESS);
+	}
+      return (remove_cmd_completions (list));
+    }
+
+  if (wl == 0 && list == 0 && opt_given)
+    {
+      builtin_usage ();
+      return (EX_USAGE);
+    }
+
+  /* If we get here, we need to build a compspec and add it for each
+     remaining argument. */
+  cs = compspec_create ();
+  cs->actions = acts;
+  cs->options = copts;
+
+  cs->globpat = STRDUP (Garg);
+  cs->words = STRDUP (Warg);
+  cs->prefix = STRDUP (Parg);
+  cs->suffix = STRDUP (Sarg);
+  cs->funcname = STRDUP (Farg);
+  cs->command = STRDUP (Carg);
+  cs->filterpat = STRDUP (Xarg);
+
+  for (rval = EXECUTION_SUCCESS, l = wl ? wl : list ; l; l = l->next)
+    {
+      /* Add CS as the compspec for the specified commands. */
+      if (progcomp_insert (l->word->word, cs) == 0)
+	rval = EXECUTION_FAILURE;
+    }
+
+  dispose_words (wl);
+  return (rval);
+}
+
+static int
+remove_cmd_completions (list)
+     WORD_LIST *list;
+{
+  WORD_LIST *l;
+  int ret;
+
+  for (ret = EXECUTION_SUCCESS, l = list; l; l = l->next)
+    {
+      if (progcomp_remove (l->word->word) == 0)
+	{
+	  builtin_error (_("%s: no completion specification"), l->word->word);
+	  ret = EXECUTION_FAILURE;
+	}
+    }
+  return ret;
+}
+
+#define SQPRINTARG(a, f) \
+  do { \
+    if (a) \
+      { \
+      	x = sh_single_quote (a); \
+	printf ("%s %s ", f, x); \
+	free (x); \
+      } \
+  } while (0)
+
+#define PRINTARG(a, f) \
+  do { \
+    if (a) \
+      printf ("%s %s ", f, a); \
+  } while (0)
+
+#define PRINTOPT(a, f) \
+  do { \
+    if (acts & a) \
+      printf ("%s ", f); \
+  } while (0)
+
+#define PRINTACT(a, f) \
+  do { \
+    if (acts & a) \
+      printf ("-A %s ", f); \
+  } while (0)
+
+#define PRINTCOMPOPT(a, f) \
+  do { \
+    if (copts & a) \
+      printf ("-o %s ", f); \
+  } while (0)
+
+#define XPRINTCOMPOPT(a, f) \
+  do { \
+    if (copts & a) \
+      printf ("-o %s ", f); \
+    else \
+      printf ("+o %s ", f); \
+  } while (0)
+
+static int
+print_one_completion (cmd, cs)
+     char *cmd;
+     COMPSPEC *cs;
+{
+  unsigned long acts, copts;
+  char *x;
+
+  printf ("complete ");
+
+  copts = cs->options;
+
+  /* First, print the -o options. */
+  PRINTCOMPOPT (COPT_BASHDEFAULT, "bashdefault");
+  PRINTCOMPOPT (COPT_DEFAULT, "default");
+  PRINTCOMPOPT (COPT_DIRNAMES, "dirnames");
+  PRINTCOMPOPT (COPT_FILENAMES, "filenames");
+  PRINTCOMPOPT (COPT_NOSPACE, "nospace");
+  PRINTCOMPOPT (COPT_PLUSDIRS, "plusdirs");
+
+  acts = cs->actions;
+
+  /* simple flags next */
+  PRINTOPT (CA_ALIAS, "-a");
+  PRINTOPT (CA_BUILTIN, "-b");
+  PRINTOPT (CA_COMMAND, "-c");
+  PRINTOPT (CA_DIRECTORY, "-d");
+  PRINTOPT (CA_EXPORT, "-e");
+  PRINTOPT (CA_FILE, "-f");
+  PRINTOPT (CA_GROUP, "-g");
+  PRINTOPT (CA_JOB, "-j");
+  PRINTOPT (CA_KEYWORD, "-k");
+  PRINTOPT (CA_SERVICE, "-s");
+  PRINTOPT (CA_USER, "-u");
+  PRINTOPT (CA_VARIABLE, "-v");
+
+  /* now the rest of the actions */
+  PRINTACT (CA_ARRAYVAR, "arrayvar");
+  PRINTACT (CA_BINDING, "binding");
+  PRINTACT (CA_DISABLED, "disabled");
+  PRINTACT (CA_ENABLED, "enabled");
+  PRINTACT (CA_FUNCTION, "function");
+  PRINTACT (CA_HELPTOPIC, "helptopic");
+  PRINTACT (CA_HOSTNAME, "hostname");
+  PRINTACT (CA_RUNNING, "running");
+  PRINTACT (CA_SETOPT, "setopt");
+  PRINTACT (CA_SHOPT, "shopt");
+  PRINTACT (CA_SIGNAL, "signal");
+  PRINTACT (CA_STOPPED, "stopped");
+
+  /* now the rest of the arguments */
+
+  /* arguments that require quoting */
+  SQPRINTARG (cs->globpat, "-G");
+  SQPRINTARG (cs->words, "-W");
+  SQPRINTARG (cs->prefix, "-P");
+  SQPRINTARG (cs->suffix, "-S");
+  SQPRINTARG (cs->filterpat, "-X");
+
+  SQPRINTARG (cs->command, "-C");
+
+  /* simple arguments that don't require quoting */
+  PRINTARG (cs->funcname, "-F");
+
+  printf ("%s\n", cmd);
+
+  return (0);
+}
+
+static void
+print_compopts (cmd, cs, full)
+     const char *cmd;
+     COMPSPEC *cs;
+     int full;
+{
+  int copts;
+
+  printf ("compopt ");
+  copts = cs->options;
+
+  if (full)
+    {
+      XPRINTCOMPOPT (COPT_BASHDEFAULT, "bashdefault");
+      XPRINTCOMPOPT (COPT_DEFAULT, "default");
+      XPRINTCOMPOPT (COPT_DIRNAMES, "dirnames");
+      XPRINTCOMPOPT (COPT_FILENAMES, "filenames");
+      XPRINTCOMPOPT (COPT_NOSPACE, "nospace");
+      XPRINTCOMPOPT (COPT_PLUSDIRS, "plusdirs");
+    }
+  else
+    {
+      PRINTCOMPOPT (COPT_BASHDEFAULT, "bashdefault");
+      PRINTCOMPOPT (COPT_DEFAULT, "default");
+      PRINTCOMPOPT (COPT_DIRNAMES, "dirnames");
+      PRINTCOMPOPT (COPT_FILENAMES, "filenames");
+      PRINTCOMPOPT (COPT_NOSPACE, "nospace");
+      PRINTCOMPOPT (COPT_PLUSDIRS, "plusdirs");
+    }
+
+  printf ("%s\n", cmd);
+}
+
+static int
+print_compitem (item)
+     BUCKET_CONTENTS *item;
+{
+  COMPSPEC *cs;
+  char *cmd;
+
+  cmd = item->key;
+  cs = (COMPSPEC *)item->data;
+
+  return (print_one_completion (cmd, cs));
+}
+
+static void
+print_all_completions ()
+{
+  progcomp_walk (print_compitem);
+}
+
+static int
+print_cmd_completions (list)
+     WORD_LIST *list;
+{
+  WORD_LIST *l;
+  COMPSPEC *cs;
+  int ret;
+
+  for (ret = EXECUTION_SUCCESS, l = list; l; l = l->next)
+    {
+      cs = progcomp_search (l->word->word);
+      if (cs)
+	print_one_completion (l->word->word, cs);
+      else
+	{
+	  builtin_error (_("%s: no completion specification"), l->word->word);
+	  ret = EXECUTION_FAILURE;
+	}
+    }
+
+  return (sh_chkwrite (ret));
+}
+
+#line 636 "./complete.def"
+
+int
+compgen_builtin (list)
+     WORD_LIST *list;
+{
+  int rval;
+  unsigned long acts, copts;
+  COMPSPEC *cs;
+  STRINGLIST *sl;
+  char *word, **matches;
+
+  if (list == 0)
+    return (EXECUTION_SUCCESS);
+
+  acts = copts = (unsigned long)0L;
+  Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;
+  cs = (COMPSPEC *)NULL;
+
+  /* Build the actions from the arguments.  Also sets the [A-Z]arg variables
+     as a side effect if they are supplied as options. */
+  rval = build_actions (list, (struct _optflags *)NULL, &acts, &copts);
+  if (rval == EX_USAGE)
+    return (rval);
+  if (rval == EXECUTION_FAILURE)
+    return (EXECUTION_SUCCESS);
+
+  list = loptend;
+
+  word = (list && list->word) ? list->word->word : "";
+
+  if (Farg)
+    builtin_error (_("warning: -F option may not work as you expect"));
+  if (Carg)
+    builtin_error (_("warning: -C option may not work as you expect"));
+
+  /* If we get here, we need to build a compspec and evaluate it. */
+  cs = compspec_create ();
+  cs->actions = acts;
+  cs->options = copts;
+  cs->refcount = 1;
+
+  cs->globpat = STRDUP (Garg);
+  cs->words = STRDUP (Warg);
+  cs->prefix = STRDUP (Parg);
+  cs->suffix = STRDUP (Sarg);
+  cs->funcname = STRDUP (Farg);
+  cs->command = STRDUP (Carg);
+  cs->filterpat = STRDUP (Xarg);
+
+  rval = EXECUTION_FAILURE;
+  sl = gen_compspec_completions (cs, "compgen", word, 0, 0);
+
+  /* If the compspec wants the bash default completions, temporarily
+     turn off programmable completion and call the bash completion code. */
+  if ((sl == 0 || sl->list_len == 0) && (copts & COPT_BASHDEFAULT))
+    {
+      matches = bash_default_completion (word, 0, 0, 0, 0);
+      sl = completions_to_stringlist (matches);
+      strvec_dispose (matches);
+    }
+
+  /* This isn't perfect, but it's the best we can do, given what readline
+     exports from its set of completion utility functions. */
+  if ((sl == 0 || sl->list_len == 0) && (copts & COPT_DEFAULT))
+    {
+      matches = rl_completion_matches (word, rl_filename_completion_function);
+      sl = completions_to_stringlist (matches);
+      strvec_dispose (matches);
+    }
+
+  if (sl)
+    {
+      if (sl->list && sl->list_len)
+	{
+	  rval = EXECUTION_SUCCESS;
+	  strlist_print (sl, (char *)NULL);
+	}
+      strlist_dispose (sl);
+    }
+
+  compspec_dispose (cs);
+  return (rval);
+}
+
+#line 747 "./complete.def"
+
+int
+compopt_builtin (list)
+     WORD_LIST *list;
+{
+  int opts_on, opts_off, *opts, opt, oind, ret, Eflag;
+  WORD_LIST *l;
+  COMPSPEC *cs;
+
+  opts_on = opts_off = 0;
+  ret = EXECUTION_SUCCESS;
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "+o:")) != EOF)
+    {
+      opts = (list_opttype == '-') ? &opts_on : &opts_off;
+
+      switch (opt)
+	{
+	case 'o':
+	  oind = find_compopt (list_optarg);
+	  if (oind < 0)
+	    {
+	      sh_invalidoptname (list_optarg);
+	      return (EX_USAGE);
+	    }
+	  *opts |= compopts[oind].optflag;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  if (list == 0)
+    {
+      if (RL_ISSTATE (RL_STATE_COMPLETING) == 0 || pcomp_curcs == 0)
+	{
+	  builtin_error (_("not currently executing completion function"));
+	  return (EXECUTION_FAILURE);
+	}
+      cs = pcomp_curcs;
+
+      if (opts_on == 0 && opts_off == 0)
+	{
+	  print_compopts (pcomp_curcmd, cs, 1);
+          return (sh_chkwrite (ret));
+	}
+
+      /* Set the compspec options */
+      pcomp_set_compspec_options (cs, opts_on, 1);
+      pcomp_set_compspec_options (cs, opts_off, 0);
+
+      /* And change the readline variables the options control */
+      pcomp_set_readline_variables (opts_on, 1);
+      pcomp_set_readline_variables (opts_off, 0);
+
+      return (ret);
+    }
+
+  for (l = list; l; l = l->next)
+    {
+      cs = progcomp_search (l->word->word);
+      if (cs == 0)
+	{
+	  builtin_error (_("%s: no completion specification"), l->word->word);
+	  ret = EXECUTION_FAILURE;
+	  continue;
+	}
+      if (opts_on == 0 && opts_off == 0)
+	{
+	  print_compopts (l->word->word, cs, 1);
+	  continue;			/* XXX -- fill in later */
+	}
+
+      /* Set the compspec options */
+      pcomp_set_compspec_options (cs, opts_on, 1);
+      pcomp_set_compspec_options (cs, opts_off, 0);
+    }
+
+  return (ret);
+}
diff -Nru bash-4.0-orig/builtins/declare.c bash-4.0/builtins/declare.c
--- bash-4.0-orig/builtins/declare.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/declare.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,477 @@
+/* declare.c, created from declare.def. */
+#line 22 "./declare.def"
+
+#line 58 "./declare.def"
+
+#line 66 "./declare.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+#include "builtext.h"
+#include "bashgetopt.h"
+
+extern int array_needs_making;
+extern int posixly_correct;
+
+static int declare_internal __P((register WORD_LIST *, int));
+
+/* Declare or change variable attributes. */
+int
+declare_builtin (list)
+     register WORD_LIST *list;
+{
+  return (declare_internal (list, 0));
+}
+
+#line 114 "./declare.def"
+int
+local_builtin (list)
+     register WORD_LIST *list;
+{
+  if (variable_context)
+    return (declare_internal (list, 1));
+  else
+    {
+      builtin_error (_("can only be used in a function"));
+      return (EXECUTION_FAILURE);
+    }
+}
+
+#if defined (ARRAY_VARS)
+#  define DECLARE_OPTS	"+acfilprtuxAF"
+#else
+#  define DECLARE_OPTS	"+cfilprtuxF"
+#endif
+
+/* The workhorse function. */
+static int
+declare_internal (list, local_var)
+     register WORD_LIST *list;
+     int local_var;
+{
+  int flags_on, flags_off, *flags;
+  int any_failed, assign_error, pflag, nodefs, opt;
+  char *t, *subscript_start;
+  SHELL_VAR *var;
+  FUNCTION_DEF *shell_fn;
+
+  flags_on = flags_off = any_failed = assign_error = pflag = nodefs = 0;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, DECLARE_OPTS)) != EOF)
+    {
+      flags = list_opttype == '+' ? &flags_off : &flags_on;
+
+      switch (opt)
+	{
+	case 'a':
+#if defined (ARRAY_VARS)
+	  *flags |= att_array;
+	  break;
+#else
+	  builtin_usage ();
+	  return (EX_USAGE);
+#endif
+	case 'A':
+#if defined (ARRAY_VARS)
+	  *flags |= att_assoc;
+	  break;
+#else
+	  builtin_usage ();
+	  return (EX_USAGE);
+#endif
+	case 'p':
+	  if (local_var == 0)
+	    pflag++;
+	  break;
+        case 'F':
+	  nodefs++;
+	  *flags |= att_function;
+	  break;
+	case 'f':
+	  *flags |= att_function;
+	  break;
+	case 'i':
+	  *flags |= att_integer;
+	  break;
+	case 'r':
+	  *flags |= att_readonly;
+	  break;
+	case 't':
+	  *flags |= att_trace;
+	  break;
+	case 'x':
+	  *flags |= att_exported;
+	  array_needs_making = 1;
+	  break;
+#if defined (CASEMOD_ATTRS)
+#  if defined (CASEMOD_CAPCASE)
+	 case 'c':
+	  *flags |= att_capcase;
+	  if (flags == &flags_on)
+	    flags_off |= att_uppercase|att_lowercase;
+	  break;
+#  endif
+	case 'l':
+	  *flags |= att_lowercase;
+	  if (flags == &flags_on)
+	    flags_off |= att_capcase|att_uppercase;
+	  break;
+	case 'u':
+	  *flags |= att_uppercase;
+	  if (flags == &flags_on)
+	    flags_off |= att_capcase|att_lowercase;
+	  break;
+#endif /* CASEMOD_ATTRS */
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+  /* If there are no more arguments left, then we just want to show
+     some variables. */
+  if (list == 0)	/* declare -[aAfFirtx] */
+    {
+      /* Show local variables defined at this context level if this is
+	 the `local' builtin. */
+      if (local_var)
+	{
+	  register SHELL_VAR **vlist;
+	  register int i;
+
+	  vlist = all_local_variables ();
+
+	  if (vlist)
+	    {
+	      for (i = 0; vlist[i]; i++)
+		print_assignment (vlist[i]);
+
+	      free (vlist);
+	    }
+	}
+      else if (pflag && (flags_on == 0 || flags_on == att_function))
+	show_all_var_attributes (flags_on == 0, nodefs);
+      else if (flags_on == 0)
+	return (set_builtin ((WORD_LIST *)NULL));
+      else
+	set_or_show_attributes ((WORD_LIST *)NULL, flags_on, nodefs);
+
+      return (sh_chkwrite (EXECUTION_SUCCESS));
+    }
+
+  if (pflag)	/* declare -p [-aAfFirtx] name [name...] */
+    {
+      for (any_failed = 0; list; list = list->next)
+	{
+	  pflag = show_name_attributes (list->word->word, nodefs);
+	  if (pflag)
+	    {
+	      sh_notfound (list->word->word);
+	      any_failed++;
+	    }
+	}
+      return (sh_chkwrite (any_failed ? EXECUTION_FAILURE : EXECUTION_SUCCESS));
+    }
+
+#define NEXT_VARIABLE() free (name); list = list->next; continue
+
+  /* There are arguments left, so we are making variables. */
+  while (list)		/* declare [-aAfFirx] name [name ...] */
+    {
+      char *value, *name;
+      int offset, aflags;
+#if defined (ARRAY_VARS)
+      int making_array_special, compound_array_assign, simple_array_assign;
+#endif
+
+      name = savestring (list->word->word);
+      offset = assignment (name, 0);
+      aflags = 0;
+
+      if (offset)	/* declare [-aAfFirx] name=value */
+	{
+	  name[offset] = '\0';
+	  value = name + offset + 1;
+	  if (name[offset - 1] == '+')
+	    {
+	      aflags |= ASS_APPEND;
+	      name[offset - 1] = '\0';
+	    }
+	}
+      else
+	value = "";
+
+#if defined (ARRAY_VARS)
+      compound_array_assign = simple_array_assign = 0;
+      subscript_start = (char *)NULL;
+      if (t = strchr (name, '['))	/* ] */
+	{
+	  subscript_start = t;
+	  *t = '\0';
+	  making_array_special = 1;
+	}
+      else
+	making_array_special = 0;
+#endif
+
+      /* If we're in posix mode or not looking for a shell function (since
+	 shell function names don't have to be valid identifiers when the
+	 shell's not in posix mode), check whether or not the argument is a
+	 valid, well-formed shell identifier. */
+      if ((posixly_correct || (flags_on & att_function) == 0) && legal_identifier (name) == 0)
+	{
+	  sh_invalidid (name);
+	  assign_error++;
+	  NEXT_VARIABLE ();
+	}
+
+      /* If VARIABLE_CONTEXT has a non-zero value, then we are executing
+	 inside of a function.  This means we should make local variables,
+	 not global ones. */
+
+      /* XXX - this has consequences when we're making a local copy of a
+	       variable that was in the temporary environment.  Watch out
+	       for this. */
+      if (variable_context && ((flags_on & att_function) == 0))
+	{
+#if defined (ARRAY_VARS)
+	  if (flags_on & att_assoc)
+	    var = make_local_assoc_variable (name);
+	  else if ((flags_on & att_array) || making_array_special)
+	    var = make_local_array_variable (name);
+	  else
+#endif
+	  var = make_local_variable (name);
+	  if (var == 0)
+	    {
+	      any_failed++;
+	      NEXT_VARIABLE ();
+	    }
+	}
+      else
+	var = (SHELL_VAR *)NULL;
+
+      /* If we are declaring a function, then complain about it in some way.
+	 We don't let people make functions by saying `typeset -f foo=bar'. */
+
+      /* There should be a way, however, to let people look at a particular
+	 function definition by saying `typeset -f foo'. */
+
+      if (flags_on & att_function)
+	{
+	  if (offset)	/* declare -f [-rix] foo=bar */
+	    {
+	      builtin_error (_("cannot use `-f' to make functions"));
+	      free (name);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else		/* declare -f [-rx] name [name...] */
+	    {
+	      var = find_function (name);
+
+	      if (var)
+		{
+		  if (readonly_p (var) && (flags_off & att_readonly))
+		    {
+		      builtin_error (_("%s: readonly function"), name);
+		      any_failed++;
+		      NEXT_VARIABLE ();
+		    }
+
+		  /* declare -[Ff] name [name...] */
+		  if (flags_on == att_function && flags_off == 0)
+		    {
+#if defined (DEBUGGER)
+		      if (nodefs && debugging_mode)
+			{
+			  shell_fn = find_function_def (var->name);
+			  if (shell_fn)
+			    printf ("%s %d %s\n", var->name, shell_fn->line, shell_fn->source_file);
+			  else
+			    printf ("%s\n", var->name);
+			}
+		      else
+#endif /* DEBUGGER */
+			{	
+			  t = nodefs ? var->name
+				     : named_function_string (name, function_cell (var), FUNC_MULTILINE|FUNC_EXTERNAL);
+			  printf ("%s\n", t);
+			  any_failed = sh_chkwrite (any_failed);
+			}
+		    }
+		  else		/* declare -[fF] -[rx] name [name...] */
+		    {
+		      VSETATTR (var, flags_on);
+		      VUNSETATTR (var, flags_off);
+		    }
+		}
+	      else
+		any_failed++;
+	      NEXT_VARIABLE ();
+	    }
+	}
+      else		/* declare -[aAirx] name [name...] */
+	{
+	  /* Non-null if we just created or fetched a local variable. */
+	  if (var == 0)
+	    var = find_variable (name);
+
+	  if (var == 0)
+	    {
+#if defined (ARRAY_VARS)
+	      if (flags_on & att_assoc)
+		var = make_new_assoc_variable (name);
+	      else if ((flags_on & att_array) || making_array_special)
+		var = make_new_array_variable (name);
+	      else
+#endif
+
+	      if (offset)
+		var = bind_variable (name, "", 0);
+	      else
+		{
+		  var = bind_variable (name, (char *)NULL, 0);
+		  VSETATTR (var, att_invisible);
+		}
+	    }
+
+	  /* Cannot use declare +r to turn off readonly attribute. */ 
+	  if (readonly_p (var) && (flags_off & att_readonly))
+	    {
+	      sh_readonly (name);
+	      any_failed++;
+	      NEXT_VARIABLE ();
+	    }
+
+	  /* Cannot use declare to assign value to readonly or noassign
+	     variable. */
+	  if ((readonly_p (var) || noassign_p (var)) && offset)
+	    {
+	      if (readonly_p (var))
+		sh_readonly (name);
+	      assign_error++;
+	      NEXT_VARIABLE ();
+	    }
+
+#if defined (ARRAY_VARS)
+	  if ((making_array_special || (flags_on & (att_array|att_assoc)) || array_p (var) || assoc_p (var)) && offset)
+	    {
+	      int vlen;
+	      vlen = STRLEN (value);
+
+	      if (value[0] == '(' && value[vlen-1] == ')')
+		compound_array_assign = 1;
+	      else
+		simple_array_assign = 1;
+	    }
+
+	  /* Cannot use declare +a name or declare +A name to remove an
+	     array variable. */
+	  if (((flags_off & att_array) && array_p (var)) || ((flags_off & att_assoc) && assoc_p (var)))
+	    {
+	      builtin_error (_("%s: cannot destroy array variables in this way"), name);
+	      any_failed++;
+	      NEXT_VARIABLE ();
+	    }
+
+	  if ((flags_on & att_array) && assoc_p (var))
+	    {
+	      builtin_error (_("%s: cannot convert associative to indexed array"), name);
+	      any_failed++;
+	      NEXT_VARIABLE ();
+	    }
+	  if ((flags_on & att_assoc) && array_p (var))
+	    {
+	      builtin_error (_("%s: cannot convert indexed to associative array"), name);
+	      any_failed++;
+	      NEXT_VARIABLE ();
+	    }
+
+	  /* declare -A name[[n]] makes name an associative array variable. */
+	  if (flags_on & att_assoc)
+	    {
+	      if (assoc_p (var) == 0)
+		var = convert_var_to_assoc (var);
+	    }
+	  /* declare -a name[[n]] or declare name[n] makes name an indexed
+	     array variable. */
+	  else if ((making_array_special || (flags_on & att_array)) && array_p (var) == 0)
+	    var = convert_var_to_array (var);
+#endif /* ARRAY_VARS */
+
+	  VSETATTR (var, flags_on);
+	  VUNSETATTR (var, flags_off);
+
+#if defined (ARRAY_VARS)
+	  if (offset && compound_array_assign)
+	    assign_array_var_from_string (var, value, aflags);
+	  else if (simple_array_assign && subscript_start)
+	    {
+	      /* declare [-a] name[N]=value */
+	      *subscript_start = '[';	/* ] */
+	      var = assign_array_element (name, value, 0);	/* XXX - not aflags */
+	      *subscript_start = '\0';
+	    }
+	  else if (simple_array_assign)
+	    /* let bind_array_variable take care of this. */
+	    bind_array_variable (name, 0, value, aflags);
+	  else
+#endif
+	  /* bind_variable_value duplicates the essential internals of
+	     bind_variable() */
+	  if (offset)
+	    bind_variable_value (var, value, aflags);
+
+	  /* If we found this variable in the temporary environment, as with
+	     `var=value declare -x var', make sure it is treated identically
+	     to `var=value export var'.  Do the same for `declare -r' and
+	     `readonly'.  Preserve the attributes, except for att_tempvar. */
+	  /* XXX -- should this create a variable in the global scope, or
+	     modify the local variable flags?  ksh93 has it modify the
+	     global scope.
+	     Need to handle case like in set_var_attribute where a temporary
+	     variable is in the same table as the function local vars. */
+	  if ((flags_on & (att_exported|att_readonly)) && tempvar_p (var))
+	    {
+	      SHELL_VAR *tv;
+	      char *tvalue;
+
+	      tv = find_tempenv_variable (var->name);
+	      if (tv)
+		{
+		  tvalue = var_isset (var) ? savestring (value_cell (var)) : savestring ("");
+	          tv = bind_variable (var->name, tvalue, 0);
+	          tv->attributes |= var->attributes & ~att_tempvar;
+	          if (tv->context > 0)
+		    VSETATTR (tv, att_propagate);
+	          free (tvalue);
+		}
+	      VSETATTR (var, att_propagate);
+	    }
+	}
+
+      stupidly_hack_special_variables (name);
+
+      NEXT_VARIABLE ();
+    }
+
+  return (assign_error ? EX_BADASSIGN
+		       : ((any_failed == 0) ? EXECUTION_SUCCESS
+  					    : EXECUTION_FAILURE));
+}
diff -Nru bash-4.0-orig/builtins/declare.def bash-4.0/builtins/declare.def
--- bash-4.0-orig/builtins/declare.def	2009-01-04 20:32:22.000000000 +0100
+++ bash-4.0/builtins/declare.def	2009-12-08 18:04:02.000000000 +0100
@@ -295,6 +295,13 @@
       subscript_start = (char *)NULL;
       if (t = strchr (name, '['))	/* ] */
 	{
+	  /* If offset != 0 we have already validated any array reference */
+	  if (offset == 0 && valid_array_reference (name) == 0)
+	    {
+	      sh_invalidid (name);
+	      assign_error++;
+	      NEXT_VARIABLE ();
+	    }
 	  subscript_start = t;
 	  *t = '\0';
 	  making_array_special = 1;
@@ -484,7 +491,7 @@
 	    }
 	  /* declare -a name[[n]] or declare name[n] makes name an indexed
 	     array variable. */
-	  else if ((making_array_special || (flags_on & att_array)) && array_p (var) == 0)
+	  else if ((making_array_special || (flags_on & att_array)) && array_p (var) == 0 && assoc_p (var) == 0)
 	    var = convert_var_to_array (var);
 #endif /* ARRAY_VARS */
 
diff -Nru bash-4.0-orig/builtins/echo.c bash-4.0/builtins/echo.c
--- bash-4.0-orig/builtins/echo.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/echo.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,135 @@
+/* echo.c, created from echo.def. */
+#line 22 "./echo.def"
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+
+#include <stdio.h>
+#include "../shell.h"
+
+#include "common.h"
+
+#line 67 "./echo.def"
+
+#line 82 "./echo.def"
+
+#if defined (V9_ECHO)
+#  define VALID_ECHO_OPTIONS "neE"
+#else /* !V9_ECHO */
+#  define VALID_ECHO_OPTIONS "n"
+#endif /* !V9_ECHO */
+
+/* System V machines already have a /bin/sh with a v9 behaviour.  We
+   give Bash the identical behaviour for these machines so that the
+   existing system shells won't barf.  Regrettably, the SUS v2 has
+   standardized the Sys V echo behavior.  This variable is external
+   so that we can have a `shopt' variable to control it at runtime. */
+#if defined (DEFAULT_ECHO_TO_XPG) || defined (STRICT_POSIX)
+int xpg_echo = 1;
+#else
+int xpg_echo = 0;
+#endif /* DEFAULT_ECHO_TO_XPG */
+
+extern int posixly_correct;
+
+/* Print the words in LIST to standard output.  If the first word is
+   `-n', then don't print a trailing newline.  We also support the
+   echo syntax from Version 9 Unix systems. */
+int
+echo_builtin (list)
+     WORD_LIST *list;
+{
+  int display_return, do_v9, i, len;
+  char *temp, *s;
+
+  do_v9 = xpg_echo;
+  display_return = 1;
+
+  if (posixly_correct && xpg_echo)
+    goto just_echo;
+
+  for (; list && (temp = list->word->word) && *temp == '-'; list = list->next)
+    {
+      /* If it appears that we are handling options, then make sure that
+	 all of the options specified are actually valid.  Otherwise, the
+	 string should just be echoed. */
+      temp++;
+
+      for (i = 0; temp[i]; i++)
+	{
+	  if (strchr (VALID_ECHO_OPTIONS, temp[i]) == 0)
+	    break;
+	}
+
+      /* echo - and echo -<nonopt> both mean to just echo the arguments. */
+      if (*temp == 0 || temp[i])
+	break;
+
+      /* All of the options in TEMP are valid options to ECHO.
+	 Handle them. */
+      while (i = *temp++)
+	{
+	  switch (i)
+	    {
+	    case 'n':
+	      display_return = 0;
+	      break;
+#if defined (V9_ECHO)
+	    case 'e':
+	      do_v9 = 1;
+	      break;
+	    case 'E':
+	      do_v9 = 0;
+	      break;
+#endif /* V9_ECHO */
+	    default:
+	      goto just_echo;	/* XXX */
+	    }
+	}
+    }
+
+just_echo:
+
+  clearerr (stdout);	/* clear error before writing and testing success */
+
+  terminate_immediately++;
+  while (list)
+    {
+      i = len = 0;
+      temp = do_v9 ? ansicstr (list->word->word, STRLEN (list->word->word), 1, &i, &len)
+		   : list->word->word;
+      if (temp)
+	{
+	  if (do_v9)
+	    {
+	      for (s = temp; len > 0; len--)
+		putchar (*s++);
+	    }
+	  else	    
+	    printf ("%s", temp);
+#if defined (SunOS5)
+	  fflush (stdout);	/* Fix for bug in SunOS 5.5 printf(3) */
+#endif
+	}
+      if (do_v9 && temp)
+	free (temp);
+      list = list->next;
+      if (i)
+	{
+	  display_return = 0;
+	  break;
+	}
+      if (list)
+	putchar(' ');
+    }
+
+  if (display_return)
+    putchar ('\n');
+
+  terminate_immediately--;
+  return (sh_chkwrite (EXECUTION_SUCCESS));
+}
diff -Nru bash-4.0-orig/builtins/enable.c bash-4.0/builtins/enable.c
--- bash-4.0-orig/builtins/enable.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/enable.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,438 @@
+/* enable.c, created from enable.def. */
+#line 22 "./enable.def"
+
+#line 50 "./enable.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../builtins.h"
+#include "../flags.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#if defined (PROGRAMMABLE_COMPLETION)
+#  include "../pcomplete.h"
+#endif
+
+#define ENABLED  1
+#define DISABLED 2
+#define SPECIAL  4
+
+#define AFLAG	0x01
+#define DFLAG	0x02
+#define FFLAG	0x04
+#define NFLAG	0x08
+#define PFLAG	0x10
+#define SFLAG	0x20
+
+#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
+static int dyn_load_builtin __P((WORD_LIST *, int, char *));
+#endif
+
+#if defined (HAVE_DLCLOSE)
+static int dyn_unload_builtin __P((char *));
+static void delete_builtin __P((struct builtin *));
+static int local_dlclose __P((void *));
+#endif
+
+static void list_some_builtins __P((int));
+static int enable_shell_command __P((char *, int));
+
+/* Enable/disable shell commands present in LIST.  If list is not specified,
+   then print out a list of shell commands showing which are enabled and
+   which are disabled. */
+int
+enable_builtin (list)
+     WORD_LIST *list;
+{
+  int result, flags;
+  int opt, filter;
+#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
+  char *filename;
+#endif
+
+  result = EXECUTION_SUCCESS;
+  flags = 0;
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "adnpsf:")) != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  flags |= AFLAG;
+	  break;
+	case 'n':
+	  flags |= NFLAG;
+	  break;
+	case 'p':
+	  flags |= PFLAG;
+	  break;
+	case 's':
+	  flags |= SFLAG;
+	  break;
+	case 'f':
+#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
+	  flags |= FFLAG;
+	  filename = list_optarg;
+	  break;
+#else
+	  builtin_error (_("dynamic loading not available"));
+	  return (EX_USAGE);
+#endif
+#if defined (HAVE_DLCLOSE)
+	case 'd':
+	  flags |= DFLAG;
+	  break;
+#else
+	  builtin_error (_("dynamic loading not available"));
+	  return (EX_USAGE);
+#endif /* HAVE_DLCLOSE */
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+#if defined (RESTRICTED_SHELL)
+  /* Restricted shells cannot load new builtins. */
+  if (restricted && (flags & (FFLAG|DFLAG)))
+    {
+      sh_restricted ((char *)NULL);
+      return (EXECUTION_FAILURE);
+    }
+#endif
+
+  if (list == 0 || (flags & PFLAG))
+    {
+      filter = (flags & AFLAG) ? (ENABLED | DISABLED)
+			       : (flags & NFLAG) ? DISABLED : ENABLED;
+
+      if (flags & SFLAG)
+	filter |= SPECIAL;
+
+      list_some_builtins (filter);
+    }
+#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
+  else if (flags & FFLAG)
+    {
+      filter = (flags & NFLAG) ? DISABLED : ENABLED;
+      if (flags & SFLAG)
+	filter |= SPECIAL;
+
+      result = dyn_load_builtin (list, filter, filename);
+#if defined (PROGRAMMABLE_COMPLETION)
+      set_itemlist_dirty (&it_builtins);
+#endif
+    }
+#endif
+#if defined (HAVE_DLCLOSE)
+  else if (flags & DFLAG)
+    {
+      while (list)
+	{
+	  opt = dyn_unload_builtin (list->word->word);
+	  if (opt == EXECUTION_FAILURE)
+	    result = EXECUTION_FAILURE;
+	  list = list->next;
+	}
+#if defined (PROGRAMMABLE_COMPLETION)
+      set_itemlist_dirty (&it_builtins);
+#endif
+    }
+#endif
+  else
+    {
+      while (list)
+	{
+	  opt = enable_shell_command (list->word->word, flags & NFLAG);
+
+	  if (opt == EXECUTION_FAILURE)
+	    {
+	      sh_notbuiltin (list->word->word);
+	      result = EXECUTION_FAILURE;
+	    }
+	  list = list->next;
+	}
+    }
+  return (result);
+}
+
+/* List some builtins.
+   FILTER is a mask with two slots: ENABLED and DISABLED. */
+static void
+list_some_builtins (filter)
+     int filter;
+{
+  register int i;
+
+  for (i = 0; i < num_shell_builtins; i++)
+    {
+      if (shell_builtins[i].function == 0 || (shell_builtins[i].flags & BUILTIN_DELETED))
+	continue;
+
+      if ((filter & SPECIAL) &&
+	  (shell_builtins[i].flags & SPECIAL_BUILTIN) == 0)
+	continue;
+
+      if ((filter & ENABLED) && (shell_builtins[i].flags & BUILTIN_ENABLED))
+	printf ("enable %s\n", shell_builtins[i].name);
+      else if ((filter & DISABLED) &&
+	       ((shell_builtins[i].flags & BUILTIN_ENABLED) == 0))
+	printf ("enable -n %s\n", shell_builtins[i].name);
+    }
+}
+
+/* Enable the shell command NAME.  If DISABLE_P is non-zero, then
+   disable NAME instead. */
+static int
+enable_shell_command (name, disable_p)
+     char *name;
+     int disable_p;
+{
+  struct builtin *b;
+
+  b = builtin_address_internal (name, 1);
+  if (b == 0)
+    return (EXECUTION_FAILURE);
+
+  if (disable_p)
+    b->flags &= ~BUILTIN_ENABLED;
+#if defined (RESTRICTED_SHELL)
+  else if (restricted && ((b->flags & BUILTIN_ENABLED) == 0))
+    {
+      sh_restricted ((char *)NULL);
+      return (EXECUTION_FAILURE);
+    }
+#endif
+  else
+    b->flags |= BUILTIN_ENABLED;
+
+#if defined (PROGRAMMABLE_COMPLETION)
+  set_itemlist_dirty (&it_enabled);
+  set_itemlist_dirty (&it_disabled);
+#endif
+
+  return (EXECUTION_SUCCESS);
+}
+
+#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)
+
+#if defined (HAVE_DLFCN_H)
+#  include <dlfcn.h>
+#endif
+
+static int
+dyn_load_builtin (list, flags, filename)
+     WORD_LIST *list;
+     int flags;
+     char *filename;
+{
+  WORD_LIST *l;
+  void *handle;
+  
+  int total, size, new, replaced;
+  char *struct_name, *name;
+  struct builtin **new_builtins, *b, *new_shell_builtins, *old_builtin;
+
+  if (list == 0)
+    return (EXECUTION_FAILURE);
+
+#ifndef RTLD_LAZY
+#define RTLD_LAZY 1
+#endif
+
+#if defined (_AIX)
+  handle = dlopen (filename, RTLD_NOW|RTLD_GLOBAL);
+#else
+  handle = dlopen (filename, RTLD_LAZY);
+#endif /* !_AIX */
+
+  if (handle == 0)
+    {
+      builtin_error (_("cannot open shared object %s: %s"), filename, dlerror ());
+      return (EXECUTION_FAILURE);
+    }
+
+  for (new = 0, l = list; l; l = l->next, new++)
+    ;
+  new_builtins = (struct builtin **)xmalloc (new * sizeof (struct builtin *));
+
+  /* For each new builtin in the shared object, find it and its describing
+     structure.  If this is overwriting an existing builtin, do so, otherwise
+     save the loaded struct for creating the new list of builtins. */
+  for (replaced = new = 0; list; list = list->next)
+    {
+      name = list->word->word;
+
+      size = strlen (name);
+      struct_name = (char *)xmalloc (size + 8);
+      strcpy (struct_name, name);
+      strcpy (struct_name + size, "_struct");
+
+      b = (struct builtin *)dlsym (handle, struct_name);
+      if (b == 0)
+	{
+	  builtin_error (_("cannot find %s in shared object %s: %s"),
+			  struct_name, filename, dlerror ());
+	  free (struct_name);
+	  continue;
+	}
+
+      free (struct_name);
+
+      b->flags &= ~STATIC_BUILTIN;
+      if (flags & SPECIAL)
+	b->flags |= SPECIAL_BUILTIN;
+      b->handle = handle;
+
+      if (old_builtin = builtin_address_internal (name, 1))
+	{
+	  replaced++;
+	  FASTCOPY ((char *)b, (char *)old_builtin, sizeof (struct builtin));
+	}
+      else
+	  new_builtins[new++] = b;
+    }
+
+  if (replaced == 0 && new == 0)
+    {
+      free (new_builtins);
+      dlclose (handle);
+      return (EXECUTION_FAILURE);
+    }
+
+  if (new)
+    {
+      total = num_shell_builtins + new;
+      size = (total + 1) * sizeof (struct builtin);
+
+      new_shell_builtins = (struct builtin *)xmalloc (size);
+      FASTCOPY ((char *)shell_builtins, (char *)new_shell_builtins,
+		num_shell_builtins * sizeof (struct builtin));
+      for (replaced = 0; replaced < new; replaced++)
+	FASTCOPY ((char *)new_builtins[replaced],
+		  (char *)&new_shell_builtins[num_shell_builtins + replaced],
+		  sizeof (struct builtin));
+
+      new_shell_builtins[total].name = (char *)0;
+      new_shell_builtins[total].function = (sh_builtin_func_t *)0;
+      new_shell_builtins[total].flags = 0;
+
+      if (shell_builtins != static_shell_builtins)
+	free (shell_builtins);
+
+      shell_builtins = new_shell_builtins;
+      num_shell_builtins = total;
+      initialize_shell_builtins ();
+    }
+
+  free (new_builtins);
+  return (EXECUTION_SUCCESS);
+}
+#endif
+
+#if defined (HAVE_DLCLOSE)
+static void
+delete_builtin (b)
+     struct builtin *b;
+{
+  int ind, size;
+  struct builtin *new_shell_builtins;
+
+  /* XXX - funky pointer arithmetic - XXX */
+#ifdef __STDC__
+  ind = b - shell_builtins;
+#else
+  ind = ((int)b - (int)shell_builtins) / sizeof (struct builtin);
+#endif
+  size = num_shell_builtins * sizeof (struct builtin);
+  new_shell_builtins = (struct builtin *)xmalloc (size);
+
+  /* Copy shell_builtins[0]...shell_builtins[ind - 1] to new_shell_builtins */
+  if (ind)
+    FASTCOPY ((char *)shell_builtins, (char *)new_shell_builtins,
+	      ind * sizeof (struct builtin));
+  /* Copy shell_builtins[ind+1]...shell_builtins[num_shell_builtins to
+     new_shell_builtins, starting at ind. */
+  FASTCOPY ((char *)(&shell_builtins[ind+1]),
+  	    (char *)(&new_shell_builtins[ind]),
+  	    (num_shell_builtins - ind) * sizeof (struct builtin));
+
+  if (shell_builtins != static_shell_builtins)
+    free (shell_builtins);
+
+  /* The result is still sorted. */
+  num_shell_builtins--;
+  shell_builtins = new_shell_builtins;
+}
+
+/* Tenon's MachTen has a dlclose that doesn't return a value, so we
+   finesse it with a local wrapper. */
+static int
+local_dlclose (handle)
+     void *handle;
+{
+#if !defined (__MACHTEN__)
+  return (dlclose (handle));
+#else /* __MACHTEN__ */
+  dlclose (handle);
+  return ((dlerror () != NULL) ? -1 : 0);    
+#endif /* __MACHTEN__ */
+}
+
+static int
+dyn_unload_builtin (name)
+     char *name;
+{
+  struct builtin *b;
+  void *handle;
+  int ref, i;
+
+  b = builtin_address_internal (name, 1);
+  if (b == 0)
+    {
+      sh_notbuiltin (name);
+      return (EXECUTION_FAILURE);
+    }
+  if (b->flags & STATIC_BUILTIN)
+    {
+      builtin_error (_("%s: not dynamically loaded"), name);
+      return (EXECUTION_FAILURE);
+    }
+
+  handle = (void *)b->handle;
+  for (ref = i = 0; i < num_shell_builtins; i++)
+    {
+      if (shell_builtins[i].handle == b->handle)
+	ref++;
+    }
+
+  /* Don't remove the shared object unless the reference count of builtins
+     using it drops to zero. */
+  if (ref == 1 && local_dlclose (handle) != 0)
+    {
+      builtin_error (_("%s: cannot delete: %s"), name, dlerror ());
+      return (EXECUTION_FAILURE);
+    }
+
+  /* Now remove this entry from the builtin table and reinitialize. */
+  delete_builtin (b);
+
+  return (EXECUTION_SUCCESS);
+}
+#endif
diff -Nru bash-4.0-orig/builtins/eval.c bash-4.0/builtins/eval.c
--- bash-4.0-orig/builtins/eval.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/eval.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,29 @@
+/* eval.c, created from eval.def. */
+#line 22 "./eval.def"
+
+#line 34 "./eval.def"
+
+#include <config.h>
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../shell.h"
+#include "bashgetopt.h"
+#include "common.h"
+
+/* Parse the string that these words make, and execute the command found. */
+int
+eval_builtin (list)
+     WORD_LIST *list;
+{
+  if (no_options (list))
+    return (EX_USAGE);
+  list = loptend;	/* skip over possible `--' */
+
+  /* Note that parse_and_execute () frees the string it is passed. */
+  return (list ? parse_and_execute (string_list (list), "eval", SEVAL_NOHIST) : EXECUTION_SUCCESS);
+}
diff -Nru bash-4.0-orig/builtins/exec.c bash-4.0/builtins/exec.c
--- bash-4.0-orig/builtins/exec.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/exec.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,198 @@
+/* exec.c, created from exec.def. */
+#line 22 "./exec.def"
+
+#line 43 "./exec.def"
+
+#include <config.h>
+
+#include "../bashtypes.h"
+#include "posixstat.h"
+#include <signal.h>
+#include <errno.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../execute_cmd.h"
+#include "../findcmd.h"
+#if defined (JOB_CONTROL)
+#  include "../jobs.h"
+#endif
+#include "../flags.h"
+#include "../trap.h"
+#if defined (HISTORY)
+#  include "../bashhist.h"
+#endif
+#include "common.h"
+#include "bashgetopt.h"
+
+/* Not all systems declare ERRNO in errno.h... and some systems #define it! */
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+extern int subshell_environment;
+extern REDIRECT *redirection_undo_list;
+
+int no_exit_on_failed_exec;
+
+/* If the user wants this to look like a login shell, then
+   prepend a `-' onto NAME and return the new name. */
+static char *
+mkdashname (name)
+     char *name;
+{
+  char *ret;
+
+  ret = (char *)xmalloc (2 + strlen (name));
+  ret[0] = '-';
+  strcpy (ret + 1, name);
+  return ret;
+}
+
+int
+exec_builtin (list)
+     WORD_LIST *list;
+{
+  int exit_value = EXECUTION_FAILURE;
+  int cleanenv, login, opt;
+  char *argv0, *command, **args, **env, *newname, *com2;
+
+  cleanenv = login = 0;
+  argv0 = (char *)NULL;
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "cla:")) != -1)
+    {
+      switch (opt)
+	{
+	case 'c':
+	  cleanenv = 1;
+	  break;
+	case 'l':
+	  login = 1;
+	  break;
+	case 'a':
+	  argv0 = list_optarg;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  /* First, let the redirections remain. */
+  dispose_redirects (redirection_undo_list);
+  redirection_undo_list = (REDIRECT *)NULL;
+
+  if (list == 0)
+    return (EXECUTION_SUCCESS);
+
+#if defined (RESTRICTED_SHELL)
+  if (restricted)
+    {
+      sh_restricted ((char *)NULL);
+      return (EXECUTION_FAILURE);
+    }
+#endif /* RESTRICTED_SHELL */
+
+  args = strvec_from_word_list (list, 1, 0, (int *)NULL);
+
+  /* A command with a slash anywhere in its name is not looked up in $PATH. */
+  command = absolute_program (args[0]) ? args[0] : search_for_command (args[0]);
+
+  if (command == 0)
+    {
+      sh_notfound (args[0]);
+      exit_value = EX_NOTFOUND;	/* As per Posix.2, 3.14.6 */
+      goto failed_exec;
+    }
+
+  com2 = full_pathname (command);
+  if (com2)
+    {
+      if (command != args[0])
+	free (command);
+      command = com2;
+    }
+
+  if (argv0)
+    {
+      free (args[0]);
+      args[0] = login ? mkdashname (argv0) : savestring (argv0);
+    }
+  else if (login)
+    {
+      newname = mkdashname (args[0]);
+      free (args[0]);
+      args[0] = newname;
+    }
+
+  /* Decrement SHLVL by 1 so a new shell started here has the same value,
+     preserving the appearance.  After we do that, we need to change the
+     exported environment to include the new value. */
+  if (cleanenv == 0)
+    adjust_shell_level (-1);
+
+  if (cleanenv)
+    env = (char **)NULL;
+  else
+    {	
+      maybe_make_export_env ();
+      env = export_env;
+    }
+
+#if defined (HISTORY)
+  if (interactive_shell && subshell_environment == 0)
+    maybe_save_shell_history ();
+#endif /* HISTORY */
+
+  restore_original_signals ();
+
+#if defined (JOB_CONTROL)
+  if (subshell_environment == 0)
+    end_job_control ();
+#endif /* JOB_CONTROL */
+
+  shell_execve (command, args, env);
+
+  /* We have to set this to NULL because shell_execve has called realloc()
+     to stuff more items at the front of the array, which may have caused
+     the memory to be freed by realloc().  We don't want to free it twice. */
+  args = (char **)NULL;
+  if (cleanenv == 0)
+    adjust_shell_level (1);
+
+  if (executable_file (command) == 0)
+    {
+      builtin_error (_("%s: cannot execute: %s"), command, strerror (errno));
+      exit_value = EX_NOEXEC;	/* As per Posix.2, 3.14.6 */
+    }
+  else
+    file_error (command);
+
+failed_exec:
+  FREE (command);
+
+  if (subshell_environment || (interactive == 0 && no_exit_on_failed_exec == 0))
+    exit_shell (exit_value);
+
+  if (args)
+    strvec_dispose (args);
+
+  initialize_traps ();
+  initialize_signals (1);
+
+#if defined (JOB_CONTROL)
+  if (interactive_shell || job_control)
+    restart_job_control ();
+#endif /* JOB_CONTROL */
+
+  return (exit_value);
+}
diff -Nru bash-4.0-orig/builtins/exit.c bash-4.0/builtins/exit.c
--- bash-4.0-orig/builtins/exit.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/exit.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,135 @@
+/* exit.c, created from exit.def. */
+#line 22 "./exit.def"
+
+#line 31 "./exit.def"
+
+#include <config.h>
+
+#include "../bashtypes.h"
+#include <stdio.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../jobs.h"
+
+#include "common.h"
+#include "builtext.h"	/* for jobs_builtin */
+
+extern int check_jobs_at_exit;
+extern int last_command_exit_value;
+extern int running_trap, trap_saved_exit_value;
+extern int subshell_environment;
+extern sh_builtin_func_t *this_shell_builtin;
+extern sh_builtin_func_t *last_shell_builtin;
+
+static int exit_or_logout __P((WORD_LIST *));
+static int sourced_logout;
+
+int
+exit_builtin (list)
+     WORD_LIST *list;
+{
+  if (interactive)
+    {
+      fprintf (stderr, login_shell ? _("logout\n") : "exit\n");
+      fflush (stderr);
+    }
+
+  return (exit_or_logout (list));
+}
+
+#line 80 "./exit.def"
+
+/* How to logout. */
+int
+logout_builtin (list)
+     WORD_LIST *list;
+{
+  if (login_shell == 0 /* && interactive */)
+    {
+      builtin_error (_("not login shell: use `exit'"));
+      return (EXECUTION_FAILURE);
+    }
+  else
+    return (exit_or_logout (list));
+}
+
+static int
+exit_or_logout (list)
+     WORD_LIST *list;
+{
+  int exit_value;
+
+#if defined (JOB_CONTROL)
+  int exit_immediate_okay, stopmsg;
+
+  exit_immediate_okay = (interactive  == 0 ||
+			 last_shell_builtin == exit_builtin ||
+			 last_shell_builtin == logout_builtin ||
+			 last_shell_builtin == jobs_builtin);
+
+  /* Check for stopped jobs if the user wants to. */
+  if (exit_immediate_okay == 0)
+    {
+      register int i;
+      for (i = stopmsg = 0; i < js.j_jobslots; i++)
+	if (jobs[i] && STOPPED (i))
+	  stopmsg = JSTOPPED;
+	else if (check_jobs_at_exit && stopmsg == 0 && RUNNING (i))
+	  stopmsg = JRUNNING;
+
+      if (stopmsg == JSTOPPED)
+	fprintf (stderr, _("There are stopped jobs.\n"));
+      else if (stopmsg == JRUNNING)
+	fprintf (stderr, _("There are running jobs.\n"));
+
+      if (stopmsg && check_jobs_at_exit)
+        list_all_jobs (JLIST_STANDARD);
+
+      if (stopmsg)
+	{
+	  /* This is NOT superfluous because EOF can get here without
+	     going through the command parser.  Set both last and this
+	     so that either `exit', `logout', or ^D will work to exit
+	     immediately if nothing intervenes. */
+	  this_shell_builtin = last_shell_builtin = exit_builtin;
+	  return (EXECUTION_FAILURE);
+	}
+    }
+#endif /* JOB_CONTROL */
+
+  /* Get return value if present.  This means that you can type
+     `logout 5' to a shell, and it returns 5. */
+
+  /* If we're running the exit trap (running_trap == 1, since running_trap
+     gets set to SIG+1), and we don't have a argument given to `exit'
+     (list == 0), use the exit status we saved before running the trap
+     commands (trap_saved_exit_value). */
+  exit_value = (running_trap == 1 && list == 0) ? trap_saved_exit_value : get_exitstat (list);
+
+  bash_logout ();
+
+  last_command_exit_value = exit_value;
+
+  /* Exit the program. */
+  jump_to_top_level (EXITPROG);
+  /*NOTREACHED*/
+}
+
+void
+bash_logout ()
+{
+  /* Run our `~/.bash_logout' file if it exists, and this is a login shell. */
+  if (login_shell && sourced_logout++ == 0 && subshell_environment == 0)
+    {
+      maybe_execute_file ("~/.bash_logout", 1);
+#ifdef SYS_BASH_LOGOUT
+      maybe_execute_file (SYS_BASH_LOGOUT, 1);
+#endif
+    }
+}
diff -Nru bash-4.0-orig/builtins/exit.def bash-4.0/builtins/exit.def
--- bash-4.0-orig/builtins/exit.def	2009-01-04 20:32:22.000000000 +0100
+++ bash-4.0/builtins/exit.def	2009-12-08 18:04:02.000000000 +0100
@@ -113,7 +113,7 @@
       for (i = stopmsg = 0; i < js.j_jobslots; i++)
 	if (jobs[i] && STOPPED (i))
 	  stopmsg = JSTOPPED;
-	else if (check_jobs_at_exit && stopmsg == 0 && RUNNING (i))
+	else if (check_jobs_at_exit && stopmsg == 0 && jobs[i] && RUNNING (i))
 	  stopmsg = JRUNNING;
 
       if (stopmsg == JSTOPPED)
diff -Nru bash-4.0-orig/builtins/fc.c bash-4.0/builtins/fc.c
--- bash-4.0-orig/builtins/fc.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/fc.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,606 @@
+/* fc.c, created from fc.def. */
+#line 22 "./fc.def"
+
+#line 51 "./fc.def"
+
+#include <config.h>
+
+#if defined (HISTORY)
+#ifndef _MINIX
+#  include <sys/param.h>
+#endif
+#include "../bashtypes.h"
+#include "posixstat.h"
+#if ! defined(_MINIX) && defined (HAVE_SYS_FILE_H)
+#  include <sys/file.h>
+#endif
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include <chartypes.h>
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+#include <errno.h>
+
+#include "../shell.h"
+#include "../builtins.h"
+#include "../flags.h"
+#include "../bashhist.h"
+#include "maxpath.h"
+#include <readline/history.h>
+#include "bashgetopt.h"
+#include "common.h"
+
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+extern int current_command_line_count;
+extern int literal_history;
+extern int posixly_correct;
+
+extern int unlink __P((const char *));
+
+extern FILE *sh_mktmpfp __P((char *, int, char **));
+
+/* **************************************************************** */
+/*								    */
+/*	The K*rn shell style fc command (Fix Command)		    */
+/*								    */
+/* **************************************************************** */
+
+/* fc builtin command (fix command) for Bash for those who
+   like K*rn-style history better than csh-style.
+
+     fc [-e ename] [-nlr] [first] [last]
+
+   FIRST and LAST can be numbers specifying the range, or FIRST can be
+   a string, which means the most recent command beginning with that
+   string.
+
+   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,
+      then the editor which corresponds to the current readline editing
+      mode, then vi.
+
+   -l means list lines instead of editing.
+   -n means no line numbers listed.
+   -r means reverse the order of the lines (making it newest listed first).
+
+     fc -e - [pat=rep ...] [command]
+     fc -s [pat=rep ...] [command]
+
+   Equivalent to !command:sg/pat/rep execpt there can be multiple PAT=REP's.
+*/
+
+/* Data structure describing a list of global replacements to perform. */
+typedef struct repl {
+  struct repl *next;
+  char *pat;
+  char *rep;
+} REPL;
+
+/* Accessors for HIST_ENTRY lists that are called HLIST. */
+#define histline(i) (hlist[(i)]->line)
+#define histdata(i) (hlist[(i)]->data)
+
+#define FREE_RLIST() \
+	do { \
+		for (rl = rlist; rl; ) { \
+			REPL *r;	\
+			r = rl->next; \
+			if (rl->pat) \
+				free (rl->pat); \
+			if (rl->rep) \
+				free (rl->rep); \
+			free (rl); \
+			rl = r; \
+		} \
+	} while (0)
+
+static char *fc_dosubs __P((char *, REPL *));
+static char *fc_gethist __P((char *, HIST_ENTRY **));
+static int fc_gethnum __P((char *, HIST_ENTRY **));
+static int fc_number __P((WORD_LIST *));
+static void fc_replhist __P((char *));
+#ifdef INCLUDE_UNUSED
+static char *fc_readline __P((FILE *));
+static void fc_addhist __P((char *));
+#endif
+
+/* String to execute on a file that we want to edit. */
+#define FC_EDIT_COMMAND "${FCEDIT:-${EDITOR:-vi}}"
+#if defined (STRICT_POSIX)
+#  define POSIX_FC_EDIT_COMMAND "${FCEDIT:-ed}"
+#else
+#  define POSIX_FC_EDIT_COMMAND "${FCEDIT:-${EDITOR:-ed}}"
+#endif
+
+int
+fc_builtin (list)
+     WORD_LIST *list;
+{
+  register int i;
+  register char *sep;
+  int numbering, reverse, listing, execute;
+  int histbeg, histend, last_hist, retval, opt;
+  FILE *stream;
+  REPL *rlist, *rl;
+  char *ename, *command, *newcom, *fcedit;
+  HIST_ENTRY **hlist;
+  char *fn;
+
+  numbering = 1;
+  reverse = listing = execute = 0;
+  ename = (char *)NULL;
+
+  /* Parse out the options and set which of the two forms we're in. */
+  reset_internal_getopt ();
+  lcurrent = list;		/* XXX */
+  while (fc_number (loptend = lcurrent) == 0 &&
+	 (opt = internal_getopt (list, ":e:lnrs")) != -1)
+    {
+      switch (opt)
+	{
+	case 'n':
+	  numbering = 0;
+	  break;
+
+	case 'l':
+	  listing = 1;
+	  break;
+
+	case 'r':
+	  reverse = 1;
+	  break;
+
+	case 's':
+	  execute = 1;
+	  break;
+
+	case 'e':
+	  ename = list_optarg;
+	  break;
+
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+  if (ename && (*ename == '-') && (ename[1] == '\0'))
+    execute = 1;
+
+  /* The "execute" form of the command (re-run, with possible string
+     substitutions). */
+  if (execute)
+    {
+      rlist = (REPL *)NULL;
+      while (list && ((sep = (char *)strchr (list->word->word, '=')) != NULL))
+	{
+	  *sep++ = '\0';
+	  rl = (REPL *)xmalloc (sizeof (REPL));
+	  rl->next = (REPL *)NULL;
+	  rl->pat = savestring (list->word->word);
+	  rl->rep = savestring (sep);
+
+	  if (rlist == NULL)
+	    rlist = rl;
+	  else
+	    {
+	      rl->next = rlist;
+	      rlist = rl;
+	    }
+	  list = list->next;
+	}
+
+      /* If we have a list of substitutions to do, then reverse it
+	 to get the replacements in the proper order. */
+
+      rlist = REVERSE_LIST (rlist, REPL *);
+
+      hlist = history_list ();
+
+      /* If we still have something in list, it is a command spec.
+	 Otherwise, we use the most recent command in time. */
+      command = fc_gethist (list ? list->word->word : (char *)NULL, hlist);
+
+      if (command == NULL)
+	{
+	  builtin_error (_("no command found"));
+	  if (rlist)
+	    FREE_RLIST ();
+
+	  return (EXECUTION_FAILURE);
+	}
+
+      if (rlist)
+	{
+	  newcom = fc_dosubs (command, rlist);
+	  free (command);
+	  FREE_RLIST ();
+	  command = newcom;
+	}
+
+      fprintf (stderr, "%s\n", command);
+      fc_replhist (command);	/* replace `fc -s' with command */
+      return (parse_and_execute (command, "fc", SEVAL_NOHIST));
+    }
+
+  /* This is the second form of the command (the list-or-edit-and-rerun
+     form). */
+  hlist = history_list ();
+  if (hlist == 0)
+    return (EXECUTION_SUCCESS);
+  for (i = 0; hlist[i]; i++);
+
+  /* With the Bash implementation of history, the current command line
+     ("fc blah..." and so on) is already part of the history list by
+     the time we get to this point.  This just skips over that command
+     and makes the last command that this deals with be the last command
+     the user entered before the fc.  We need to check whether the
+     line was actually added (HISTIGNORE may have caused it to not be),
+     so we check hist_last_line_added. */
+
+  last_hist = i - remember_on_history - hist_last_line_added;
+
+  if (list)
+    {
+      histbeg = fc_gethnum (list->word->word, hlist);
+      list = list->next;
+
+      if (list)
+	histend = fc_gethnum (list->word->word, hlist);
+      else
+	histend = listing ? last_hist : histbeg;
+    }
+  else
+    {
+      /* The default for listing is the last 16 history items. */
+      if (listing)
+	{
+	  histend = last_hist;
+	  histbeg = histend - 16 + 1;	/* +1 because loop below uses >= */
+	  if (histbeg < 0)
+	    histbeg = 0;
+	}
+      else
+	/* For editing, it is the last history command. */
+	histbeg = histend = last_hist;
+    }
+
+  /* "When not listing, the fc command that caused the editing shall not be
+     entered into the history list." */
+  if (listing == 0 && hist_last_line_added)
+    {
+      bash_delete_last_history ();
+      /* If we're editing a single command -- the last command in the
+	 history -- and we just removed the dummy command added by
+	 edit_and_execute_command (), we need to check whether or not we
+	 just removed the last command in the history and need to back
+	 the pointer up.  remember_on_history is off because we're running
+	 in parse_and_execute(). */
+      if (histbeg == histend && histend == last_hist && hlist[last_hist] == 0)
+	last_hist = histbeg = --histend;
+    }
+
+  /* We print error messages for line specifications out of range. */
+  if ((histbeg < 0) || (histend < 0))
+    {
+      sh_erange ((char *)NULL, _("history specification"));
+      return (EXECUTION_FAILURE);
+    }
+
+  if (histend < histbeg)
+    {
+      i = histend;
+      histend = histbeg;
+      histbeg = i;
+
+      reverse = 1;
+    }
+
+  if (listing)
+    stream = stdout;
+  else
+    {
+      numbering = 0;
+      stream = sh_mktmpfp ("bash-fc", MT_USERANDOM|MT_USETMPDIR, &fn);
+      if (stream == 0)
+	{
+	  builtin_error (_("%s: cannot open temp file: %s"), fn ? fn : "", strerror (errno));
+	  FREE (fn);
+	  return (EXECUTION_FAILURE);
+	}
+    }
+
+  for (i = reverse ? histend : histbeg; reverse ? i >= histbeg : i <= histend; reverse ? i-- : i++)
+    {
+      QUIT;
+      if (numbering)
+	fprintf (stream, "%d", i + history_base);
+      if (listing)
+	{
+	  if (posixly_correct)
+	    fputs ("\t", stream);
+	  else
+	    fprintf (stream, "\t%c", histdata (i) ? '*' : ' ');
+	}
+      fprintf (stream, "%s\n", histline (i));
+    }
+
+  if (listing)
+    return (sh_chkwrite (EXECUTION_SUCCESS));
+
+  fflush (stream);
+  if (ferror (stream))
+    {
+      sh_wrerror ();
+      fclose (stream);
+      return (EXECUTION_FAILURE);
+    }
+  fclose (stream);
+
+  /* Now edit the file of commands. */
+  if (ename)
+    {
+      command = (char *)xmalloc (strlen (ename) + strlen (fn) + 2);
+      sprintf (command, "%s %s", ename, fn);
+    }
+  else
+    {
+      fcedit = posixly_correct ? POSIX_FC_EDIT_COMMAND : FC_EDIT_COMMAND;
+      command = (char *)xmalloc (3 + strlen (fcedit) + strlen (fn));
+      sprintf (command, "%s %s", fcedit, fn);
+    }
+  retval = parse_and_execute (command, "fc", SEVAL_NOHIST);
+  if (retval != EXECUTION_SUCCESS)
+    {
+      unlink (fn);
+      free (fn);
+      return (EXECUTION_FAILURE);
+    }
+
+  /* Make sure parse_and_execute doesn't turn this off, even though a
+     call to parse_and_execute farther up the function call stack (e.g.,
+     if this is called by vi_edit_and_execute_command) may have already
+     called bash_history_disable. */
+  remember_on_history = 1;
+
+  /* Turn on the `v' flag while fc_execute_file runs so the commands
+     will be echoed as they are read by the parser. */
+  begin_unwind_frame ("fc builtin");
+  add_unwind_protect ((Function *)xfree, fn);
+  add_unwind_protect (unlink, fn);
+  unwind_protect_int (echo_input_at_read);
+  echo_input_at_read = 1;
+    
+  retval = fc_execute_file (fn);
+
+  run_unwind_frame ("fc builtin");
+
+  return (retval);
+}
+
+/* Return 1 if LIST->word->word is a legal number for fc's use. */
+static int
+fc_number (list)
+     WORD_LIST *list;
+{
+  char *s;
+
+  if (list == 0)
+    return 0;
+  s = list->word->word;
+  if (*s == '-')
+    s++;
+  return (legal_number (s, (intmax_t *)NULL));
+}
+
+/* Return an absolute index into HLIST which corresponds to COMMAND.  If
+   COMMAND is a number, then it was specified in relative terms.  If it
+   is a string, then it is the start of a command line present in HLIST. */
+static int
+fc_gethnum (command, hlist)
+     char *command;
+     HIST_ENTRY **hlist;
+{
+  int sign, n, clen;
+  register int i, j;
+  register char *s;
+
+  sign = 1;
+  /* Count history elements. */
+  for (i = 0; hlist[i]; i++);
+
+  /* With the Bash implementation of history, the current command line
+     ("fc blah..." and so on) is already part of the history list by
+     the time we get to this point.  This just skips over that command
+     and makes the last command that this deals with be the last command
+     the user entered before the fc.  We need to check whether the
+     line was actually added (HISTIGNORE may have caused it to not be),
+     so we check hist_last_line_added.  This needs to agree with the
+     calculation of last_hist in fc_builtin above. */
+  i -= remember_on_history + hist_last_line_added;
+
+  /* No specification defaults to most recent command. */
+  if (command == NULL)
+    return (i);
+
+  /* Otherwise, there is a specification.  It can be a number relative to
+     the current position, or an absolute history number. */
+  s = command;
+
+  /* Handle possible leading minus sign. */
+  if (s && (*s == '-'))
+    {
+      sign = -1;
+      s++;
+    }
+
+  if (s && DIGIT(*s))
+    {
+      n = atoi (s);
+      n *= sign;
+
+      /* If the value is negative or zero, then it is an offset from
+	 the current history item. */
+      if (n < 0)
+	{
+	  n += i + 1;
+	  return (n < 0 ? 0 : n);
+	}
+      else if (n == 0)
+	return (i);
+      else
+	{
+	  n -= history_base;
+	  return (i < n ? i : n);
+	}
+    }
+
+  clen = strlen (command);
+  for (j = i; j >= 0; j--)
+    {
+      if (STREQN (command, histline (j), clen))
+	return (j);
+    }
+  return (-1);
+}
+
+/* Locate the most recent history line which begins with
+   COMMAND in HLIST, and return a malloc()'ed copy of it. */
+static char *
+fc_gethist (command, hlist)
+     char *command;
+     HIST_ENTRY **hlist;
+{
+  int i;
+
+  if (hlist == 0)
+    return ((char *)NULL);
+
+  i = fc_gethnum (command, hlist);
+
+  if (i >= 0)
+    return (savestring (histline (i)));
+  else
+    return ((char *)NULL);
+}
+
+#ifdef INCLUDE_UNUSED
+/* Read the edited history lines from STREAM and return them
+   one at a time.  This can read unlimited length lines.  The
+   caller should free the storage. */
+static char *
+fc_readline (stream)
+     FILE *stream;
+{
+  register int c;
+  int line_len = 0, lindex = 0;
+  char *line = (char *)NULL;
+
+  while ((c = getc (stream)) != EOF)
+    {
+      if ((lindex + 2) >= line_len)
+	line = (char *)xrealloc (line, (line_len += 128));
+
+      if (c == '\n')
+	{
+	  line[lindex++] = '\n';
+	  line[lindex++] = '\0';
+	  return (line);
+	}
+      else
+	line[lindex++] = c;
+    }
+
+  if (!lindex)
+    {
+      if (line)
+	free (line);
+
+      return ((char *)NULL);
+    }
+
+  if (lindex + 2 >= line_len)
+    line = (char *)xrealloc (line, lindex + 3);
+
+  line[lindex++] = '\n';	    /* Finish with newline if none in file */
+  line[lindex++] = '\0';
+  return (line);
+}
+#endif
+
+/* Perform the SUBS on COMMAND.
+   SUBS is a list of substitutions, and COMMAND is a simple string.
+   Return a pointer to a malloc'ed string which contains the substituted
+   command. */
+static char *
+fc_dosubs (command, subs)
+     char *command;
+     REPL *subs;
+{
+  register char *new, *t;
+  register REPL *r;
+
+  for (new = savestring (command), r = subs; r; r = r->next)
+    {
+      t = strsub (new, r->pat, r->rep, 1);
+      free (new);
+      new = t;
+    }
+  return (new);
+}
+
+/* Use `command' to replace the last entry in the history list, which,
+   by this time, is `fc blah...'.  The intent is that the new command
+   become the history entry, and that `fc' should never appear in the
+   history list.  This way you can do `r' to your heart's content. */
+static void
+fc_replhist (command)
+     char *command;
+{
+  int n;
+
+  if (command == 0 || *command == '\0')
+    return;
+
+  n = strlen (command);
+  if (command[n - 1] == '\n')
+    command[n - 1] = '\0';
+
+  if (command && *command)
+    {
+      bash_delete_last_history ();
+      maybe_add_history (command);	/* Obeys HISTCONTROL setting. */
+    }
+}
+
+#ifdef INCLUDE_UNUSED
+/* Add LINE to the history, after removing a single trailing newline. */
+static void
+fc_addhist (line)
+     char *line;
+{
+  register int n;
+
+  if (line == 0 || *line == 0)
+    return;
+
+  n = strlen (line);
+
+  if (line[n - 1] == '\n')
+    line[n - 1] = '\0';
+
+  if (line && *line)
+    maybe_add_history (line);		/* Obeys HISTCONTROL setting. */
+}
+#endif
+
+#endif /* HISTORY */
diff -Nru bash-4.0-orig/builtins/fc.def bash-4.0/builtins/fc.def
--- bash-4.0-orig/builtins/fc.def	2009-01-04 20:32:22.000000000 +0100
+++ bash-4.0/builtins/fc.def	2009-12-08 18:04:02.000000000 +0100
@@ -88,6 +88,7 @@
 extern int current_command_line_count;
 extern int literal_history;
 extern int posixly_correct;
+extern int subshell_environment, interactive_shell;
 
 extern int unlink __P((const char *));
 
@@ -172,7 +173,7 @@
   register int i;
   register char *sep;
   int numbering, reverse, listing, execute;
-  int histbeg, histend, last_hist, retval, opt;
+  int histbeg, histend, last_hist, retval, opt, rh;
   FILE *stream;
   REPL *rlist, *rl;
   char *ename, *command, *newcom, *fcedit;
@@ -275,6 +276,8 @@
 
       fprintf (stderr, "%s\n", command);
       fc_replhist (command);	/* replace `fc -s' with command */
+      /* Posix says that the re-executed commands should be entered into the
+	 history. */
       return (parse_and_execute (command, "fc", SEVAL_NOHIST));
     }
 
@@ -293,7 +296,12 @@
      line was actually added (HISTIGNORE may have caused it to not be),
      so we check hist_last_line_added. */
 
-  last_hist = i - remember_on_history - hist_last_line_added;
+  /* Even though command substitution through parse_and_execute turns off
+     remember_on_history, command substitution in a shell when set -o history
+     has been enabled (interactive or not) should use it in the last_hist
+     calculation as if it were on. */
+  rh = remember_on_history || ((subshell_environment & SUBSHELL_COMSUB) && enable_history_list);
+  last_hist = i - rh - hist_last_line_added;
 
   if (list)
     {
@@ -456,7 +464,7 @@
      char *command;
      HIST_ENTRY **hlist;
 {
-  int sign, n, clen;
+  int sign, n, clen, rh;
   register int i, j;
   register char *s;
 
@@ -472,7 +480,12 @@
      line was actually added (HISTIGNORE may have caused it to not be),
      so we check hist_last_line_added.  This needs to agree with the
      calculation of last_hist in fc_builtin above. */
-  i -= remember_on_history + hist_last_line_added;
+  /* Even though command substitution through parse_and_execute turns off
+     remember_on_history, command substitution in a shell when set -o history
+     has been enabled (interactive or not) should use it in the last_hist
+     calculation as if it were on. */
+  rh = remember_on_history || ((subshell_environment & SUBSHELL_COMSUB) && enable_history_list);
+  i -= rh + hist_last_line_added;
 
   /* No specification defaults to most recent command. */
   if (command == NULL)
diff -Nru bash-4.0-orig/builtins/fg_bg.c bash-4.0/builtins/fg_bg.c
--- bash-4.0-orig/builtins/fg_bg.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/fg_bg.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,143 @@
+/* fg_bg.c, created from fg_bg.def. */
+#line 22 "./fg_bg.def"
+
+#line 36 "./fg_bg.def"
+
+#include <config.h>
+
+#include "../bashtypes.h"
+#include <signal.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../jobs.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#if defined (JOB_CONTROL)
+extern char *this_command_name;
+
+static int fg_bg __P((WORD_LIST *, int));
+
+/* How to bring a job into the foreground. */
+int
+fg_builtin (list)
+     WORD_LIST *list;
+{
+  int fg_bit;
+  register WORD_LIST *t;
+
+  if (job_control == 0)
+    {
+      sh_nojobs ((char *)NULL);
+      return (EXECUTION_FAILURE);
+    }
+
+  if (no_options (list))
+    return (EX_USAGE);
+  list = loptend;
+
+  /* If the last arg on the line is '&', then start this job in the
+     background.  Else, fg the job. */
+  for (t = list; t && t->next; t = t->next)
+    ;
+  fg_bit = (t && t->word->word[0] == '&' && t->word->word[1] == '\0') == 0;
+
+  return (fg_bg (list, fg_bit));
+}
+#endif /* JOB_CONTROL */
+
+#line 99 "./fg_bg.def"
+
+#if defined (JOB_CONTROL)
+/* How to put a job into the background. */
+int
+bg_builtin (list)
+     WORD_LIST *list;
+{
+  int r;
+
+  if (job_control == 0)
+    {
+      sh_nojobs ((char *)NULL);
+      return (EXECUTION_FAILURE);
+    }
+
+  if (no_options (list))
+    return (EX_USAGE);
+  list = loptend;
+
+  /* This relies on the fact that fg_bg() takes a WORD_LIST *, but only acts
+     on the first member (if any) of that list. */
+  r = EXECUTION_SUCCESS;
+  do
+    {
+      if (fg_bg (list, 0) == EXECUTION_FAILURE)
+	r = EXECUTION_FAILURE;
+      if (list)
+	list = list->next;
+    }
+  while (list);
+
+  return r;
+}
+
+/* How to put a job into the foreground/background. */
+static int
+fg_bg (list, foreground)
+     WORD_LIST *list;
+     int foreground;
+{
+  sigset_t set, oset;
+  int job, status, old_async_pid;
+  JOB *j;
+
+  BLOCK_CHILD (set, oset);
+  job = get_job_spec (list);
+
+  if (INVALID_JOB (job))
+    {
+      if (job != DUP_JOB)
+	sh_badjob (list ? list->word->word : _("current"));
+
+      goto failure;
+    }
+
+  j = get_job_by_jid (job);
+  /* Or if j->pgrp == shell_pgrp. */
+  if (IS_JOBCONTROL (job) == 0)
+    {
+      builtin_error (_("job %d started without job control"), job + 1);
+      goto failure;
+    }
+
+  if (foreground == 0)
+    {
+      old_async_pid = last_asynchronous_pid;
+      last_asynchronous_pid = j->pgrp;	/* As per Posix.2 5.4.2 */
+    }
+
+  status = start_job (job, foreground);
+
+  if (status >= 0)
+    {
+    /* win: */
+      UNBLOCK_CHILD (oset);
+      return (foreground ? status : EXECUTION_SUCCESS);
+    }
+  else
+    {
+      if (foreground == 0)
+	last_asynchronous_pid = old_async_pid;
+
+    failure:
+      UNBLOCK_CHILD (oset);
+      return (EXECUTION_FAILURE);
+    }
+}
+#endif /* JOB_CONTROL */
diff -Nru bash-4.0-orig/builtins/getopts.c bash-4.0/builtins/getopts.c
--- bash-4.0-orig/builtins/getopts.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/getopts.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,270 @@
+/* getopts.c, created from getopts.def. */
+#line 22 "./getopts.def"
+
+#line 64 "./getopts.def"
+
+#include <config.h>
+
+#include <stdio.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+
+#include "../shell.h"
+#include "common.h"
+#include "bashgetopt.h"
+#include "getopt.h"
+
+#define G_EOF		-1
+#define G_INVALID_OPT	-2
+#define G_ARG_MISSING	-3
+
+extern char *this_command_name;
+
+static int getopts_bind_variable __P((char *, char *));
+static int dogetopts __P((int, char **));
+
+/* getopts_reset is magic code for when OPTIND is reset.  N is the
+   value that has just been assigned to OPTIND. */
+void
+getopts_reset (newind)
+     int newind;
+{
+  sh_optind = newind;
+  sh_badopt = 0;
+}
+
+static int
+getopts_bind_variable (name, value)
+     char *name, *value;
+{
+  SHELL_VAR *v;
+
+  if (legal_identifier (name))
+    {
+      v = bind_variable (name, value, 0);
+      return (v && (readonly_p (v) == 0)) ? EXECUTION_SUCCESS : EXECUTION_FAILURE;
+    }
+  else
+    {
+      sh_invalidid (name);
+      return (EXECUTION_FAILURE);
+    }
+}
+
+/* Error handling is now performed as specified by Posix.2, draft 11
+   (identical to that of ksh-88).  The special handling is enabled if
+   the first character of the option string is a colon; this handling
+   disables diagnostic messages concerning missing option arguments
+   and invalid option characters.  The handling is as follows.
+
+   INVALID OPTIONS:
+        name -> "?"
+        if (special_error) then
+                OPTARG = option character found
+                no error output
+        else
+                OPTARG unset
+                diagnostic message
+        fi
+ 
+  MISSING OPTION ARGUMENT;
+        if (special_error) then
+                name -> ":"
+                OPTARG = option character found
+        else
+                name -> "?"
+                OPTARG unset
+                diagnostic message
+        fi
+ */
+
+static int
+dogetopts (argc, argv)
+     int argc;
+     char **argv;
+{
+  int ret, special_error, old_opterr, i, n;
+  char strval[2], numval[16];
+  char *optstr;			/* list of options */
+  char *name;			/* variable to get flag val */
+  char *t;
+
+  if (argc < 3)
+    {
+      builtin_usage ();
+      return (EX_USAGE);
+    }
+
+  /* argv[0] is "getopts". */
+
+  optstr = argv[1];
+  name = argv[2];
+  argc -= 2;
+  argv += 2;
+
+  special_error = optstr[0] == ':';
+
+  if (special_error)
+    {
+      old_opterr = sh_opterr;
+      optstr++;
+      sh_opterr = 0;		/* suppress diagnostic messages */
+    }
+
+  if (argc > 1)
+    {
+      sh_getopt_restore_state (argv);
+      t = argv[0];
+      argv[0] = dollar_vars[0];
+      ret = sh_getopt (argc, argv, optstr);
+      argv[0] = t;
+    }
+  else if (rest_of_args == (WORD_LIST *)NULL)
+    {
+      for (i = 0; i < 10 && dollar_vars[i]; i++)
+	;
+
+      sh_getopt_restore_state (dollar_vars);
+      ret = sh_getopt (i, dollar_vars, optstr);
+    }
+  else
+    {
+      register WORD_LIST *words;
+      char **v;
+
+      for (i = 0; i < 10 && dollar_vars[i]; i++)
+	;
+      for (words = rest_of_args; words; words = words->next, i++)
+	;
+      v = strvec_create (i + 1);
+      for (i = 0; i < 10 && dollar_vars[i]; i++)
+	v[i] = dollar_vars[i];
+      for (words = rest_of_args; words; words = words->next, i++)
+	v[i] = words->word->word;
+      v[i] = (char *)NULL;
+      sh_getopt_restore_state (v);
+      ret = sh_getopt (i, v, optstr);
+      free (v);
+    }
+
+  if (special_error)
+    sh_opterr = old_opterr;
+
+  /* Set the OPTIND variable in any case, to handle "--" skipping.  It's
+     highly unlikely that 14 digits will be too few. */
+  if (sh_optind < 10)
+    {
+      numval[14] = sh_optind + '0';
+      numval[15] = '\0';
+      i = 14;
+    }
+  else
+    {
+      numval[i = 15] = '\0';
+      n = sh_optind;
+      do
+	{
+	  numval[--i] = (n % 10) + '0';
+	}
+      while (n /= 10);
+    }
+  bind_variable ("OPTIND", numval + i, 0);
+
+  /* If an error occurred, decide which one it is and set the return
+     code appropriately.  In all cases, the option character in error
+     is in OPTOPT.  If an invalid option was encountered, OPTARG is
+     NULL.  If a required option argument was missing, OPTARG points
+     to a NULL string (that is, sh_optarg[0] == 0). */
+  if (ret == '?')
+    {
+      if (sh_optarg == NULL)
+	ret = G_INVALID_OPT;
+      else if (sh_optarg[0] == '\0')
+	ret = G_ARG_MISSING;
+    }
+	    
+  if (ret == G_EOF)
+    {
+      unbind_variable ("OPTARG");
+      getopts_bind_variable (name, "?");
+      return (EXECUTION_FAILURE);
+    }
+
+  if (ret == G_INVALID_OPT)
+    {
+      /* Invalid option encountered. */
+      ret = getopts_bind_variable (name, "?");
+
+      if (special_error)
+	{
+	  strval[0] = (char)sh_optopt;
+	  strval[1] = '\0';
+	  bind_variable ("OPTARG", strval, 0);
+	}
+      else
+	unbind_variable ("OPTARG");
+
+      return (ret);
+    }
+
+  if (ret == G_ARG_MISSING)
+    {
+      /* Required argument missing. */
+      if (special_error)
+	{
+	  ret = getopts_bind_variable (name, ":");
+
+	  strval[0] = (char)sh_optopt;
+	  strval[1] = '\0';
+	  bind_variable ("OPTARG", strval, 0);
+	}
+      else
+	{
+	  ret = getopts_bind_variable (name, "?");
+	  unbind_variable ("OPTARG");
+	}
+      return (ret);
+    }			
+
+  bind_variable ("OPTARG", sh_optarg, 0);
+
+  strval[0] = (char) ret;
+  strval[1] = '\0';
+  return (getopts_bind_variable (name, strval));
+}
+
+/* The getopts builtin.  Build an argv, and call dogetopts with it. */
+int
+getopts_builtin (list)
+     WORD_LIST *list;
+{
+  char **av;
+  int ac, ret;
+
+  if (list == 0)
+    {
+      builtin_usage ();
+      return EX_USAGE;
+    }
+
+  reset_internal_getopt ();
+  if (internal_getopt (list, "") != -1)
+    {
+      builtin_usage ();
+      return (EX_USAGE);
+    }
+  list = loptend;
+
+  av = make_builtin_argv (list, &ac);
+  ret = dogetopts (ac, av);
+  free ((char *)av);
+
+  return (ret);
+}
diff -Nru bash-4.0-orig/builtins/hash.c bash-4.0/builtins/hash.c
--- bash-4.0-orig/builtins/hash.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/hash.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,240 @@
+/* hash.c, created from hash.def. */
+#line 22 "./hash.def"
+
+#line 46 "./hash.def"
+
+#include <config.h>
+
+#include <stdio.h>
+
+#include "../bashtypes.h"
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include <errno.h>
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../builtins.h"
+#include "../flags.h"
+#include "../findcmd.h"
+#include "../hashcmd.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+extern int posixly_correct;
+extern int dot_found_in_search;
+extern char *this_command_name;
+
+static int add_hashed_command __P((char *, int));
+static int print_hash_info __P((BUCKET_CONTENTS *));
+static int print_portable_hash_info __P((BUCKET_CONTENTS *));
+static int print_hashed_commands __P((int));
+static int list_hashed_filename_targets __P((WORD_LIST *, int));
+
+/* Print statistics on the current state of hashed commands.  If LIST is
+   not empty, then rehash (or hash in the first place) the specified
+   commands. */
+int
+hash_builtin (list)
+     WORD_LIST *list;
+{
+  int expunge_hash_table, list_targets, list_portably, delete, opt;
+  char *w, *pathname;
+
+  if (hashing_enabled == 0)
+    {
+      builtin_error (_("hashing disabled"));
+      return (EXECUTION_FAILURE);
+    }
+
+  expunge_hash_table = list_targets = list_portably = delete = 0;
+  pathname = (char *)NULL;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "dlp:rt")) != -1)
+    {
+      switch (opt)
+	{
+	case 'd':
+	  delete = 1;
+	  break;
+	case 'l':
+	  list_portably = 1;
+	  break;
+	case 'p':
+	  pathname = list_optarg;
+	  break;
+	case 'r':
+	  expunge_hash_table = 1;
+	  break;
+	case 't':
+	  list_targets = 1;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  /* hash -t requires at least one argument. */
+  if (list == 0 && list_targets)
+    {
+      sh_needarg ("-t");
+      return (EXECUTION_FAILURE);
+    }
+
+  /* We want hash -r to be silent, but hash -- to print hashing info, so
+     we test expunge_hash_table. */
+  if (list == 0 && expunge_hash_table == 0)
+    {
+      opt = print_hashed_commands (list_portably);
+      if (opt == 0 && posixly_correct == 0)
+	printf (_("%s: hash table empty\n"), this_command_name);
+
+      return (EXECUTION_SUCCESS);
+    }
+
+  if (expunge_hash_table)
+    phash_flush ();
+
+  /* If someone runs `hash -r -t xyz' he will be disappointed. */
+  if (list_targets)
+    return (list_hashed_filename_targets (list, list_portably));
+      
+#if defined (RESTRICTED_SHELL)
+  if (restricted && pathname && strchr (pathname, '/'))
+    {
+      sh_restricted (pathname);
+      return (EXECUTION_FAILURE);
+    }
+#endif
+
+  for (opt = EXECUTION_SUCCESS; list; list = list->next)
+    {
+      /* Add, remove or rehash the specified commands. */
+      w = list->word->word;
+      if (pathname)
+	{
+	  if (is_directory (pathname))
+	    {
+#ifdef EISDIR
+	      builtin_error ("%s: %s", pathname, strerror (EISDIR));
+#else
+	      builtin_error (_("%s: is a directory"), pathname);
+#endif
+	      opt = EXECUTION_FAILURE;
+	    }
+	  else
+	    phash_insert (w, pathname, 0, 0);
+	}
+      else if (absolute_program (w))
+	continue;
+      else if (delete)
+	{
+	  if (phash_remove (w))
+	    {
+	      sh_notfound (w);
+	      opt = EXECUTION_FAILURE;
+	    }
+	}
+      else if (add_hashed_command (w, 0))
+	opt = EXECUTION_FAILURE;
+    }
+
+  fflush (stdout);
+  return (opt);
+}
+
+static int
+add_hashed_command (w, quiet)
+     char *w;
+     int quiet;
+{
+  int rv;
+  char *full_path;
+
+  rv = 0;
+  if (find_function (w) == 0 && find_shell_builtin (w) == 0)
+    {
+      full_path = find_user_command (w);
+      if (full_path && executable_file (full_path))
+	phash_insert (w, full_path, dot_found_in_search, 0);
+      else
+	{
+	  if (quiet == 0)
+	    sh_notfound (w);
+	  rv++;
+	}
+      FREE (full_path);
+    }
+  return (rv);
+}
+
+/* Print information about current hashed info. */
+static int
+print_hash_info (item)
+     BUCKET_CONTENTS *item;
+{
+  printf ("%4d\t%s\n", item->times_found, pathdata(item)->path);
+  return 0;
+}
+
+static int
+print_portable_hash_info (item)
+     BUCKET_CONTENTS *item;
+{
+  printf ("builtin hash -p %s %s\n", pathdata(item)->path, item->key);
+  return 0;
+}
+
+static int
+print_hashed_commands (fmt)
+     int fmt;
+{
+  if (hashed_filenames == 0 || HASH_ENTRIES (hashed_filenames) == 0)
+    return (0);
+
+  if (fmt == 0)
+    printf (_("hits\tcommand\n"));
+  hash_walk (hashed_filenames, fmt ? print_portable_hash_info : print_hash_info);
+  return (1);
+}
+
+static int
+list_hashed_filename_targets (list, fmt)
+     WORD_LIST *list;
+     int fmt;
+{
+  int all_found, multiple;
+  char *target;
+  WORD_LIST *l;
+
+  all_found = 1;
+  multiple = list->next != 0;
+
+  for (l = list; l; l = l->next)
+    {
+      target = phash_search (l->word->word);
+      if (target == 0)
+	{
+	  all_found = 0;
+	  sh_notfound (l->word->word);
+	  continue;
+	}
+      if (fmt)
+	printf ("builtin hash -p %s %s\n", target, l->word->word);
+      else
+	{
+	  if (multiple)
+	    printf ("%s\t", l->word->word);
+	  printf ("%s\n", target);
+	}
+    }
+
+  return (all_found ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+}
diff -Nru bash-4.0-orig/builtins/help.c bash-4.0/builtins/help.c
--- bash-4.0-orig/builtins/help.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/help.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,343 @@
+/* help.c, created from help.def. */
+#line 22 "./help.def"
+
+#line 45 "./help.def"
+
+#include <config.h>
+
+#if defined (HELP_BUILTIN)
+#include <stdio.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <errno.h>
+
+#include <filecntl.h>
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../builtins.h"
+#include "../pathexp.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#include <glob/strmatch.h>
+#include <glob/glob.h>
+
+#ifndef errno
+extern int errno;
+#endif
+
+extern const char * const bash_copyright;
+extern const char * const bash_license;
+
+static void show_builtin_command_help __P((void));
+static int open_helpfile __P((char *));
+static void show_desc __P((char *, int));
+static void show_manpage __P((char *, int));
+static void show_longdoc __P((int));
+
+/* Print out a list of the known functions in the shell, and what they do.
+   If LIST is supplied, print out the list which matches for each pattern
+   specified. */
+int
+help_builtin (list)
+     WORD_LIST *list;
+{
+  register int i;
+  char *pattern, *name;
+  int plen, match_found, sflag, dflag, mflag;
+
+  dflag = sflag = mflag = 0;
+  reset_internal_getopt ();
+  while ((i = internal_getopt (list, "dms")) != -1)
+    {
+      switch (i)
+	{
+	case 'd':
+	  dflag = 1;
+	  break;
+	case 'm':
+	  mflag = 1;
+	  break;
+	case 's':
+	  sflag = 1;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  if (list == 0)
+    {
+      show_shell_version (0);
+      show_builtin_command_help ();
+      return (EXECUTION_SUCCESS);
+    }
+
+  /* We should consider making `help bash' do something. */
+
+  if (glob_pattern_p (list->word->word))
+    {
+      printf (ngettext ("Shell commands matching keyword `", "Shell commands matching keywords `", (list->next ? 2 : 1)));
+      print_word_list (list, ", ");
+      printf ("'\n\n");
+    }
+
+  for (match_found = 0, pattern = ""; list; list = list->next)
+    {
+      pattern = list->word->word;
+      plen = strlen (pattern);
+
+      for (i = 0; name = shell_builtins[i].name; i++)
+	{
+	  QUIT;
+	  if ((strncmp (pattern, name, plen) == 0) ||
+	      (strmatch (pattern, name, FNMATCH_EXTFLAG) != FNM_NOMATCH))
+	    {
+	      match_found++;
+	      if (dflag)
+		{
+		  show_desc (name, i);
+		  continue;
+		}
+	      else if (mflag)
+		{
+		  show_manpage (name, i);
+		  continue;
+		}
+
+	      printf ("%s: %s\n", name, shell_builtins[i].short_doc);
+
+	      if (sflag == 0)
+		show_longdoc (i);
+	    }
+	}
+    }
+
+  if (match_found == 0)
+    {
+      builtin_error (_("no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."), pattern, pattern, pattern);
+      return (EXECUTION_FAILURE);
+    }
+
+  fflush (stdout);
+  return (EXECUTION_SUCCESS);
+}
+
+static int
+open_helpfile (name)
+     char *name;
+{
+  int fd;
+
+  fd = open (name, O_RDONLY);
+  if (fd == -1)
+    {
+      builtin_error (_("%s: cannot open: %s"), name, strerror (errno));
+      return -1;
+    }
+  return fd;
+}
+
+/* By convention, enforced by mkbuiltins.c, if separate help files are being
+   used, the long_doc array contains one string -- the full pathname of the
+   help file for this builtin.  */
+static void
+show_longdoc (i)
+     int i;
+{
+  register int j;
+  char * const *doc;
+  int fd;
+
+  doc = shell_builtins[i].long_doc;
+
+  if (doc && doc[0] && *doc[0] == '/' && doc[1] == (char *)NULL)
+    {
+      fd = open_helpfile (doc[0]);
+      if (fd < 0)
+	return;
+      zcatfd (fd, 1, doc[0]);
+      close (fd);
+    }
+  else
+    for (j = 0; doc[j]; j++)
+      printf ("%*s%s\n", BASE_INDENT, " ", _(doc[j]));
+}
+
+static void
+show_desc (name, i)
+     char *name;
+     int i;
+{
+  register int j;
+  char **doc, *line;
+  int fd, usefile;
+
+  doc = (char **)shell_builtins[i].long_doc;
+
+  usefile = (doc && doc[0] && *doc[0] == '/' && doc[1] == (char *)NULL);
+  if (usefile)
+    {
+      fd = open_helpfile (doc[0]);
+      if (fd < 0)
+	return;
+      zmapfd (fd, &line, doc[0]);
+      close (fd);
+    }
+  else
+    line = doc ? doc[0] : (char *)NULL;
+
+  printf ("%s - ", name);
+  for (j = 0; line && line[j]; j++)
+    {
+      putchar (line[j]);
+      if (line[j] == '\n')
+	break;
+    }
+  
+  fflush (stdout);
+
+  if (usefile)
+    free (line);
+}
+
+/* Print builtin help in pseudo-manpage format. */
+static void
+show_manpage (name, i)
+     char *name;
+     int i;
+{
+  register int j;
+  char **doc, *line;
+  int fd, usefile;
+
+  doc = (char **)shell_builtins[i].long_doc;
+
+  usefile = (doc && doc[0] && *doc[0] == '/' && doc[1] == (char *)NULL);
+  if (usefile)
+    {
+      fd = open_helpfile (doc[0]);
+      if (fd < 0)
+	return;
+      zmapfd (fd, &line, doc[0]);
+      close (fd);
+    }
+  else
+    line = doc ? _(doc[0]) : (char *)NULL;
+
+  /* NAME */
+  printf ("NAME\n");
+  printf ("%*s%s - ", BASE_INDENT, " ", name);
+  for (j = 0; line && line[j]; j++)
+    {
+      putchar (line[j]);
+      if (line[j] == '\n')
+	break;
+    }
+  printf ("\n");
+
+  /* SYNOPSIS */
+  printf ("SYNOPSIS\n");
+  printf ("%*s%s\n\n", BASE_INDENT, " ", shell_builtins[i].short_doc);
+
+  /* DESCRIPTION */
+  printf ("DESCRIPTION\n");
+  if (usefile == 0)
+    {
+      for (j = 0; doc[j]; j++)
+        printf ("%*s%s\n", BASE_INDENT, " ", _(doc[j]));
+    }
+  else
+    {
+      for (j = 0; line && line[j]; j++)
+	{
+	  putchar (line[j]);
+	  if (line[j] == '\n')
+	    printf ("%*s", BASE_INDENT, " ");
+	}
+    }
+  putchar ('\n');
+
+  /* SEE ALSO */
+  printf ("SEE ALSO\n");
+  printf ("%*sbash(1)\n\n", BASE_INDENT, " ");
+
+  /* IMPLEMENTATION */
+  printf ("IMPLEMENTATION\n");
+  printf ("%*s", BASE_INDENT, " ");
+  show_shell_version (0);
+  printf ("%*s", BASE_INDENT, " ");
+  printf ("%s\n", _(bash_copyright));
+  printf ("%*s", BASE_INDENT, " ");
+  printf ("%s\n", _(bash_license));
+
+  fflush (stdout);
+  if (usefile)
+    free (line);
+}
+
+static void
+show_builtin_command_help ()
+{
+  int i, j;
+  int height, width;
+  char *t, blurb[128];
+
+  printf (
+_("These shell commands are defined internally.  Type `help' to see this list.\n\
+Type `help name' to find out more about the function `name'.\n\
+Use `info bash' to find out more about the shell in general.\n\
+Use `man -k' or `info' to find out more about commands not in this list.\n\
+\n\
+A star (*) next to a name means that the command is disabled.\n\
+\n"));
+
+  t = get_string_value ("COLUMNS");
+  width = (t && *t) ? atoi (t) : 80;
+  if (width <= 0)
+    width = 80;
+
+  width /= 2;
+  if (width > sizeof (blurb))
+    width = sizeof (blurb);
+  height = (num_shell_builtins + 1) / 2;	/* number of rows */
+
+  for (i = 0; i < height; i++)
+    {
+      QUIT;
+
+      /* first column */
+      blurb[0] = (shell_builtins[i].flags & BUILTIN_ENABLED) ? ' ' : '*';
+      strncpy (blurb + 1, shell_builtins[i].short_doc, width - 2);
+      blurb[width - 2] = '>';		/* indicate truncation */
+      blurb[width - 1] = '\0';
+      printf ("%s", blurb);
+      if (((i << 1) >= num_shell_builtins) || (i+height >= num_shell_builtins))
+	{
+	  printf ("\n");
+	  break;
+	}
+
+      /* two spaces */
+      for (j = strlen (blurb); j < width; j++)
+        putc (' ', stdout);
+
+      /* second column */
+      blurb[0] = (shell_builtins[i+height].flags & BUILTIN_ENABLED) ? ' ' : '*';
+      strncpy (blurb + 1, shell_builtins[i+height].short_doc, width - 3);
+      blurb[width - 3] = '>';		/* indicate truncation */
+      blurb[width - 2] = '\0';
+      printf ("%s\n", blurb);
+    }
+}
+#endif /* HELP_BUILTIN */
diff -Nru bash-4.0-orig/builtins/history.c bash-4.0/builtins/history.c
--- bash-4.0-orig/builtins/history.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/history.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,328 @@
+/* history.c, created from history.def. */
+#line 22 "./history.def"
+
+#line 57 "./history.def"
+
+#include <config.h>
+
+#if defined (HISTORY)
+#include "../bashtypes.h"
+#if ! defined(_MINIX) && defined (HAVE_SYS_FILE_H)
+#  include <sys/file.h>
+#endif
+#include "posixstat.h"
+#include "filecntl.h"
+#include <errno.h>
+#include <stdio.h>
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../bashhist.h"
+#include <readline/history.h>
+#include "bashgetopt.h"
+#include "common.h"
+
+#if !defined (errno)
+extern int errno;
+#endif
+
+extern int current_command_line_count;
+extern int force_append_history;	/* shopt -s histappend */
+
+static char *histtime __P((HIST_ENTRY *, const char *));
+static int display_history __P((WORD_LIST *));
+static void push_history __P((WORD_LIST *));
+static int expand_and_print_history __P((WORD_LIST *));
+
+#define AFLAG	0x01
+#define RFLAG	0x02
+#define WFLAG	0x04
+#define NFLAG	0x08
+#define SFLAG	0x10
+#define PFLAG	0x20
+#define CFLAG	0x40
+#define DFLAG	0x80
+
+int
+history_builtin (list)
+     WORD_LIST *list;
+{
+  int flags, opt, result, old_history_lines, obase;
+  char *filename, *delete_arg;
+  intmax_t delete_offset;
+
+  flags = 0;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "acd:npsrw")) != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  flags |= AFLAG;
+	  break;
+	case 'c':
+	  flags |= CFLAG;
+	  break;
+	case 'n':
+	  flags |= NFLAG;
+	  break;
+	case 'r':
+	  flags |= RFLAG;
+	  break;
+	case 'w':
+	  flags |= WFLAG;
+	  break;
+	case 's':
+	  flags |= SFLAG;
+	  break;
+	case 'd':
+	  flags |= DFLAG;
+	  delete_arg = list_optarg;
+	  break;
+	case 'p':
+#if defined (BANG_HISTORY)
+	  flags |= PFLAG;
+#endif
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  opt = flags & (AFLAG|RFLAG|WFLAG|NFLAG);
+  if (opt && opt != AFLAG && opt != RFLAG && opt != WFLAG && opt != NFLAG)
+    {
+      builtin_error (_("cannot use more than one of -anrw"));
+      return (EXECUTION_FAILURE);
+    }
+
+  /* clear the history, but allow other arguments to add to it again. */
+  if (flags & CFLAG)
+    {
+      bash_clear_history ();
+      if (list == 0)
+	return (EXECUTION_SUCCESS);
+    }
+
+  if (flags & SFLAG)
+    {
+      if (list)
+	push_history (list);
+      return (EXECUTION_SUCCESS);
+    }
+#if defined (BANG_HISTORY)
+  else if (flags & PFLAG)
+    {
+      if (list)
+	return (expand_and_print_history (list));
+      return (sh_chkwrite (EXECUTION_SUCCESS));
+    }
+#endif
+  else if (flags & DFLAG)
+    {
+      if ((legal_number (delete_arg, &delete_offset) == 0)
+	  || (delete_offset < history_base)
+	  || (delete_offset > (history_base + history_length)))
+	{
+	  sh_erange (delete_arg, _("history position"));
+	  return (EXECUTION_FAILURE);
+	}
+      opt = delete_offset;
+      result = bash_delete_histent (opt - history_base);
+      /* Since remove_history changes history_length, this can happen if
+	 we delete the last history entry. */
+      if (where_history () > history_length)
+	history_set_pos (history_length);
+      return (result ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+    }
+  else if ((flags & (AFLAG|RFLAG|NFLAG|WFLAG|CFLAG)) == 0)
+    {
+      result = display_history (list);
+      return (sh_chkwrite (result));
+    }
+
+  filename = list ? list->word->word : get_string_value ("HISTFILE");
+  result = EXECUTION_SUCCESS;
+
+  if (flags & AFLAG)		/* Append session's history to file. */
+    result = maybe_append_history (filename);
+  else if (flags & WFLAG)	/* Write entire history. */
+    result = write_history (filename);
+  else if (flags & RFLAG)	/* Read entire file. */
+    result = read_history (filename);
+  else if (flags & NFLAG)	/* Read `new' history from file. */
+    {
+      /* Read all of the lines in the file that we haven't already read. */
+      old_history_lines = history_lines_in_file;
+      obase = history_base;
+
+      using_history ();
+      result = read_history_range (filename, history_lines_in_file, -1);
+      using_history ();
+
+      history_lines_in_file = where_history ();
+
+      /* If we're rewriting the history file at shell exit rather than just
+	 appending the lines from this session to it, the question is whether
+	 we reset history_lines_this_session to 0, losing any history entries
+	 we had before we read the new entries from the history file, or
+	 whether we count the new entries we just read from the file as
+	 history lines added during this session.
+	 Right now, we do the latter.  This will cause these history entries
+	 to be written to the history file along with any intermediate entries
+	 we add when we do a `history -a', but the alternative is losing
+	 them altogether. */
+      if (force_append_history == 0)
+	history_lines_this_session += history_lines_in_file - old_history_lines +
+				    history_base - obase;
+    }
+
+  return (result ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
+}
+
+/* Accessors for HIST_ENTRY lists that are called HLIST. */
+#define histline(i) (hlist[(i)]->line)
+#define histdata(i) (hlist[(i)]->data)
+
+static char *
+histtime (hlist, histtimefmt)
+     HIST_ENTRY *hlist;
+     const char *histtimefmt;
+{
+  static char timestr[128];
+  time_t t;
+
+  t = history_get_time (hlist);
+  if (t)
+    strftime (timestr, sizeof (timestr), histtimefmt, localtime (&t));
+  else
+    strcpy (timestr, "??");
+  return timestr;
+}
+
+static int
+display_history (list)
+     WORD_LIST *list;
+{
+  register int i;
+  intmax_t limit;
+  HIST_ENTRY **hlist;
+  char *histtimefmt, *timestr;
+
+  if (list)
+    {
+      if (get_numeric_arg (list, 0, &limit) == 0)
+	return (EXECUTION_FAILURE);
+
+      if (limit < 0)
+	limit = -limit;
+    }
+  else
+    limit = -1;
+
+  hlist = history_list ();
+
+  if (hlist)
+    {
+      for (i = 0;  hlist[i]; i++)
+	;
+
+      if (0 <= limit && limit < i)
+	i -= limit;
+      else
+	i = 0;
+
+      histtimefmt = get_string_value ("HISTTIMEFORMAT");
+
+      while (hlist[i])
+	{
+	  QUIT;
+
+	  timestr = (histtimefmt && *histtimefmt) ? histtime (hlist[i], histtimefmt) : (char *)NULL;
+	  printf ("%5d%c %s%s\n", i + history_base,
+		  histdata(i) ? '*' : ' ',
+		  ((timestr && *timestr) ? timestr : ""),
+		  histline(i));
+	  i++;
+	}
+    }
+
+  return (EXECUTION_SUCCESS);
+}
+
+/* Remove the last entry in the history list and add each argument in
+   LIST to the history. */
+static void
+push_history (list)
+     WORD_LIST *list;
+{
+  char *s;
+
+  /* Delete the last history entry if it was a single entry added to the
+     history list (generally the `history -s' itself), or if `history -s'
+     is being used in a compound command and the compound command was
+     added to the history as a single element (command-oriented history).
+     If you don't want history -s to remove the compound command from the
+     history, change #if 0 to #if 1 below. */
+#if 0
+  if (hist_last_line_pushed == 0 && hist_last_line_added && bash_delete_last_history () == 0)
+#else
+  if (hist_last_line_pushed == 0 &&
+	(hist_last_line_added ||
+	  (current_command_line_count > 0 && current_command_first_line_saved && command_oriented_history))
+      && bash_delete_last_history () == 0)
+#endif
+      return;
+
+  s = string_list (list);
+  /* Call check_add_history with FORCE set to 1 to skip the check against
+     current_command_line_count.  If history -s is used in a compound
+     command, the above code will delete the compound command's history
+     entry and this call will add the line to the history as a separate
+     entry.  Without FORCE=1, if current_command_line_count were > 1, the
+     line would be appended to the entry before the just-deleted entry. */
+  check_add_history (s, 1);	/* obeys HISTCONTROL, HISTIGNORE */
+
+  hist_last_line_pushed = 1;	/* XXX */
+  free (s);
+}
+
+#if defined (BANG_HISTORY)
+static int
+expand_and_print_history (list)
+     WORD_LIST *list;
+{
+  char *s;
+  int r, result;
+
+  if (hist_last_line_pushed == 0 && hist_last_line_added && bash_delete_last_history () == 0)
+    return EXECUTION_FAILURE;
+  result = EXECUTION_SUCCESS;
+  while (list)
+    {
+      r = history_expand (list->word->word, &s);
+      if (r < 0)
+	{
+	  builtin_error (_("%s: history expansion failed"), list->word->word);
+	  result = EXECUTION_FAILURE;
+	}
+      else
+	{
+	  fputs (s, stdout);
+	  putchar ('\n');
+	}
+      FREE (s);
+      list = list->next;
+    }
+  fflush (stdout);
+  return result;
+}
+#endif /* BANG_HISTORY */
+#endif /* HISTORY */
diff -Nru bash-4.0-orig/builtins/jobs.c bash-4.0/builtins/jobs.c
--- bash-4.0-orig/builtins/jobs.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/jobs.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,238 @@
+/* jobs.c, created from jobs.def. */
+#line 22 "./jobs.def"
+
+#line 48 "./jobs.def"
+
+#include <config.h>
+
+#if defined (JOB_CONTROL)
+#include "../bashtypes.h"
+#include <signal.h>
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../jobs.h"
+#include "../execute_cmd.h"
+#include "bashgetopt.h"
+#include "common.h"
+
+#define JSTATE_ANY	0x0
+#define JSTATE_RUNNING	0x1
+#define JSTATE_STOPPED	0x2
+
+static int execute_list_with_replacements __P((WORD_LIST *));
+
+/* The `jobs' command.  Prints outs a list of active jobs.  If the
+   argument `-l' is given, then the process id's are printed also.
+   If the argument `-p' is given, print the process group leader's
+   pid only.  If `-n' is given, only processes that have changed
+   status since the last notification are printed.  If -x is given,
+   replace all job specs with the pid of the appropriate process
+   group leader and execute the command.  The -r and -s options mean
+   to print info about running and stopped jobs only, respectively. */
+int
+jobs_builtin (list)
+     WORD_LIST *list;
+{
+  int form, execute, state, opt, any_failed, job;
+  sigset_t set, oset;
+
+  execute = any_failed = 0;
+  form = JLIST_STANDARD;
+  state = JSTATE_ANY;
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "lpnxrs")) != -1)
+    {
+      switch (opt)
+	{
+	case 'l':
+	  form = JLIST_LONG;
+	  break;
+	case 'p':
+	  form = JLIST_PID_ONLY;
+	  break;
+	case 'n':
+	  form = JLIST_CHANGED_ONLY;
+	  break;
+	case 'x':
+	  if (form != JLIST_STANDARD)
+	    {
+	      builtin_error (_("no other options allowed with `-x'"));
+	      return (EXECUTION_FAILURE);
+	    }
+	  execute++;
+	  break;
+	case 'r':
+	  state = JSTATE_RUNNING;
+	  break;
+	case 's':
+	  state = JSTATE_STOPPED;
+	  break;
+
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+  if (execute)
+    return (execute_list_with_replacements (list));
+
+  if (!list)
+    {
+      switch (state)
+	{
+	case JSTATE_ANY:
+	  list_all_jobs (form);
+	  break;
+	case JSTATE_RUNNING:
+	  list_running_jobs (form);
+	  break;
+	case JSTATE_STOPPED:
+	  list_stopped_jobs (form);
+	  break;
+	}
+      return (EXECUTION_SUCCESS);
+    }
+
+  while (list)
+    {
+      BLOCK_CHILD (set, oset);
+      job = get_job_spec (list);
+
+      if ((job == NO_JOB) || jobs == 0 || get_job_by_jid (job) == 0)
+	{
+	  sh_badjob (list->word->word);
+	  any_failed++;
+	}
+      else if (job != DUP_JOB)
+	list_one_job ((JOB *)NULL, form, 0, job);
+
+      UNBLOCK_CHILD (oset);
+      list = list->next;
+    }
+  return (any_failed ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
+}
+
+static int
+execute_list_with_replacements (list)
+     WORD_LIST *list;
+{
+  register WORD_LIST *l;
+  int job, result;
+  COMMAND *command;
+  JOB *j;
+
+  /* First do the replacement of job specifications with pids. */
+  for (l = list; l; l = l->next)
+    {
+      if (l->word->word[0] == '%')	/* we have a winner */
+	{
+	  job = get_job_spec (l);
+
+	  /* A bad job spec is not really a job spec! Pass it through. */
+	  if (INVALID_JOB (job))
+	    continue;
+
+	  j = get_job_by_jid (job);
+	  free (l->word->word);
+	  l->word->word = itos (j->pgrp);
+	}
+    }
+
+  /* Next make a new simple command and execute it. */
+  begin_unwind_frame ("jobs_builtin");
+
+  command = make_bare_simple_command ();
+  command->value.Simple->words = copy_word_list (list);
+  command->value.Simple->redirects = (REDIRECT *)NULL;
+  command->flags |= CMD_INHIBIT_EXPANSION;
+  command->value.Simple->flags |= CMD_INHIBIT_EXPANSION;
+
+  add_unwind_protect (dispose_command, command);
+  result = execute_command (command);
+  dispose_command (command);
+
+  discard_unwind_frame ("jobs_builtin");
+  return (result);
+}
+#endif /* JOB_CONTROL */
+
+#line 230 "./jobs.def"
+
+#if defined (JOB_CONTROL)
+int
+disown_builtin (list)
+     WORD_LIST *list;
+{
+  int opt, job, retval, nohup_only, running_jobs, all_jobs;
+  sigset_t set, oset;
+  intmax_t pid_value;
+
+  nohup_only = running_jobs = all_jobs = 0;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "ahr")) != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  all_jobs = 1;
+	  break;
+	case 'h':
+	  nohup_only = 1;
+	  break;
+	case 'r':
+	  running_jobs = 1;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+  retval = EXECUTION_SUCCESS;
+
+  /* `disown -a' or `disown -r' */
+  if (list == 0 && (all_jobs || running_jobs))
+    {
+      if (nohup_only)
+	nohup_all_jobs (running_jobs);
+      else
+	delete_all_jobs (running_jobs);
+      return (EXECUTION_SUCCESS);
+    }
+
+  do
+    {
+      BLOCK_CHILD (set, oset);
+      job = (list && legal_number (list->word->word, &pid_value) && pid_value == (pid_t) pid_value)
+		? get_job_by_pid ((pid_t) pid_value, 0)
+		: get_job_spec (list);
+
+      if (job == NO_JOB || jobs == 0 || INVALID_JOB (job))
+	{
+	  sh_badjob (list ? list->word->word : _("current"));
+	  retval = EXECUTION_FAILURE;
+	}
+      else if (nohup_only)
+	nohup_job (job);
+      else
+	delete_job (job, 1);
+      UNBLOCK_CHILD (oset);
+
+      if (list)
+	list = list->next;
+    }
+  while (list);
+
+  return (retval);
+}
+#endif /* JOB_CONTROL */
diff -Nru bash-4.0-orig/builtins/kill.c bash-4.0/builtins/kill.c
--- bash-4.0-orig/builtins/kill.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/kill.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,222 @@
+/* kill.c, created from kill.def. */
+#line 22 "./kill.def"
+
+#line 45 "./kill.def"
+
+#include <config.h>
+
+#include <stdio.h>
+#include <errno.h>
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../trap.h"
+#include "../jobs.h"
+#include "common.h"
+
+/* Not all systems declare ERRNO in errno.h... and some systems #define it! */
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+extern int posixly_correct;
+
+static void kill_error __P((pid_t, int));
+
+#if !defined (CONTINUE_AFTER_KILL_ERROR)
+#  define CONTINUE_OR_FAIL return (EXECUTION_FAILURE)
+#else
+#  define CONTINUE_OR_FAIL goto continue_killing
+#endif /* CONTINUE_AFTER_KILL_ERROR */
+
+/* Here is the kill builtin.  We only have it so that people can type
+   kill -KILL %1?  No, if you fill up the process table this way you
+   can still kill some. */
+int
+kill_builtin (list)
+     WORD_LIST *list;
+{
+  int sig, any_succeeded, listing, saw_signal, dflags;
+  char *sigspec, *word;
+  pid_t pid;
+  intmax_t pid_value;
+
+  if (list == 0)
+    {
+      builtin_usage ();
+      return (EXECUTION_FAILURE);
+    }
+
+  any_succeeded = listing = saw_signal = 0;
+  sig = SIGTERM;
+  sigspec = "TERM";
+
+  dflags = DSIG_NOCASE | ((posixly_correct == 0) ? DSIG_SIGPREFIX : 0);
+  /* Process options. */
+  while (list)
+    {
+      word = list->word->word;
+
+      if (ISOPTION (word, 'l'))
+	{
+	  listing++;
+	  list = list->next;
+	}
+      else if (ISOPTION (word, 's') || ISOPTION (word, 'n'))
+	{
+	  list = list->next;
+	  if (list)
+	    {
+	      sigspec = list->word->word;
+	      if (sigspec[0] == '0' && sigspec[1] == '\0')
+		sig = 0;
+	      else
+		sig = decode_signal (sigspec, dflags);
+	      list = list->next;
+	    }
+	  else
+	    {
+	      sh_needarg (word);
+	      return (EXECUTION_FAILURE);
+	    }
+	}
+      else if (ISOPTION (word, '-'))
+	{
+	  list = list->next;
+	  break;
+	}
+      else if (ISOPTION (word, '?'))
+	{
+	  builtin_usage ();
+	  return (EXECUTION_SUCCESS);
+	}
+      /* If this is a signal specification then process it.  We only process
+	 the first one seen; other arguments may signify process groups (e.g,
+	 -num == process group num). */
+      else if ((*word == '-') && !saw_signal)
+	{
+	  sigspec = word + 1;
+	  sig = decode_signal (sigspec, dflags);
+	  saw_signal++;
+	  list = list->next;
+	}
+      else
+	break;
+    }
+
+  if (listing)
+    return (display_signal_list (list, 0));
+
+  /* OK, we are killing processes. */
+  if (sig == NO_SIG)
+    {
+      sh_invalidsig (sigspec);
+      return (EXECUTION_FAILURE);
+    }
+
+  if (list == 0)
+    {
+      builtin_usage ();
+      return (EXECUTION_FAILURE);
+    }
+
+  while (list)
+    {
+      word = list->word->word;
+
+      if (*word == '-')
+	word++;
+
+      /* Use the entire argument in case of minus sign presence. */
+      if (*word && legal_number (list->word->word, &pid_value) && (pid_value == (pid_t)pid_value))
+	{
+	  pid = (pid_t) pid_value;
+
+	  if (kill_pid (pid, sig, pid < -1) < 0)
+	    {
+	      if (errno == EINVAL)
+		sh_invalidsig (sigspec);
+	      else
+		kill_error (pid, errno);
+	      CONTINUE_OR_FAIL;
+	    }
+	  else
+	    any_succeeded++;
+	}
+#if defined (JOB_CONTROL)
+      else if (*list->word->word && *list->word->word != '%')
+	{
+	  builtin_error (_("%s: arguments must be process or job IDs"), list->word->word);
+	  CONTINUE_OR_FAIL;
+	}
+      else if (*word)
+	/* Posix.2 says you can kill without job control active (4.32.4) */
+	{			/* Must be a job spec.  Check it out. */
+	  int job;
+	  sigset_t set, oset;
+	  JOB *j;
+
+	  BLOCK_CHILD (set, oset);
+	  job = get_job_spec (list);
+
+	  if (INVALID_JOB (job))
+	    {
+	      if (job != DUP_JOB)
+		sh_badjob (list->word->word);
+	      UNBLOCK_CHILD (oset);
+	      CONTINUE_OR_FAIL;
+	    }
+
+	  j = get_job_by_jid (job);
+	  /* Job spec used.  Kill the process group. If the job was started
+	     without job control, then its pgrp == shell_pgrp, so we have
+	     to be careful.  We take the pid of the first job in the pipeline
+	     in that case. */
+	  pid = IS_JOBCONTROL (job) ? j->pgrp : j->pipe->pid;
+
+	  UNBLOCK_CHILD (oset);
+
+	  if (kill_pid (pid, sig, 1) < 0)
+	    {
+	      if (errno == EINVAL)
+		sh_invalidsig (sigspec);
+	      else
+		kill_error (pid, errno);
+	      CONTINUE_OR_FAIL;
+	    }
+	  else
+	    any_succeeded++;
+	}
+#endif /* !JOB_CONTROL */
+      else
+	{
+	  sh_badpid (list->word->word);
+	  CONTINUE_OR_FAIL;
+	}
+    continue_killing:
+      list = list->next;
+    }
+
+  return (any_succeeded ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+}
+
+static void
+kill_error (pid, e)
+     pid_t pid;
+     int e;
+{
+  char *x;
+
+  x = strerror (e);
+  if (x == 0)
+    x = _("Unknown error");
+  builtin_error ("(%ld) - %s", (long)pid, x);
+}
diff -Nru bash-4.0-orig/builtins/let.c bash-4.0/builtins/let.c
--- bash-4.0-orig/builtins/let.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/let.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,66 @@
+/* let.c, created from let.def. */
+#line 66 "./let.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+
+/* Arithmetic LET function. */
+int
+let_builtin (list)
+     WORD_LIST *list;
+{
+  intmax_t ret;
+  int expok;
+
+  /* Skip over leading `--' argument. */
+  if (list && list->word && ISOPTION (list->word->word, '-'))
+    list = list->next;
+
+  if (list == 0)
+    {
+      builtin_error (_("expression expected"));
+      return (EXECUTION_FAILURE);
+    }
+
+  for (; list; list = list->next)
+    {
+      ret = evalexp (list->word->word, &expok);
+      if (expok == 0)
+	return (EXECUTION_FAILURE);
+    }
+
+  return ((ret == 0) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
+}
+
+#ifdef INCLUDE_UNUSED
+int
+exp_builtin (list)
+     WORD_LIST *list;
+{
+  char *exp;
+  intmax_t ret;
+  int expok;
+
+  if (list == 0)
+    {
+      builtin_error (_("expression expected"));
+      return (EXECUTION_FAILURE);
+    }
+
+  exp = string_list (list);
+  ret = evalexp (exp, &expok);
+  (void)free (exp);
+  return (((ret == 0) || (expok == 0)) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
+}
+#endif
diff -Nru bash-4.0-orig/builtins/mapfile.c bash-4.0/builtins/mapfile.c
--- bash-4.0-orig/builtins/mapfile.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/mapfile.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,287 @@
+/* mapfile.c, created from mapfile.def. */
+#line 23 "./mapfile.def"
+
+#line 55 "./mapfile.def"
+
+#line 63 "./mapfile.def"
+
+#include <config.h>
+
+#include "builtins.h"
+#include "posixstat.h"
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "bashansi.h"
+
+#include <stdio.h>
+#include <errno.h>
+
+#include "../bashintl.h"
+#include "../shell.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#if !defined (errno)
+extern int errno;
+#endif
+
+#if defined (ARRAY_VARS)
+
+#define DEFAULT_ARRAY_NAME	"MAPFILE"
+
+/* The value specifying how frequently `mapfile'  calls the callback. */
+#define DEFAULT_QUANTUM 5000
+
+/* Values for FLAGS */
+#define MAPF_CLEARARRAY	0x01
+#define MAPF_CHOP	0x02
+
+static int
+run_callback(callback, current_index)
+     const char *callback;
+     unsigned int current_index;
+{
+  unsigned int execlen;
+  char  *execstr;
+  int flags;
+
+  execlen = strlen (callback) + 10;
+  /* 1 for space between %s and %d,
+     another 1 for the last nul char for C string. */
+  execlen += 2;
+  execstr = xmalloc (execlen);
+
+  flags = 0;
+#if 0
+  if (interactive)
+    flags |= SEVAL_NOHIST|SEVAL_INTERACT;
+#endif
+  snprintf (execstr, execlen, "%s %d", callback, current_index);
+  return parse_and_execute(execstr, NULL, flags);
+}
+
+static void
+do_chop(line)
+     char * line;
+{
+  int length;
+
+  length = strlen (line);
+  if (length && line[length-1] == '\n') 
+    line[length-1] = '\0';
+}
+
+static int
+mapfile (fd, line_count_goal, origin, nskip, callback_quantum, callback, array_name, flags)
+     int fd;
+     long line_count_goal, origin, nskip, callback_quantum;
+     char *callback, *array_name;
+     int flags;
+{
+  char *line;
+  size_t line_length;
+  unsigned int array_index, line_count;
+  SHELL_VAR *entry;
+  int unbuffered_read;
+  
+  line = NULL;
+  line_length = 0;
+  unbuffered_read = 0;
+
+  /* The following check should be done before reading any lines.  Doing it
+     here allows us to call bind_array_element instead of bind_array_variable
+     and skip the variable lookup on every call. */
+  entry = find_or_make_array_variable (array_name, 1);
+  if (entry == 0 || readonly_p (entry) || noassign_p (entry))
+    {
+      if (readonly_p (entry))
+	err_readonly (array_name);
+	
+      return (EXECUTION_FAILURE);
+    }
+  if (flags & MAPF_CLEARARRAY)
+    array_flush (array_cell (entry));
+
+#ifndef __CYGWIN__
+  unbuffered_read = (lseek (fd, 0L, SEEK_CUR) < 0) && (errno == ESPIPE);
+#else
+  unbuffered_read = 1;
+#endif
+
+  zreset ();
+
+  /* Skip any lines at beginning of file? */
+  for (line_count = 0; line_count < nskip; line_count++)
+    if (zgetline (fd, &line, &line_length, unbuffered_read) < 0)
+      break;
+
+  line = 0;
+  line_length = 0;    
+
+  /* Reset the buffer for bash own stream */
+  interrupt_immediately++;
+  for (array_index = origin, line_count = 1; 
+       zgetline (fd, &line, &line_length, unbuffered_read) != -1;
+       array_index++, line_count++) 
+    {
+      /* Have we exceeded # of lines to store? */
+      if (line_count_goal != 0 && line_count > line_count_goal) 
+	break;
+
+      /* Remove trailing newlines? */
+      if (flags & MAPF_CHOP)
+	do_chop (line);
+	  
+      /* Has a callback been registered and if so is it time to call it? */
+      if (callback && line_count && (line_count % callback_quantum) == 0) 
+	{
+	  run_callback (callback, array_index);
+
+	  /* Reset the buffer for bash own stream. */
+	  if (unbuffered_read == 0)
+	    zsyncfd (fd);
+	}
+
+      bind_array_element (entry, array_index, line, 0);
+    }
+
+  xfree (line);
+
+  if (unbuffered_read == 0)
+    zsyncfd (fd);
+
+  interrupt_immediately--;
+  return EXECUTION_SUCCESS;
+}
+
+int
+mapfile_builtin (list)
+     WORD_LIST *list;
+{
+  int opt, code, fd, clear_array, flags;
+  intmax_t intval;
+  long lines, origin, nskip, callback_quantum;
+  char *array_name, *callback;
+
+  clear_array = 1;
+  fd = 0;
+  lines = origin = nskip = 0;
+  flags = MAPF_CLEARARRAY;
+  callback_quantum = DEFAULT_QUANTUM;
+  callback = 0;
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "u:n:O:tC:c:s:")) != -1)
+    {
+      switch (opt)
+	{
+	case 'u':
+	  code = legal_number (list_optarg, &intval);
+	  if (code == 0 || intval < 0 || intval != (int)intval)
+	    {
+	      builtin_error (_("%s: invalid file descriptor specification"), list_optarg);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else
+	    fd = intval;
+
+	  if (sh_validfd (fd) == 0)
+	    {
+	      builtin_error (_("%d: invalid file descriptor: %s"), fd, strerror (errno));
+	      return (EXECUTION_FAILURE);
+	    }
+	  break;	  
+
+	case 'n':
+	  code = legal_number (list_optarg, &intval);
+	  if (code == 0 || intval < 0 || intval != (unsigned)intval)
+	    {
+	      builtin_error (_("%s: invalid line count"), list_optarg);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else
+	    lines = intval;
+	  break;
+
+	case 'O':
+	  code = legal_number (list_optarg, &intval);
+	  if (code == 0 || intval < 0 || intval != (unsigned)intval)
+	    {
+	      builtin_error (_("%s: invalid array origin"), list_optarg);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else
+	    origin = intval;
+	  flags &= ~MAPF_CLEARARRAY;
+	  break;
+	case 't':
+	  flags |= MAPF_CHOP;
+	  break;
+	case 'C':
+	  callback = list_optarg;
+	  break;
+	case 'c':
+	  code = legal_number (list_optarg, &intval);
+	  if (code == 0 || intval < 0 || intval != (unsigned)intval)
+	    {
+	      builtin_error (_("%s: invalid callback quantum"), list_optarg);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else
+	    callback_quantum = intval;
+	  break;
+	case 's':
+	  code = legal_number (list_optarg, &intval);
+	  if (code == 0 || intval < 0 || intval != (unsigned)intval)
+	    {
+	      builtin_error (_("%s: invalid line count"), list_optarg);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else
+	    nskip = intval;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  if (list == 0) 
+    array_name = DEFAULT_ARRAY_NAME;
+  else if (list->word == 0 || list->word->word == 0)
+    {
+      builtin_error ("internal error: getting variable name");
+      return (EXECUTION_FAILURE);
+    }
+  else if (list->word->word[0] == '\0')
+    {
+      builtin_error (_("empty array variable name"));
+      return (EX_USAGE);
+    } 
+  else
+    array_name = list->word->word;
+  
+  if (legal_identifier (array_name) == 0 && valid_array_reference (array_name) == 0)
+    {
+      sh_invalidid (array_name);
+      return (EXECUTION_FAILURE);
+    }
+
+  return mapfile (fd, lines, origin, nskip, callback_quantum, callback, array_name, flags);
+}
+
+#else
+
+int
+mapfile_builtin (list)
+     WORD_LIST *list;
+{
+  builtin_error (_("array variable support required"));
+  return (EXECUTION_FAILURE);
+}
+
+#endif  /* ARRAY_VARS */
diff -Nru bash-4.0-orig/builtins/pipesize.h bash-4.0/builtins/pipesize.h
--- bash-4.0-orig/builtins/pipesize.h	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/pipesize.h	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,8 @@
+/*
+ * pipesize.h
+ *
+ * This file is automatically generated by psize.sh
+ * Do not edit!
+ */
+
+#define PIPESIZE 65536
diff -Nru bash-4.0-orig/builtins/printf.c bash-4.0/builtins/printf.c
--- bash-4.0-orig/builtins/printf.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/printf.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,1050 @@
+/* printf.c, created from printf.def. */
+#line 22 "./printf.def"
+
+#line 48 "./printf.def"
+
+#include <config.h>
+
+#include "../bashtypes.h"
+
+#include <errno.h>
+#if defined (HAVE_LIMITS_H)
+#  include <limits.h>
+#else
+   /* Assume 32-bit ints. */
+#  define INT_MAX		2147483647
+#  define INT_MIN		(-2147483647-1)
+#endif
+
+#if defined (PREFER_STDARG)
+#  include <stdarg.h>
+#else
+#  include <varargs.h>
+#endif
+
+#include <stdio.h>
+#include <chartypes.h>
+
+#ifdef HAVE_INTTYPES_H
+#  include <inttypes.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "shmbutil.h"
+#include "stdc.h"
+#include "bashgetopt.h"
+#include "common.h"
+
+#if defined (PRI_MACROS_BROKEN)
+#  undef PRIdMAX
+#endif
+
+#if !defined (PRIdMAX)
+#  if HAVE_LONG_LONG
+#    define PRIdMAX	"lld"
+#  else
+#    define PRIdMAX	"ld"
+#  endif
+#endif
+
+#if !defined (errno)
+extern int errno;
+#endif
+
+#define PC(c) \
+  do { \
+    char b[2]; \
+    tw++; \
+    b[0] = c; b[1] = '\0'; \
+    if (vflag) \
+      vbadd (b, 1); \
+    else \
+      putchar (c); \
+  } while (0)
+
+#define PF(f, func) \
+  do { \
+    int nw; \
+    clearerr (stdout); \
+    if (have_fieldwidth && have_precision) \
+      nw = vflag ? vbprintf (f, fieldwidth, precision, func) : printf (f, fieldwidth, precision, func); \
+    else if (have_fieldwidth) \
+      nw = vflag ? vbprintf (f, fieldwidth, func) : printf (f, fieldwidth, func); \
+    else if (have_precision) \
+      nw = vflag ? vbprintf (f, precision, func) : printf (f, fieldwidth, func); \
+    else \
+      nw = vflag ? vbprintf (f, func) : printf (f, func); \
+    tw += nw; \
+    if (ferror (stdout)) \
+      { \
+	sh_wrerror (); \
+	clearerr (stdout); \
+	return (EXECUTION_FAILURE); \
+      } \
+  } while (0)
+
+/* We free the buffer used by mklong() if it's `too big'. */
+#define PRETURN(value) \
+  do \
+    { \
+      if (vflag) \
+	{ \
+	  bind_variable  (vname, vbuf, 0); \
+	  stupidly_hack_special_variables (vname); \
+	} \
+      if (conv_bufsize > 4096 ) \
+	{ \
+	  free (conv_buf); \
+	  conv_bufsize = 0; \
+	  conv_buf = 0; \
+	} \
+      if (vbsize > 4096) \
+	{ \
+	  free (vbuf); \
+	  vbsize = 0; \
+	  vbuf = 0; \
+	} \
+      else if (vbuf) \
+	vbuf[0] = 0; \
+      terminate_immediately--; \
+      fflush (stdout); \
+      if (ferror (stdout)) \
+	{ \
+	  clearerr (stdout); \
+	  return (EXECUTION_FAILURE); \
+	} \
+      return (value); \
+    } \
+  while (0)
+
+#define SKIP1 "#'-+ 0"
+#define LENMODS "hjlLtz"
+
+#ifndef HAVE_ASPRINTF
+extern int asprintf __P((char **, const char *, ...)) __attribute__((__format__ (printf, 2, 3)));
+#endif
+
+#ifndef HAVE_VSNPRINTF
+extern int vsnprintf __P((char *, size_t, const char *, ...)) __attribute__((__format__ (printf, 3, 4)));
+#endif
+
+static void printf_erange __P((char *));
+static int printstr __P((char *, char *, int, int, int));
+static int tescape __P((char *, char *, int *));
+static char *bexpand __P((char *, int, int *, int *));
+static char *vbadd __P((char *, int));
+static int vbprintf __P((const char *, ...)) __attribute__((__format__ (printf, 1, 2)));
+static char *mklong __P((char *, char *, size_t));
+static int getchr __P((void));
+static char *getstr __P((void));
+static int  getint __P((void));
+static intmax_t getintmax __P((void));
+static uintmax_t getuintmax __P((void));
+
+#if defined (HAVE_LONG_DOUBLE) && HAVE_DECL_STRTOLD && !defined(STRTOLD_BROKEN)
+typedef long double floatmax_t;
+#  define FLOATMAX_CONV	"L"
+#  define strtofltmax	strtold
+#else
+typedef double floatmax_t;
+#  define FLOATMAX_CONV	""
+#  define strtofltmax	strtod
+#endif
+static floatmax_t getfloatmax __P((void));
+
+static intmax_t asciicode __P((void));
+
+static WORD_LIST *garglist;
+static int retval;
+static int conversion_error;
+
+/* printf -v var support */
+static int vflag = 0;
+static char *vbuf, *vname;
+static size_t vbsize;
+static int vblen;
+
+static intmax_t tw;
+
+static char *conv_buf;
+static size_t conv_bufsize;
+
+int
+printf_builtin (list)
+     WORD_LIST *list;
+{
+  int ch, fieldwidth, precision;
+  int have_fieldwidth, have_precision;
+  char convch, thisch, nextch, *format, *modstart, *fmt, *start;
+
+  conversion_error = 0;
+  retval = EXECUTION_SUCCESS;
+
+  vflag = 0;
+
+  reset_internal_getopt ();
+  while ((ch = internal_getopt (list, "v:")) != -1)
+    {
+      switch (ch)
+	{
+	case 'v':
+	  if (legal_identifier (vname = list_optarg))
+	    {
+	      vflag = 1;
+	      vblen = 0;
+	      if (vbuf)
+		vbuf[0] = 0;
+	    }
+	  else
+	    {
+	      sh_invalidid (vname);
+	      return (EX_USAGE);
+	    }
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;	/* skip over possible `--' */
+
+  if (list == 0)
+    {
+      builtin_usage ();
+      return (EX_USAGE);
+    }
+
+  if (list->word->word == 0 || list->word->word[0] == '\0')
+    return (EXECUTION_SUCCESS);
+
+  format = list->word->word;
+  tw = 0;
+
+  garglist = list->next;
+
+  /* If the format string is empty after preprocessing, return immediately. */
+  if (format == 0 || *format == 0)
+    return (EXECUTION_SUCCESS);
+
+  terminate_immediately++;
+	  
+  /* Basic algorithm is to scan the format string for conversion
+     specifications -- once one is found, find out if the field
+     width or precision is a '*'; if it is, gather up value.  Note,
+     format strings are reused as necessary to use up the provided
+     arguments, arguments of zero/null string are provided to use
+     up the format string. */
+  do
+    {
+      tw = 0;
+      /* find next format specification */
+      for (fmt = format; *fmt; fmt++)
+	{
+	  precision = fieldwidth = 0;
+	  have_fieldwidth = have_precision = 0;
+
+	  if (*fmt == '\\')
+	    {
+	      fmt++;
+	      /* A NULL third argument to tescape means to bypass the
+		 special processing for arguments to %b. */
+	      fmt += tescape (fmt, &nextch, (int *)NULL);
+	      PC (nextch);
+	      fmt--;	/* for loop will increment it for us again */
+	      continue;
+	    }
+
+	  if (*fmt != '%')
+	    {
+	      PC (*fmt);
+	      continue;
+	    }
+
+	  /* ASSERT(*fmt == '%') */
+	  start = fmt++;
+
+	  if (*fmt == '%')		/* %% prints a % */
+	    {
+	      PC ('%');
+	      continue;
+	    }
+
+	  /* found format specification, skip to field width */
+	  for (; *fmt && strchr(SKIP1, *fmt); ++fmt)
+	    ;
+
+	  /* Skip optional field width. */
+	  if (*fmt == '*')
+	    {
+	      fmt++;
+	      have_fieldwidth = 1;
+	      fieldwidth = getint ();
+	    }
+	  else
+	    while (DIGIT (*fmt))
+	      fmt++;
+
+	  /* Skip optional '.' and precision */
+	  if (*fmt == '.')
+	    {
+	      ++fmt;
+	      if (*fmt == '*')
+		{
+		  fmt++;
+		  have_precision = 1;
+		  precision = getint ();
+		}
+	      else
+		{
+		  /* Negative precisions are allowed but treated as if the
+		     precision were missing; I would like to allow a leading
+		     `+' in the precision number as an extension, but lots
+		     of asprintf/fprintf implementations get this wrong. */
+#if 0
+		  if (*fmt == '-' || *fmt == '+')
+#else
+		  if (*fmt == '-')
+#endif
+		    fmt++;
+		  while (DIGIT (*fmt))
+		    fmt++;
+		}
+	    }
+
+	  /* skip possible format modifiers */
+	  modstart = fmt;
+	  while (*fmt && strchr (LENMODS, *fmt))
+	    fmt++;
+	    
+	  if (*fmt == 0)
+	    {
+	      builtin_error (_("`%s': missing format character"), start);
+	      PRETURN (EXECUTION_FAILURE);
+	    }
+
+	  convch = *fmt;
+	  thisch = modstart[0];
+	  nextch = modstart[1];
+	  modstart[0] = convch;
+	  modstart[1] = '\0';
+
+	  switch(convch)
+	    {
+	    case 'c':
+	      {
+		char p;
+
+		p = getchr ();
+		PF(start, p);
+		break;
+	      }
+
+	    case 's':
+	      {
+		char *p;
+
+		p = getstr ();
+		PF(start, p);
+		break;
+	      }
+
+	    case 'n':
+	      {
+		char *var;
+
+		var = getstr ();
+		if (var && *var)
+		  {
+		    if (legal_identifier (var))
+		      bind_var_to_int (var, tw);
+		    else
+		      {
+			sh_invalidid (var);
+			PRETURN (EXECUTION_FAILURE);
+		      }
+		  }
+		break;
+	      }
+
+	    case 'b':		/* expand escapes in argument */
+	      {
+		char *p, *xp;
+		int rlen, r;
+
+		p = getstr ();
+		ch = rlen = r = 0;
+		xp = bexpand (p, strlen (p), &ch, &rlen);
+
+		if (xp)
+		  {
+		    /* Have to use printstr because of possible NUL bytes
+		       in XP -- printf does not handle that well. */
+		    r = printstr (start, xp, rlen, fieldwidth, precision);
+		    if (r < 0)
+		      {
+		        sh_wrerror ();
+			clearerr (stdout);
+		        retval = EXECUTION_FAILURE;
+		      }
+		    free (xp);
+		  }
+
+		if (ch || r < 0)
+		  PRETURN (retval);
+		break;
+	      }
+
+	    case 'q':		/* print with shell quoting */
+	      {
+		char *p, *xp;
+		int r;
+
+		r = 0;
+		p = getstr ();
+		if (p && *p == 0)	/* XXX - getstr never returns null */
+		  xp = savestring ("''");
+		else if (ansic_shouldquote (p))
+		  xp = ansic_quote (p, 0, (int *)0);
+		else
+		  xp = sh_backslash_quote (p);
+		if (xp)
+		  {
+		    /* Use printstr to get fieldwidth and precision right. */
+		    r = printstr (start, xp, strlen (xp), fieldwidth, precision);
+		    if (r < 0)
+		      {
+			sh_wrerror ();
+			clearerr (stdout);
+		      }
+		    free (xp);
+		  }
+
+		if (r < 0)
+		  PRETURN (EXECUTION_FAILURE);
+		break;
+	      }
+
+	    case 'd':
+	    case 'i':
+	      {
+		char *f;
+		long p;
+		intmax_t pp;
+
+		p = pp = getintmax ();
+		if (p != pp)
+		  {
+		    f = mklong (start, PRIdMAX, sizeof (PRIdMAX) - 2);
+		    PF (f, pp);
+		  }
+		else
+		  {
+		    /* Optimize the common case where the integer fits
+		       in "long".  This also works around some long
+		       long and/or intmax_t library bugs in the common
+		       case, e.g. glibc 2.2 x86.  */
+		    f = mklong (start, "l", 1);
+		    PF (f, p);
+		  }
+		break;
+	      }
+
+	    case 'o':
+	    case 'u':
+	    case 'x':
+	    case 'X':
+	      {
+		char *f;
+		unsigned long p;
+		uintmax_t pp;
+
+		p = pp = getuintmax ();
+		if (p != pp)
+		  {
+		    f = mklong (start, PRIdMAX, sizeof (PRIdMAX) - 2);
+		    PF (f, pp);
+		  }
+		else
+		  {
+		    f = mklong (start, "l", 1);
+		    PF (f, p);
+		  }
+		break;
+	      }
+
+	    case 'e':
+	    case 'E':
+	    case 'f':
+	    case 'F':
+	    case 'g':
+	    case 'G':
+#if defined (HAVE_PRINTF_A_FORMAT)
+	    case 'a':
+	    case 'A':
+#endif
+	      {
+		char *f;
+		floatmax_t p;
+
+		p = getfloatmax ();
+		f = mklong (start, FLOATMAX_CONV, sizeof(FLOATMAX_CONV) - 1);
+		PF (f, p);
+		break;
+	      }
+
+	    /* We don't output unrecognized format characters; we print an
+	       error message and return a failure exit status. */
+	    default:
+	      builtin_error (_("`%c': invalid format character"), convch);
+	      PRETURN (EXECUTION_FAILURE);
+	    }
+
+	  modstart[0] = thisch;
+	  modstart[1] = nextch;
+	}
+
+      if (ferror (stdout))
+	{
+	  sh_wrerror ();
+	  clearerr (stdout);
+	  PRETURN (EXECUTION_FAILURE);
+	}
+    }
+  while (garglist && garglist != list->next);
+
+  if (conversion_error)
+    retval = EXECUTION_FAILURE;
+
+  PRETURN (retval);
+}
+
+static void
+printf_erange (s)
+     char *s;
+{
+  builtin_error (_("warning: %s: %s"), s, strerror(ERANGE));
+}
+
+/* We duplicate a lot of what printf(3) does here. */
+static int
+printstr (fmt, string, len, fieldwidth, precision)
+     char *fmt;			/* format */
+     char *string;		/* expanded string argument */
+     int len;			/* length of expanded string */
+     int fieldwidth;		/* argument for width of `*' */
+     int precision;		/* argument for precision of `*' */
+{
+#if 0
+  char *s;
+#endif
+  int padlen, nc, ljust, i;
+  int fw, pr;			/* fieldwidth and precision */
+
+#if 0
+  if (string == 0 || *string == '\0')
+#else
+  if (string == 0 || len == 0)
+#endif
+    return 0;
+
+#if 0
+  s = fmt;
+#endif
+  if (*fmt == '%')
+    fmt++;
+
+  ljust = fw = 0;
+  pr = -1;
+
+  /* skip flags */
+  while (strchr (SKIP1, *fmt))
+    {
+      if (*fmt == '-')
+	ljust = 1;
+      fmt++;
+    }
+
+  /* get fieldwidth, if present */
+  if (*fmt == '*')
+    {
+      fmt++;
+      fw = fieldwidth;
+      if (fw < 0)
+	{
+	  fw = -fw;
+	  ljust = 1;
+	}
+    }
+  else if (DIGIT (*fmt))
+    {
+      fw = *fmt++ - '0';
+      while (DIGIT (*fmt))
+	fw = (fw * 10) + (*fmt++ - '0');
+    }
+
+  /* get precision, if present */
+  if (*fmt == '.')
+    {
+      fmt++;
+      if (*fmt == '*')
+	{
+	  fmt++;
+	  pr = precision;
+	}
+      else if (DIGIT (*fmt))
+	{
+	  pr = *fmt++ - '0';
+	  while (DIGIT (*fmt))
+	    pr = (pr * 10) + (*fmt++ - '0');
+	}
+    }
+
+#if 0
+  /* If we remove this, get rid of `s'. */
+  if (*fmt != 'b' && *fmt != 'q')
+    {
+      internal_error ("format parsing problem: %s", s);
+      fw = pr = 0;
+    }
+#endif
+
+  /* chars from string to print */
+  nc = (pr >= 0 && pr <= len) ? pr : len;
+
+  padlen = fw - nc;
+  if (padlen < 0)
+    padlen = 0;
+  if (ljust)
+    padlen = -padlen;
+
+  /* leading pad characters */
+  for (; padlen > 0; padlen--)
+    PC (' ');
+
+  /* output NC characters from STRING */
+  for (i = 0; i < nc; i++)
+    PC (string[i]);
+
+  /* output any necessary trailing padding */
+  for (; padlen < 0; padlen++)
+    PC (' ');
+
+  return (ferror (stdout) ? -1 : 0);
+}
+  
+/* Convert STRING by expanding the escape sequences specified by the
+   POSIX standard for printf's `%b' format string.  If SAWC is non-null,
+   perform the processing appropriate for %b arguments.  In particular,
+   recognize `\c' and use that as a string terminator.  If we see \c, set
+   *SAWC to 1 before returning.  LEN is the length of STRING. */
+
+/* Translate a single backslash-escape sequence starting at ESTART (the
+   character after the backslash) and return the number of characters
+   consumed by the sequence.  CP is the place to return the translated
+   value.  *SAWC is set to 1 if the escape sequence was \c, since that means
+   to short-circuit the rest of the processing.  If SAWC is null, we don't
+   do the \c short-circuiting, and \c is treated as an unrecognized escape
+   sequence; we also bypass the other processing specific to %b arguments.  */
+static int
+tescape (estart, cp, sawc)
+     char *estart;
+     char *cp;
+     int *sawc;
+{
+  register char *p;
+  int temp, c, evalue;
+
+  p = estart;
+
+  switch (c = *p++)
+    {
+#if defined (__STDC__)
+      case 'a': *cp = '\a'; break;
+#else
+      case 'a': *cp = '\007'; break;
+#endif
+
+      case 'b': *cp = '\b'; break;
+
+      case 'e':
+      case 'E': *cp = '\033'; break;	/* ESC -- non-ANSI */
+
+      case 'f': *cp = '\f'; break;
+
+      case 'n': *cp = '\n'; break;
+
+      case 'r': *cp = '\r'; break;
+
+      case 't': *cp = '\t'; break;
+
+      case 'v': *cp = '\v'; break;
+
+      /* The octal escape sequences are `\0' followed by up to three octal
+	 digits (if SAWC), or `\' followed by up to three octal digits (if
+	 !SAWC).  As an extension, we allow the latter form even if SAWC. */
+      case '0': case '1': case '2': case '3':
+      case '4': case '5': case '6': case '7':
+	evalue = OCTVALUE (c);
+	for (temp = 2 + (!evalue && !!sawc); ISOCTAL (*p) && temp--; p++)
+	  evalue = (evalue * 8) + OCTVALUE (*p);
+	*cp = evalue & 0xFF;
+	break;
+
+      /* And, as another extension, we allow \xNNN, where each N is a
+	 hex digit. */
+      case 'x':
+#if 0
+	for (evalue = 0; ISXDIGIT ((unsigned char)*p); p++)
+#else
+	for (temp = 2, evalue = 0; ISXDIGIT ((unsigned char)*p) && temp--; p++)
+#endif
+	  evalue = (evalue * 16) + HEXVALUE (*p);
+	if (p == estart + 1)
+	  {
+	    builtin_error (_("missing hex digit for \\x"));
+	    *cp = '\\';
+	    return 0;
+	  }
+	*cp = evalue & 0xFF;
+	break;
+
+      case '\\':	/* \\ -> \ */
+	*cp = c;
+	break;
+
+      /* SAWC == 0 means that \', \", and \? are recognized as escape
+	 sequences, though the only processing performed is backslash
+	 removal. */
+      case '\'': case '"': case '?':
+	if (!sawc)
+	  *cp = c;
+	else
+	  {
+	    *cp = '\\';
+	    return 0;
+	  }
+	break;
+
+      case 'c':
+	if (sawc)
+	  {
+	    *sawc = 1;
+	    break;
+	  }
+      /* other backslash escapes are passed through unaltered */
+      default:
+	*cp = '\\';
+	return 0;
+      }
+  return (p - estart);
+}
+
+static char *
+bexpand (string, len, sawc, lenp)
+     char *string;
+     int len, *sawc, *lenp;
+{
+  int temp;
+  char *ret, *r, *s, c;
+
+#if 0
+  if (string == 0 || *string == '\0')
+#else
+  if (string == 0 || len == 0)
+#endif
+    {
+      if (sawc)
+	*sawc = 0;
+      if (lenp)
+	*lenp = 0;
+      return ((char *)NULL);
+    }
+
+  ret = (char *)xmalloc (len + 1);
+  for (r = ret, s = string; s && *s; )
+    {
+      c = *s++;
+      if (c != '\\' || *s == '\0')
+	{
+	  *r++ = c;
+	  continue;
+	}
+      temp = 0;
+      s += tescape (s, &c, &temp);
+      if (temp)
+	{
+	  if (sawc)
+	    *sawc = 1;
+	  break;
+	}
+
+      *r++ = c;
+    }
+
+  *r = '\0';
+  if (lenp)
+    *lenp = r - ret;
+  return ret;
+}
+
+static char *
+vbadd (buf, blen)
+     char *buf;
+     int blen;
+{
+  size_t nlen;
+
+  nlen = vblen + blen + 1;
+  if (nlen >= vbsize)
+    {
+      vbsize = ((nlen + 63) >> 6) << 6;
+      vbuf = (char *)xrealloc (vbuf, vbsize);
+    }
+
+  if (blen == 1)
+    vbuf[vblen++] = buf[0];
+  else if (blen > 1)
+    {
+      FASTCOPY (buf, vbuf  + vblen, blen);
+      vblen += blen;
+    }
+  vbuf[vblen] = '\0';
+
+#ifdef DEBUG
+  if  (strlen (vbuf) != vblen)
+    internal_error  ("printf:vbadd: vblen (%d) != strlen (vbuf) (%d)", vblen, (int)strlen (vbuf));
+#endif
+
+  return vbuf;
+}
+
+static int
+#if defined (PREFER_STDARG)
+vbprintf (const char *format, ...)
+#else
+vbprintf (format, va_alist)
+  const char *format;
+  va_dcl
+#endif
+{
+  va_list args;
+  size_t nlen;
+  int blen;
+
+  SH_VA_START (args, format);
+  blen = vsnprintf (vbuf + vblen, vbsize - vblen, format, args);
+  va_end (args);
+
+  nlen = vblen + blen + 1;
+  if (nlen >= vbsize)
+    {
+      vbsize = ((nlen + 63) >> 6) << 6;
+      vbuf = (char *)xrealloc (vbuf, vbsize);
+      SH_VA_START (args, format);
+      blen = vsnprintf (vbuf + vblen, vbsize - vblen, format, args);
+      va_end (args);
+    }
+
+  vblen += blen;
+  vbuf[vblen] = '\0';
+
+#ifdef DEBUG
+  if  (strlen (vbuf) != vblen)
+    internal_error  ("printf:vbadd: vblen (%d) != strlen (vbuf) (%d)", vblen, (int)strlen (vbuf));
+#endif
+  
+  return (blen);
+}
+
+static char *
+mklong (str, modifiers, mlen)
+     char *str;
+     char *modifiers;
+     size_t mlen;
+{
+  size_t len, slen;
+
+  slen = strlen (str);
+  len = slen + mlen + 1;
+
+  if (len > conv_bufsize)
+    {
+      conv_bufsize = (((len + 1023) >> 10) << 10);
+      conv_buf = (char *)xrealloc (conv_buf, conv_bufsize);
+    }
+
+  FASTCOPY (str, conv_buf, slen - 1);
+  FASTCOPY (modifiers, conv_buf + slen - 1, mlen);
+
+  conv_buf[len - 2] = str[slen - 1];
+  conv_buf[len - 1] = '\0';
+  return (conv_buf);
+}
+
+static int
+getchr ()
+{
+  int ret;
+
+  if (garglist == 0)
+    return ('\0');
+
+  ret = (int)garglist->word->word[0];
+  garglist = garglist->next;
+  return ret;
+}
+
+static char *
+getstr ()
+{
+  char *ret;
+
+  if (garglist == 0)
+    return ("");
+
+  ret = garglist->word->word;
+  garglist = garglist->next;
+  return ret;
+}
+
+static int
+getint ()
+{
+  intmax_t ret;
+
+  ret = getintmax ();
+
+  if (ret > INT_MAX)
+    {
+      printf_erange (garglist->word->word);
+      ret = INT_MAX;
+    }
+  else if (ret < INT_MIN)
+    {
+      printf_erange (garglist->word->word);
+      ret = INT_MIN;
+    }
+
+  return ((int)ret);
+}
+
+static intmax_t
+getintmax ()
+{
+  intmax_t ret;
+  char *ep;
+
+  if (garglist == 0)
+    return (0);
+
+  if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+    return asciicode ();
+
+  errno = 0;
+  ret = strtoimax (garglist->word->word, &ep, 0);
+
+  if (*ep)
+    {
+      sh_invalidnum (garglist->word->word);
+      /* POSIX.2 says ``...a diagnostic message shall be written to standard
+	 error, and the utility shall not exit with a zero exit status, but
+	 shall continue processing any remaining operands and shall write the
+         value accumulated at the time the error was detected to standard
+	 output.''  Yecch. */
+      ret = 0;
+      conversion_error = 1;
+    }
+  else if (errno == ERANGE)
+    printf_erange (garglist->word->word);
+
+  garglist = garglist->next;
+  return (ret);
+}
+
+static uintmax_t
+getuintmax ()
+{
+  uintmax_t ret;
+  char *ep;
+
+  if (garglist == 0)
+    return (0);
+
+  if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+    return asciicode ();
+
+  errno = 0;
+  ret = strtoumax (garglist->word->word, &ep, 0);
+  
+  if (*ep)
+    {
+      sh_invalidnum (garglist->word->word);
+      /* Same POSIX.2 conversion error requirements as getintmax(). */
+      ret = 0;
+      conversion_error = 1;
+    }
+  else if (errno == ERANGE)
+    printf_erange (garglist->word->word);
+
+  garglist = garglist->next;
+  return (ret);
+}
+
+static floatmax_t
+getfloatmax ()
+{
+  floatmax_t ret;
+  char *ep;
+
+  if (garglist == 0)
+    return (0);
+
+  if (garglist->word->word[0] == '\'' || garglist->word->word[0] == '"')
+    return asciicode ();
+
+  errno = 0;
+  ret = strtofltmax (garglist->word->word, &ep);
+
+  if (*ep)
+    {
+      sh_invalidnum (garglist->word->word);
+      /* Same thing about POSIX.2 conversion error requirements. */
+      ret = 0;
+      conversion_error = 1;
+    }
+  else if (errno == ERANGE)
+    printf_erange (garglist->word->word);
+
+  garglist = garglist->next;
+  return (ret);
+}
+
+/* NO check is needed for garglist here. */
+static intmax_t
+asciicode ()
+{
+  register intmax_t ch;
+#if defined (HANDLE_MULTIBYTE)
+  wchar_t wc;
+  size_t mblength, slen;
+#endif
+  DECLARE_MBSTATE;
+
+#if defined (HANDLE_MULTIBYTE)
+  slen = strlen (garglist->word->word+1);
+  mblength = MBLEN (garglist->word->word+1, slen);
+  if (mblength > 1)
+    {
+      mblength = mbtowc (&wc, garglist->word->word+1, slen);
+      ch = wc;		/* XXX */
+    }
+  else
+#endif
+    ch = (unsigned char)garglist->word->word[1];
+
+  garglist = garglist->next;
+  return (ch);
+}
diff -Nru bash-4.0-orig/builtins/pushd.c bash-4.0/builtins/pushd.c
--- bash-4.0-orig/builtins/pushd.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/pushd.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,674 @@
+/* pushd.c, created from pushd.def. */
+#line 22 "./pushd.def"
+
+#line 55 "./pushd.def"
+
+#line 84 "./pushd.def"
+
+#line 113 "./pushd.def"
+
+#include <config.h>
+
+#if defined (PUSHD_AND_POPD)
+#include <stdio.h>
+#ifndef _MINIX
+#  include <sys/param.h>
+#endif
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include <errno.h>
+
+#include <tilde/tilde.h>
+
+#include "../shell.h"
+#include "maxpath.h"
+#include "common.h"
+#include "builtext.h"
+
+#ifdef LOADABLE_BUILTIN
+#  include "builtins.h"
+#endif
+
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+/* The list of remembered directories. */
+static char **pushd_directory_list = (char **)NULL;
+
+/* Number of existing slots in this list. */
+static int directory_list_size;
+
+/* Offset to the end of the list. */
+static int directory_list_offset;
+
+static void pushd_error __P((int, char *));
+static void clear_directory_stack __P((void));
+static int cd_to_string __P((char *));
+static int change_to_temp __P((char *));
+static void add_dirstack_element __P((char *));
+static int get_dirstack_index __P((intmax_t, int, int *));
+
+#define NOCD		0x01
+#define ROTATE		0x02
+#define LONGFORM	0x04
+#define CLEARSTAK	0x08
+
+int
+pushd_builtin (list)
+     WORD_LIST *list;
+{
+  WORD_LIST *orig_list;
+  char *temp, *current_directory, *top;
+  int j, flags, skipopt;
+  intmax_t num;
+  char direction;
+
+  orig_list = list;
+  if (list && list->word && ISOPTION (list->word->word, '-'))
+    {
+      list = list->next;
+      skipopt = 1;
+    }
+  else
+    skipopt = 0;
+
+  /* If there is no argument list then switch current and
+     top of list. */
+  if (list == 0)
+    {
+      if (directory_list_offset == 0)
+	{
+	  builtin_error (_("no other directory"));
+	  return (EXECUTION_FAILURE);
+	}
+
+      current_directory = get_working_directory ("pushd");
+      if (current_directory == 0)
+	return (EXECUTION_FAILURE);
+
+      j = directory_list_offset - 1;
+      temp = pushd_directory_list[j];
+      pushd_directory_list[j] = current_directory;
+      j = change_to_temp (temp);
+      free (temp);
+      return j;
+    }
+
+  for (flags = 0; skipopt == 0 && list; list = list->next)
+    {
+      if (ISOPTION (list->word->word, 'n'))
+	{
+	  flags |= NOCD;
+	}
+      else if (ISOPTION (list->word->word, '-'))
+	{
+	  list = list->next;
+	  break;
+	}
+      else if (list->word->word[0] == '-' && list->word->word[1] == '\0')
+	/* Let `pushd -' work like it used to. */
+	break;
+      else if (((direction = list->word->word[0]) == '+') || direction == '-')
+	{
+	  if (legal_number (list->word->word + 1, &num) == 0)
+	    {
+	      sh_invalidnum (list->word->word);
+	      builtin_usage ();
+	      return (EXECUTION_FAILURE);
+	    }
+
+	  if (direction == '-')
+	    num = directory_list_offset - num;
+
+	  if (num > directory_list_offset || num < 0)
+	    {
+	      pushd_error (directory_list_offset, list->word->word);
+	      return (EXECUTION_FAILURE);
+	    }
+	  flags |= ROTATE;
+	}
+      else if (*list->word->word == '-')
+	{
+	  sh_invalidopt (list->word->word);
+	  builtin_usage ();
+	  return (EXECUTION_FAILURE);
+	}
+      else
+	break;
+    }
+
+  if (flags & ROTATE)
+    {
+      /* Rotate the stack num times.  Remember, the current
+	 directory acts like it is part of the stack. */
+      temp = get_working_directory ("pushd");
+
+      if (num == 0)
+	{
+	  j = ((flags & NOCD) == 0) ? change_to_temp (temp) : EXECUTION_SUCCESS;
+	  free (temp);
+	  return j;
+	}
+
+      do
+	{
+	  top = pushd_directory_list[directory_list_offset - 1];
+
+	  for (j = directory_list_offset - 2; j > -1; j--)
+	    pushd_directory_list[j + 1] = pushd_directory_list[j];
+
+	  pushd_directory_list[j + 1] = temp;
+
+	  temp = top;
+	  num--;
+	}
+      while (num);
+
+      j = ((flags & NOCD) == 0) ? change_to_temp (temp) : EXECUTION_SUCCESS;
+      free (temp);
+      return j;
+    }
+
+  if (list == 0)
+    return (EXECUTION_SUCCESS);
+
+  /* Change to the directory in list->word->word.  Save the current
+     directory on the top of the stack. */
+  current_directory = get_working_directory ("pushd");
+  if (current_directory == 0)
+    return (EXECUTION_FAILURE);
+
+  j = ((flags & NOCD) == 0) ? cd_builtin (skipopt ? orig_list : list) : EXECUTION_SUCCESS;
+  if (j == EXECUTION_SUCCESS)
+    {
+      add_dirstack_element ((flags & NOCD) ? savestring (list->word->word) : current_directory);
+      dirs_builtin ((WORD_LIST *)NULL);
+      if (flags & NOCD)
+	free (current_directory);
+      return (EXECUTION_SUCCESS);
+    }
+  else
+    {
+      free (current_directory);
+      return (EXECUTION_FAILURE);
+    }
+}
+
+/* Pop the directory stack, and then change to the new top of the stack.
+   If LIST is non-null it should consist of a word +N or -N, which says
+   what element to delete from the stack.  The default is the top one. */
+int
+popd_builtin (list)
+     WORD_LIST *list;
+{
+  register int i;
+  intmax_t which;
+  int flags;
+  char direction;
+  char *which_word;
+
+  which_word = (char *)NULL;
+  for (flags = 0, which = 0, direction = '+'; list; list = list->next)
+    {
+      if (ISOPTION (list->word->word, 'n'))
+	{
+	  flags |= NOCD;
+	}
+      else if (ISOPTION (list->word->word, '-'))
+	{
+	  list = list->next;
+	  break;
+	}
+      else if (((direction = list->word->word[0]) == '+') || direction == '-')
+	{
+	  if (legal_number (list->word->word + 1, &which) == 0)
+	    {
+	      sh_invalidnum (list->word->word);
+	      builtin_usage ();
+	      return (EXECUTION_FAILURE);
+	    }
+	  which_word = list->word->word;
+	}
+      else if (*list->word->word == '-')
+	{
+	  sh_invalidopt (list->word->word);
+	  builtin_usage ();
+	  return (EXECUTION_FAILURE);
+	}
+      else
+	break;
+    }
+
+  if (which > directory_list_offset || (directory_list_offset == 0 && which == 0))
+    {
+      pushd_error (directory_list_offset, which_word ? which_word : "");
+      return (EXECUTION_FAILURE);
+    }
+
+  /* Handle case of no specification, or top of stack specification. */
+  if ((direction == '+' && which == 0) ||
+      (direction == '-' && which == directory_list_offset))
+    {
+      i = ((flags & NOCD) == 0) ? cd_to_string (pushd_directory_list[directory_list_offset - 1])
+      				: EXECUTION_SUCCESS;
+      if (i != EXECUTION_SUCCESS)
+	return (i);
+      free (pushd_directory_list[--directory_list_offset]);
+    }
+  else
+    {
+      /* Since an offset other than the top directory was specified,
+	 remove that directory from the list and shift the remainder
+	 of the list into place. */
+      i = (direction == '+') ? directory_list_offset - which : which;
+      free (pushd_directory_list[i]);
+      directory_list_offset--;
+
+      /* Shift the remainder of the list into place. */
+      for (; i < directory_list_offset; i++)
+	pushd_directory_list[i] = pushd_directory_list[i + 1];
+    }
+
+  dirs_builtin ((WORD_LIST *)NULL);
+  return (EXECUTION_SUCCESS);
+}
+
+/* Print the current list of directories on the directory stack. */
+int
+dirs_builtin (list)
+     WORD_LIST *list;
+{
+  int flags, desired_index, index_flag, vflag;
+  intmax_t i;
+  char *temp, *w;
+
+  for (flags = vflag = index_flag = 0, desired_index = -1, w = ""; list; list = list->next)
+    {
+      if (ISOPTION (list->word->word, 'l'))
+	{
+	  flags |= LONGFORM;
+	}
+      else if (ISOPTION (list->word->word, 'c'))
+	{
+	  flags |= CLEARSTAK;
+	}
+      else if (ISOPTION (list->word->word, 'v'))
+	{
+	  vflag |= 2;
+	}
+      else if (ISOPTION (list->word->word, 'p'))
+	{
+	  vflag |= 1;
+	}
+      else if (ISOPTION (list->word->word, '-'))
+	{
+	  list = list->next;
+	  break;
+	}
+      else if (*list->word->word == '+' || *list->word->word == '-')
+	{
+	  int sign;
+	  if (legal_number (w = list->word->word + 1, &i) == 0)
+	    {
+	      sh_invalidnum (list->word->word);
+	      builtin_usage ();
+	      return (EXECUTION_FAILURE);
+	    }
+	  sign = (*list->word->word == '+') ? 1 : -1;
+	  desired_index = get_dirstack_index (i, sign, &index_flag);
+	}
+      else
+	{
+	  sh_invalidopt (list->word->word);
+	  builtin_usage ();
+	  return (EXECUTION_FAILURE);
+	}
+    }
+
+  if (flags & CLEARSTAK)
+    {
+      clear_directory_stack ();
+      return (EXECUTION_SUCCESS);
+    }
+
+  if (index_flag && (desired_index < 0 || desired_index > directory_list_offset))
+    {
+      pushd_error (directory_list_offset, w);
+      return (EXECUTION_FAILURE);
+    }
+
+#define DIRSTACK_FORMAT(temp) \
+  (flags & LONGFORM) ? temp : polite_directory_format (temp)
+
+  /* The first directory printed is always the current working directory. */
+  if (index_flag == 0 || (index_flag == 1 && desired_index == 0))
+    {
+      temp = get_working_directory ("dirs");
+      if (temp == 0)
+	temp = savestring (_("<no current directory>"));
+      if (vflag & 2)
+	printf ("%2d  %s", 0, DIRSTACK_FORMAT (temp));
+      else
+	printf ("%s", DIRSTACK_FORMAT (temp));
+      free (temp);
+      if (index_flag)
+	{
+	  putchar ('\n');
+	  return (sh_chkwrite (EXECUTION_SUCCESS));
+	}
+    }
+
+#define DIRSTACK_ENTRY(i) \
+  (flags & LONGFORM) ? pushd_directory_list[i] \
+		     : polite_directory_format (pushd_directory_list[i])
+
+  /* Now print the requested directory stack entries. */
+  if (index_flag)
+    {
+      if (vflag & 2)
+	printf ("%2d  %s", directory_list_offset - desired_index,
+			   DIRSTACK_ENTRY (desired_index));
+      else
+	printf ("%s", DIRSTACK_ENTRY (desired_index));
+    }
+  else
+    for (i = directory_list_offset - 1; i >= 0; i--)
+      if (vflag >= 2)
+	printf ("\n%2d  %s", directory_list_offset - (int)i, DIRSTACK_ENTRY (i));
+      else
+	printf ("%s%s", (vflag & 1) ? "\n" : " ", DIRSTACK_ENTRY (i));
+
+  putchar ('\n');
+
+  return (sh_chkwrite (EXECUTION_SUCCESS));
+}
+
+static void
+pushd_error (offset, arg)
+     int offset;
+     char *arg;
+{
+  if (offset == 0)
+    builtin_error (_("directory stack empty"));
+  else
+    sh_erange (arg, _("directory stack index"));
+}
+
+static void
+clear_directory_stack ()
+{
+  register int i;
+
+  for (i = 0; i < directory_list_offset; i++)
+    free (pushd_directory_list[i]);
+  directory_list_offset = 0;
+}
+
+/* Switch to the directory in NAME.  This uses the cd_builtin to do the work,
+   so if the result is EXECUTION_FAILURE then an error message has already
+   been printed. */
+static int
+cd_to_string (name)
+     char *name;
+{
+  WORD_LIST *tlist;
+  WORD_LIST *dir;
+  int result;
+
+  dir = make_word_list (make_word (name), NULL);
+  tlist = make_word_list (make_word ("--"), dir);
+  result = cd_builtin (tlist);
+  dispose_words (tlist);
+  return (result);
+}
+
+static int
+change_to_temp (temp)
+     char *temp;
+{
+  int tt;
+
+  tt = temp ? cd_to_string (temp) : EXECUTION_FAILURE;
+
+  if (tt == EXECUTION_SUCCESS)
+    dirs_builtin ((WORD_LIST *)NULL);
+
+  return (tt);
+}
+
+static void
+add_dirstack_element (dir)
+     char *dir;
+{
+  if (directory_list_offset == directory_list_size)
+    pushd_directory_list = strvec_resize (pushd_directory_list, directory_list_size += 10);
+  pushd_directory_list[directory_list_offset++] = dir;
+}
+
+static int
+get_dirstack_index (ind, sign, indexp)
+     intmax_t ind;
+     int sign, *indexp;
+{
+  if (indexp)
+    *indexp = sign > 0 ? 1 : 2;
+
+  /* dirs +0 prints the current working directory. */
+  /* dirs -0 prints last element in directory stack */
+  if (ind == 0 && sign > 0)
+    return 0;
+  else if (ind == directory_list_offset)
+    {
+      if (indexp)
+	*indexp = sign > 0 ? 2 : 1;
+      return 0;
+    }
+  else if (ind >= 0 && ind <= directory_list_offset)
+    return (sign > 0 ? directory_list_offset - ind : ind);
+  else
+    return -1;
+}
+
+/* Used by the tilde expansion code. */
+char *
+get_dirstack_from_string (string)
+     char *string;
+{
+  int ind, sign, index_flag;
+  intmax_t i;
+
+  sign = 1;
+  if (*string == '-' || *string == '+')
+    {
+      sign = (*string == '-') ? -1 : 1;
+      string++;
+    }
+  if (legal_number (string, &i) == 0)
+    return ((char *)NULL);
+
+  index_flag = 0;
+  ind = get_dirstack_index (i, sign, &index_flag);
+  if (index_flag && (ind < 0 || ind > directory_list_offset))
+    return ((char *)NULL);
+  if (index_flag == 0 || (index_flag == 1 && ind == 0))
+    return (get_string_value ("PWD"));
+  else
+    return (pushd_directory_list[ind]);
+}
+
+#ifdef INCLUDE_UNUSED
+char *
+get_dirstack_element (ind, sign)
+     intmax_t ind;
+     int sign;
+{
+  int i;
+
+  i = get_dirstack_index (ind, sign, (int *)NULL);
+  return (i < 0 || i > directory_list_offset) ? (char *)NULL
+					      : pushd_directory_list[i];
+}
+#endif
+
+void
+set_dirstack_element (ind, sign, value)
+     intmax_t ind;
+     int  sign;
+     char *value;
+{
+  int i;
+
+  i = get_dirstack_index (ind, sign, (int *)NULL);
+  if (ind == 0 || i < 0 || i > directory_list_offset)
+    return;
+  free (pushd_directory_list[i]);
+  pushd_directory_list[i] = savestring (value);
+}
+
+WORD_LIST *
+get_directory_stack (flags)
+     int flags;
+{
+  register int i;
+  WORD_LIST *ret;
+  char *d, *t;
+
+  for (ret = (WORD_LIST *)NULL, i = 0; i < directory_list_offset; i++)
+    {
+      d = (flags&1) ? polite_directory_format (pushd_directory_list[i])
+		    : pushd_directory_list[i];
+      ret = make_word_list (make_word (d), ret);
+    }
+  /* Now the current directory. */
+  d = get_working_directory ("dirstack");
+  i = 0;	/* sentinel to decide whether or not to free d */
+  if (d == 0)
+    d = ".";
+  else
+    {
+      t = polite_directory_format (d);
+      /* polite_directory_format sometimes returns its argument unchanged.
+	 If it does not, we can free d right away.  If it does, we need to
+	 mark d to be deleted later. */
+      if (t != d)
+	{
+	  free (d);
+	  d = t;
+	}
+      else /* t == d, so d is what we want */
+	i = 1;
+    }
+  ret = make_word_list (make_word (d), ret);
+  if (i)
+    free (d);
+  return ret;	/* was (REVERSE_LIST (ret, (WORD_LIST *)); */
+}
+
+#ifdef LOADABLE_BUILTIN
+char * const dirs_doc[] = {
+N_("Display the list of currently remembered directories.  Directories\n\
+    find their way onto the list with the `pushd' command; you can get\n\
+    back up through the list with the `popd' command.\n\
+    \n\
+    Options:\n\
+      -c	clear the directory stack by deleting all of the elements\n\
+      -l	do not print tilde-prefixed versions of directories relative\n\
+    	to your home directory\n\
+      -p	print the directory stack with one entry per line\n\
+      -v	print the directory stack with one entry per line prefixed\n\
+    	with its position in the stack\n\
+    \n\
+    Arguments:\n\
+      +N	Displays the Nth entry counting from the left of the list shown by\n\
+    	dirs when invoked without options, starting with zero.\n\
+    \n\
+      -N	Displays the Nth entry counting from the right of the list shown by\n\
+	dirs when invoked without options, starting with zero."),
+  (char *)NULL
+};
+
+char * const pushd_doc[] = {
+N_("Adds a directory to the top of the directory stack, or rotates\n\
+    the stack, making the new top of the stack the current working\n\
+    directory.  With no arguments, exchanges the top two directories.\n\
+    \n\
+    Options:\n\
+      -n	Suppresses the normal change of directory when adding\n\
+    	directories to the stack, so only the stack is manipulated.\n\
+    \n\
+    Arguments:\n\
+      +N	Rotates the stack so that the Nth directory (counting\n\
+    	from the left of the list shown by `dirs', starting with\n\
+    	zero) is at the top.\n\
+    \n\
+      -N	Rotates the stack so that the Nth directory (counting\n\
+    	from the right of the list shown by `dirs', starting with\n\
+    	zero) is at the top.\n\
+    \n\
+      dir	Adds DIR to the directory stack at the top, making it the\n\
+    	new current working directory.\n\
+    \n\
+    The `dirs' builtin displays the directory stack."),
+  (char *)NULL
+};
+
+char * const popd_doc[] = {
+N_("Removes entries from the directory stack.  With no arguments, removes\n\
+    the top directory from the stack, and changes to the new top directory.\n\
+    \n\
+    Options:\n\
+      -n	Suppresses the normal change of directory when removing\n\
+    	directories from the stack, so only the stack is manipulated.\n\
+    \n\
+    Arguments:\n\
+      +N	Removes the Nth entry counting from the left of the list\n\
+    	shown by `dirs', starting with zero.  For example: `popd +0'\n\
+    	removes the first directory, `popd +1' the second.\n\
+    \n\
+      -N	Removes the Nth entry counting from the right of the list\n\
+    	shown by `dirs', starting with zero.  For example: `popd -0'\n\
+    	removes the last directory, `popd -1' the next to last.\n\
+    \n\
+    The `dirs' builtin displays the directory stack."),
+  (char *)NULL
+};
+
+struct builtin pushd_struct = {
+	"pushd",
+	pushd_builtin,
+	BUILTIN_ENABLED,
+	pushd_doc,
+	"pushd [+N | -N] [-n] [dir]",
+	0
+};
+
+struct builtin popd_struct = {
+	"popd",
+	popd_builtin,
+	BUILTIN_ENABLED,
+	popd_doc,
+	"popd [+N | -N] [-n]",
+	0
+};
+
+struct builtin dirs_struct = {
+	"dirs",
+	dirs_builtin,
+	BUILTIN_ENABLED,
+	dirs_doc,
+	"dirs [-clpv] [+N] [-N]",
+	0
+};
+#endif /* LOADABLE_BUILTIN */
+
+#endif /* PUSHD_AND_POPD */
diff -Nru bash-4.0-orig/builtins/read.c bash-4.0/builtins/read.c
--- bash-4.0-orig/builtins/read.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/read.c	2009-12-08 18:04:02.000000000 +0100
@@ -0,0 +1,910 @@
+/* read.c, created from read.def. */
+#line 22 "./read.def"
+
+#line 62 "./read.def"
+
+#include <config.h>
+
+#include "bashtypes.h"
+#include "posixstat.h"
+
+#include <stdio.h>
+
+#include "bashansi.h"
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include <signal.h>
+#include <errno.h>
+
+#ifdef __CYGWIN__
+#  include <fcntl.h>
+#  include <io.h>
+#endif
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#include <shtty.h>
+
+#if defined (READLINE)
+#include "../bashline.h"
+#include <readline/readline.h>
+#endif
+
+#if defined (BUFFERED_INPUT)
+#  include "input.h"
+#endif
+
+#if !defined(errno)
+extern int errno;
+#endif
+
+struct ttsave
+{
+  int fd;
+  TTYSTRUCT *attrs;
+};
+
+#if defined (READLINE)
+static void reset_attempted_completion_function __P((char *));
+static int set_itext __P((void));
+static char *edit_line __P((char *, char *));
+static void set_eol_delim __P((int));
+static void reset_eol_delim __P((char *));
+#endif
+static SHELL_VAR *bind_read_variable __P((char *, char *));
+#if defined (HANDLE_MULTIBYTE)
+static int read_mbchar __P((int, char *, int, int, int));
+#endif
+static void ttyrestore __P((struct ttsave *));
+
+static sighandler sigalrm __P((int));
+static void reset_alarm __P((void));
+
+static procenv_t alrmbuf;
+static SigHandler *old_alrm;
+static unsigned char delim;
+
+static sighandler
+sigalrm (s)
+     int s;
+{
+  longjmp (alrmbuf, 1);
+}
+
+static void
+reset_alarm ()
+{
+  set_signal_handler (SIGALRM, old_alrm);
+  falarm (0, 0);
+}
+
+/* Read the value of the shell variables whose names follow.
+   The reading is done from the current input stream, whatever
+   that may be.  Successive words of the input line are assigned
+   to the variables mentioned in LIST.  The last variable in LIST
+   gets the remainder of the words on the line.  If no variables
+   are mentioned in LIST, then the default variable is $REPLY. */
+int
+read_builtin (list)
+     WORD_LIST *list;
+{
+  register char *varname;
+  int size, i, nr, pass_next, saw_escape, eof, opt, retval, code, print_ps2;
+  int input_is_tty, input_is_pipe, unbuffered_read, skip_ctlesc, skip_ctlnul;
+  int raw, edit, nchars, silent, have_timeout, fd;
+  unsigned int tmsec, tmusec;
+  long ival, uval;
+  intmax_t intval;
+  char c;
+  char *input_string, *orig_input_string, *ifs_chars, *prompt, *arrayname;
+  char *e, *t, *t1, *ps2, *tofree;
+  struct stat tsb;
+  SHELL_VAR *var;
+  TTYSTRUCT ttattrs, ttset;
+  struct ttsave termsave;
+#if defined (ARRAY_VARS)
+  WORD_LIST *alist;
+#endif
+#if defined (READLINE)
+  char *rlbuf, *itext;
+  int rlind;
+#endif
+
+  USE_VAR(size);
+  USE_VAR(i);
+  USE_VAR(pass_next);
+  USE_VAR(print_ps2);
+  USE_VAR(saw_escape);
+  USE_VAR(input_is_pipe);
+/*  USE_VAR(raw); */
+  USE_VAR(edit);
+  USE_VAR(tmsec);
+  USE_VAR(tmusec);
+  USE_VAR(nchars);
+  USE_VAR(silent);
+  USE_VAR(ifs_chars);
+  USE_VAR(prompt);
+  USE_VAR(arrayname);
+#if defined (READLINE)
+  USE_VAR(rlbuf);
+  USE_VAR(rlind);
+  USE_VAR(itext);
+#endif
+  USE_VAR(list);
+  USE_VAR(ps2);
+
+  i = 0;		/* Index into the string that we are reading. */
+  raw = edit = 0;	/* Not reading raw input by default. */
+  silent = 0;
+  arrayname = prompt = (char *)NULL;
+  fd = 0;		/* file descriptor to read from */
+
+#if defined (READLINE)
+  rlbuf = itext = (char *)0;
+  rlind = 0;
+#endif
+
+  tmsec = tmusec = 0;		/* no timeout */
+  nr = nchars = input_is_tty = input_is_pipe = unbuffered_read = have_timeout = 0;
+  delim = '\n';		/* read until newline */
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "ersa:d:i:n:p:t:u:")) != -1)
+    {
+      switch (opt)
+	{
+	case 'r':
+	  raw = 1;
+	  break;
+	case 'p':
+	  prompt = list_optarg;
+	  break;
+	case 's':
+	  silent = 1;
+	  break;
+	case 'e':
+#if defined (READLINE)
+	  edit = 1;
+#endif
+	  break;
+	case 'i':
+#if defined (READLINE)
+	  itext = list_optarg;
+#endif
+	  break;
+#if defined (ARRAY_VARS)
+	case 'a':
+	  arrayname = list_optarg;
+	  break;
+#endif
+	case 't':
+	  code = uconvert (list_optarg, &ival, &uval);
+	  if (code == 0 || ival < 0 || uval < 0)
+	    {
+	      builtin_error (_("%s: invalid timeout specification"), list_optarg);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else
+	    {
+	      have_timeout = 1;
+	      tmsec = ival;
+	      tmusec = uval;
+	    }
+	  break;
+	case 'n':
+	  code = legal_number (list_optarg, &intval);
+	  if (code == 0 || intval < 0 || intval != (int)intval)
+	    {
+	      sh_invalidnum (list_optarg);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else
+	    nchars = intval;
+	  break;
+	case 'u':
+	  code = legal_number (list_optarg, &intval);
+	  if (code == 0 || intval < 0 || intval != (int)intval)
+	    {
+	      builtin_error (_("%s: invalid file descriptor specification"), list_optarg);
+	      return (EXECUTION_FAILURE);
+	    }
+	  else
+	    fd = intval;
+	  if (sh_validfd (fd) == 0)
+	    {
+	      builtin_error (_("%d: invalid file descriptor: %s"), fd, strerror (errno));
+	      return (EXECUTION_FAILURE);
+	    }
+	  break;
+	case 'd':
+	  delim = *list_optarg;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  /* `read -t 0 var' tests whether input is available with select/FIONREAD,
+     and fails if those are unavailable */
+  if (have_timeout && tmsec == 0 && tmusec == 0)
+#if 0
+    return (EXECUTION_FAILURE);
+#else
+    return (input_avail (fd) ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+#endif
+
+  /* IF IFS is unset, we use the default of " \t\n". */
+  ifs_chars = getifs ();
+  if (ifs_chars == 0)		/* XXX - shouldn't happen */
+    ifs_chars = "";
+  for (skip_ctlesc = skip_ctlnul = 0, e = ifs_chars; *e; e++)
+    skip_ctlesc |= *e == CTLESC, skip_ctlnul |= *e == CTLNUL;
+
+  input_string = (char *)xmalloc (size = 112);	/* XXX was 128 */
+  input_string[0] = '\0';
+
+  /* $TMOUT, if set, is the default timeout for read. */
+  if (have_timeout == 0 && (e = get_string_value ("TMOUT")))
+    {
+      code = uconvert (e, &ival, &uval);
+      if (code == 0 || ival < 0 || uval < 0)
+	tmsec = tmusec = 0;
+      else
+	{
+	  tmsec = ival;
+	  tmusec = uval;
+	}
+    }
+
+  begin_unwind_frame ("read_builtin");
+
+#if defined (BUFFERED_INPUT)
+  if (interactive == 0 && default_buffered_input >= 0 && fd_is_bash_input (fd))
+    sync_buffered_stream (default_buffered_input);
+#endif
+
+  input_is_tty = isatty (fd);
+  if (input_is_tty == 0)
+#ifndef __CYGWIN__
+    input_is_pipe = (lseek (fd, 0L, SEEK_CUR) < 0) && (errno == ESPIPE);
+#else
+    input_is_pipe = 1;
+#endif
+
+  /* If the -p, -e or -s flags were given, but input is not coming from the
+     terminal, turn them off. */
+  if ((prompt || edit || silent) && input_is_tty == 0)
+    {
+      prompt = (char *)NULL;
+#if defined (READLINE)
+      itext = (char *)NULL;
+#endif
+      edit = silent = 0;
+    }
+
+#if defined (READLINE)
+  if (edit)
+    add_unwind_protect (xfree, rlbuf);
+#endif
+
+  pass_next = 0;	/* Non-zero signifies last char was backslash. */
+  saw_escape = 0;	/* Non-zero signifies that we saw an escape char */
+
+  if (tmsec > 0 || tmusec > 0)
+    {
+      /* Turn off the timeout if stdin is a regular file (e.g. from
+	 input redirection). */
+      if ((fstat (fd, &tsb) < 0) || S_ISREG (tsb.st_mode))
+	tmsec = tmusec = 0;
+    }
+
+  if (tmsec > 0 || tmusec > 0)
+    {
+      code = setjmp (alrmbuf);
+      if (code)
+	{
+#if 0
+	  run_unwind_frame ("read_builtin");
+	  return (EXECUTION_FAILURE);
+#else
+	  input_string[i] = '\0';	/* make sure it's terminated */
+	  retval = 128+SIGALRM;;
+	  goto assign_vars;
+#endif
+	}
+      old_alrm = set_signal_handler (SIGALRM, sigalrm);
+      add_unwind_protect (reset_alarm, (char *)NULL);
+#if defined (READLINE)
+      if (edit)
+	add_unwind_protect (reset_attempted_completion_function, (char *)NULL);
+#endif
+      falarm (tmsec, tmusec);
+    }
+
+  /* If we've been asked to read only NCHARS chars, or we're using some
+     character other than newline to terminate the line, do the right
+     thing to readline or the tty. */
+  if (nchars > 0 || delim != '\n')
+    {
+#if defined (READLINE)
+      if (edit)
+	{
+	  if (nchars > 0)
+	    {
+	      unwind_protect_int (rl_num_chars_to_read);
+	      rl_num_chars_to_read = nchars;
+	    }
+	  if (delim != '\n')
+	    {
+	      set_eol_delim (delim);
+	      add_unwind_protect (reset_eol_delim, (char *)NULL);
+	    }
+	}
+      else
+#endif
+      if (input_is_tty)
+	{
+	  /* ttsave() */
+	  termsave.fd = fd;
+	  ttgetattr (fd, &ttattrs);
+	  termsave.attrs = &ttattrs;
+
+	  ttset = ttattrs;	  
+	  i = silent ? ttfd_cbreak (fd, &ttset) : ttfd_onechar (fd, &ttset);
+	  if (i < 0)
+	    sh_ttyerror (1);
+	  add_unwind_protect ((Function *)ttyrestore, (char *)&termsave);
+	}
+    }
+  else if (silent)	/* turn off echo but leave term in canonical mode */
+    {
+      /* ttsave (); */
+      termsave.fd = fd;
+      ttgetattr (fd, &ttattrs);
+      termsave.attrs = &ttattrs;
+
+      ttset = ttattrs;
+      i = ttfd_noecho (fd, &ttset);			/* ttnoecho (); */
+      if (i < 0)
+	sh_ttyerror (1);
+
+      add_unwind_protect ((Function *)ttyrestore, (char *)&termsave);
+    }
+
+  /* This *must* be the top unwind-protect on the stack, so the manipulation
+     of the unwind-protect stack after the realloc() works right. */
+  add_unwind_protect (xfree, input_string);
+  interrupt_immediately++;
+  terminate_immediately++;
+
+  unbuffered_read = (nchars > 0) || (delim != '\n') || input_is_pipe;
+
+  if (prompt && edit == 0)
+    {
+      fprintf (stderr, "%s", prompt);
+      fflush (stderr);
+    }
+
+#if defined (__CYGWIN__) && defined (O_TEXT)
+  setmode (0, O_TEXT);
+#endif
+
+  ps2 = 0;
+  for (print_ps2 = eof = retval = 0;;)
+    {
+#if defined (READLINE)
+      if (edit)
+	{
+	  if (rlbuf && rlbuf[rlind] == '\0')
+	    {
+	      xfree (rlbuf);
+	      rlbuf = (char *)0;
+	    }
+	  if (rlbuf == 0)
+	    {
+	      rlbuf = edit_line (prompt ? prompt : "", itext);
+	      rlind = 0;
+	    }
+	  if (rlbuf == 0)
+	    {
+	      eof = 1;
+	      break;
+	    }
+	  c = rlbuf[rlind++];
+	}
+      else
+	{
+#endif
+
+      if (print_ps2)
+	{
+	  if (ps2 == 0)
+	    ps2 = get_string_value ("PS2");
+	  fprintf (stderr, "%s", ps2 ? ps2 : "");
+	  fflush (stderr);
+	  print_ps2 = 0;
+	}
+
+      if (unbuffered_read)
+	retval = zread (fd, &c, 1);
+      else
+	retval = zreadc (fd, &c);
+
+      if (retval <= 0)
+	{
+	  eof = 1;
+	  break;
+	}
+
+#if defined (READLINE)
+	}
+#endif
+
+      if (i + 4 >= size)	/* XXX was i + 2; use i + 4 for multibyte/read_mbchar */
+	{
+	  input_string = (char *)xrealloc (input_string, size += 128);
+	  remove_unwind_protect ();
+	  add_unwind_protect (xfree, input_string);
+	}
+
+      /* If the next character is to be accepted verbatim, a backslash
+	 newline pair still disappears from the input. */
+      if (pass_next)
+	{
+	  pass_next = 0;
+	  if (c == '\n')
+	    {
+	      i--;		/* back up over the CTLESC */
+	      if (interactive && input_is_tty && raw == 0)
+		print_ps2 = 1;
+	    }
+	  else
+	    goto add_char;
+	  continue;
+	}
+
+      /* This may cause problems if IFS contains CTLESC */
+      if (c == '\\' && raw == 0)
+	{
+	  pass_next++;
+	  if (skip_ctlesc == 0)
+	    {
+	      saw_escape++;
+	      input_string[i++] = CTLESC;
+	    }
+	  continue;
+	}
+
+      if ((unsigned char)c == delim)
+	break;
+
+      if ((skip_ctlesc == 0 && c == CTLESC) || (skip_ctlnul == 0 && c == CTLNUL))
+	{
+	  saw_escape++;
+	  input_string[i++] = CTLESC;
+	}
+
+add_char:
+      input_string[i++] = c;
+
+#if defined (HANDLE_MULTIBYTE)
+      if (nchars > 0 && MB_CUR_MAX > 1)
+	{
+	  input_string[i] = '\0';	/* for simplicity and debugging */
+	  i += read_mbchar (fd, input_string, i, c, unbuffered_read);
+	}
+#endif
+
+      nr++;
+
+      if (nchars > 0 && nr >= nchars)
+	break;
+    }
+  input_string[i] = '\0';
+
+#if 1
+  if (retval < 0)
+    {
+      builtin_error (_("read error: %d: %s"), fd, strerror (errno));
+      run_unwind_frame ("read_builtin");
+      return (EXECUTION_FAILURE);
+    }
+#endif
+
+  if (tmsec > 0 || tmusec > 0)
+    reset_alarm ();
+
+  if (nchars > 0 || delim != '\n')
+    {
+#if defined (READLINE)
+      if (edit)
+	{
+	  if (nchars > 0)
+	    rl_num_chars_to_read = 0;
+	  if (delim != '\n')
+	    reset_eol_delim ((char *)NULL);
+	}
+      else
+#endif
+      if (input_is_tty)
+	ttyrestore (&termsave);
+    }
+  else if (silent)
+    ttyrestore (&termsave);
+
+  if (unbuffered_read == 0)
+    zsyncfd (fd);
+
+  interrupt_immediately--;
+  terminate_immediately--;
+  discard_unwind_frame ("read_builtin");
+
+  retval = eof ? EXECUTION_FAILURE : EXECUTION_SUCCESS;
+
+assign_vars:
+
+#if defined (ARRAY_VARS)
+  /* If -a was given, take the string read, break it into a list of words,
+     an assign them to `arrayname' in turn. */
+  if (arrayname)
+    {
+      if (legal_identifier (arrayname) == 0)
+	{
+	  sh_invalidid (arrayname);
+	  xfree (input_string);
+	  return (EXECUTION_FAILURE);
+	}
+
+      var = find_or_make_array_variable (arrayname, 1);
+      if (var == 0)
+	{
+	  xfree (input_string);
+	  return EXECUTION_FAILURE;	/* readonly or noassign */
+	}
+      array_flush (array_cell (var));
+
+      alist = list_string (input_string, ifs_chars, 0);
+      if (alist)
+	{
+	  if (saw_escape)
+	    dequote_list (alist);
+	  else
+	    word_list_remove_quoted_nulls (alist);
+	  assign_array_var_from_word_list (var, alist, 0);
+	  dispose_words (alist);
+	}
+      xfree (input_string);
+      return (retval);
+    }
+#endif /* ARRAY_VARS */ 
+
+  /* If there are no variables, save the text of the line read to the
+     variable $REPLY.  ksh93 strips leading and trailing IFS whitespace,
+     so that `read x ; echo "$x"' and `read ; echo "$REPLY"' behave the
+     same way, but I believe that the difference in behaviors is useful
+     enough to not do it.  Without the bash behavior, there is no way
+     to read a line completely without interpretation or modification
+     unless you mess with $IFS (e.g., setting it to the empty string).
+     If you disagree, change the occurrences of `#if 0' to `#if 1' below. */
+  if (list == 0)
+    {
+#if 0
+      orig_input_string = input_string;
+      for (t = input_string; ifs_chars && *ifs_chars && spctabnl(*t) && isifs(*t); t++)
+	;
+      input_string = t;
+      input_string = strip_trailing_ifs_whitespace (input_string, ifs_chars, saw_escape);
+#endif
+
+      if (saw_escape)
+	{
+	  t = dequote_string (input_string);
+	  var = bind_variable ("REPLY", t, 0);
+	  free (t);
+	}
+      else
+	var = bind_variable ("REPLY", input_string, 0);
+      VUNSETATTR (var, att_invisible);
+
+      free (input_string);
+      return (retval);
+    }
+
+  /* This code implements the Posix.2 spec for splitting the words
+     read and assigning them to variables. */
+  orig_input_string = input_string;
+
+  /* Remove IFS white space at the beginning of the input string.  If
+     $IFS is null, no field splitting is performed. */
+  for (t = input_string; ifs_chars && *ifs_chars && spctabnl(*t) && isifs(*t); t++)
+    ;
+  input_string = t;
+  for (; list->next; list = list->next)
+    {
+      varname = list->word->word;
+#if defined (ARRAY_VARS)
+      if (legal_identifier (varname) == 0 && valid_array_reference (varname) == 0)
+#else
+      if (legal_identifier (varname) == 0)
+#endif
+	{
+	  sh_invalidid (varname);
+	  xfree (orig_input_string);
+	  return (EXECUTION_FAILURE);
+	}
+
+      /* If there are more variables than words read from the input,
+	 the remaining variables are set to the empty string. */
+      if (*input_string)
+	{
+	  /* This call updates INPUT_STRING. */
+	  t = get_word_from_string (&input_string, ifs_chars, &e);
+	  if (t)
+	    *e = '\0';
+	  /* Don't bother to remove the CTLESC unless we added one
+	     somewhere while reading the string. */
+	  if (t && saw_escape)
+	    {
+	      t1 = dequote_string (t);
+	      var = bind_read_variable (varname, t1);
+	      xfree (t1);
+	    }
+	  else
+	    var = bind_read_variable (varname, t);
+	}
+      else
+	{
+	  t = (char *)0;
+	  var = bind_read_variable (varname, "");
+	}
+
+      FREE (t);
+      if (var == 0)
+	{
+	  xfree (orig_input_string);
+	  return (EXECUTION_FAILURE);
+	}
+
+      stupidly_hack_special_variables (varname);
+      VUNSETATTR (var, att_invisible);
+    }
+
+  /* Now assign the rest of the line to the last variable argument. */
+#if defined (ARRAY_VARS)
+  if (legal_identifier (list->word->word) == 0 && valid_array_reference (list->word->word) == 0)
+#else
+  if (legal_identifier (list->word->word) == 0)
+#endif
+    {
+      sh_invalidid (list->word->word);
+      xfree (orig_input_string);
+      return (EXECUTION_FAILURE);
+    }
+
+#if 0
+  /* This has to be done this way rather than using string_list
+     and list_string because Posix.2 says that the last variable gets the
+     remaining words and their intervening separators. */
+  input_string = strip_trailing_ifs_whitespace (input_string, ifs_chars, saw_escape);
+#else
+  /* Check whether or not the number of fields is exactly the same as the
+     number of variables. */
+  tofree = NULL;
+  if (*input_string)
+    {
+      t1 = input_string;
+      t = get_word_from_string (&input_string, ifs_chars, &e);
+      if (*input_string == 0)
+	tofree = input_string = t;
+      else
+	input_string = strip_trailing_ifs_whitespace (t1, ifs_chars, saw_escape);
+    }
+#endif
+
+  if (saw_escape)
+    {
+      t = dequote_string (input_string);
+      var = bind_read_variable (list->word->word, t);
+      xfree (t);
+    }
+  else
+    var = bind_read_variable (list->word->word, input_string);
+  stupidly_hack_special_variables (list->word->word);
+  FREE (tofree);
+
+  if (var)
+    VUNSETATTR (var, att_invisible);
+  xfree (orig_input_string);
+
+  return (retval);
+}
+
+static SHELL_VAR *
+bind_read_variable (name, value)
+     char *name, *value;
+{
+#if defined (ARRAY_VARS)
+  if (valid_array_reference (name) == 0)
+    return (bind_variable (name, value, 0));
+  else
+    return (assign_array_element (name, value, 0));
+#else /* !ARRAY_VARS */
+  return bind_variable (name, value, 0);
+#endif /* !ARRAY_VARS */
+}
+
+#if defined (HANDLE_MULTIBYTE)
+static int
+read_mbchar (fd, string, ind, ch, unbuffered)
+     int fd;
+     char *string;
+     int ind, ch, unbuffered;
+{
+  char mbchar[MB_LEN_MAX + 1];
+  int i, n, r;
+  char c;
+  size_t ret;
+  mbstate_t ps, ps_back;
+  wchar_t wc;
+
+  memset (&ps, '\0', sizeof (mbstate_t));
+  memset (&ps_back, '\0', sizeof (mbstate_t));
+  
+  mbchar[0] = ch;
+  i = 1;
+  for (n = 0; n <= MB_LEN_MAX; n++)
+    {
+      ps_back = ps;
+      ret = mbrtowc (&wc, mbchar, i, &ps);
+      if (ret == (size_t)-2)
+	{
+	  ps = ps_back;
+	  if (unbuffered)
+	    r = zread (fd, &c, 1);
+	  else
+	    r = zreadc (fd, &c);
+	  if (r < 0)
+	    goto mbchar_return;
+	  mbchar[i++] = c;	
+	  continue;
+	}
+      else if (ret == (size_t)-1 || ret == (size_t)0 || ret > (size_t)0)
+	break;
+    }
+
+mbchar_return:
+  if (i > 1)	/* read a multibyte char */
+    /* mbchar[0] is already string[ind-1] */
+    for (r = 1; r < i; r++)
+      string[ind+r-1] = mbchar[r];
+  return i - 1;
+}
+#endif
+
+
+static void
+ttyrestore (ttp)
+     struct ttsave *ttp;
+{
+  ttsetattr (ttp->fd, ttp->attrs);
+}
+
+#if defined (READLINE)
+static rl_completion_func_t *old_attempted_completion_function = 0;
+static rl_hook_func_t *old_startup_hook;
+static char *deftext;
+
+static void
+reset_attempted_completion_function (cp)
+     char *cp;
+{
+  if (rl_attempted_completion_function == 0 && old_attempted_completion_function)
+    rl_attempted_completion_function = old_attempted_completion_function;
+}
+
+static int
+set_itext ()
+{
+  int r1, r2;
+
+  r1 = r2 = 0;
+  if (old_startup_hook)
+    r1 = (*old_startup_hook) ();
+  if (deftext)
+    {
+      r2 = rl_insert_text (deftext);
+      deftext = (char *)NULL;
+      rl_startup_hook = old_startup_hook;
+      old_startup_hook = (rl_hook_func_t *)NULL;
+    }
+  return (r1 || r2);
+}
+
+static char *
+edit_line (p, itext)
+     char *p;
+     char *itext;
+{
+  char *ret;
+  int len;
+
+  if (bash_readline_initialized == 0)
+    initialize_readline ();
+
+  old_attempted_completion_function = rl_attempted_completion_function;
+  rl_attempted_completion_function = (rl_completion_func_t *)NULL;
+  if (itext)
+    {
+      old_startup_hook = rl_startup_hook;
+      rl_startup_hook = set_itext;
+      deftext = itext;
+    }
+  ret = readline (p);
+  rl_attempted_completion_function = old_attempted_completion_function;
+  old_attempted_completion_function = (rl_completion_func_t *)NULL;
+
+  if (ret == 0)
+    return ret;
+  len = strlen (ret);
+  ret = (char *)xrealloc (ret, len + 2);
+  ret[len++] = delim;
+  ret[len] = '\0';
+  return ret;
+}
+
+static int old_delim_ctype;
+static rl_command_func_t *old_delim_func;
+static int old_newline_ctype;
+static rl_command_func_t *old_newline_func;
+
+static unsigned char delim_char;
+
+static void
+set_eol_delim (c)
+     int c;
+{
+  Keymap cmap;
+
+  if (bash_readline_initialized == 0)
+    initialize_readline ();
+  cmap = rl_get_keymap ();
+
+  /* Change newline to self-insert */
+  old_newline_ctype = cmap[RETURN].type;
+  old_newline_func =  cmap[RETURN].function;
+  cmap[RETURN].type = ISFUNC;
+  cmap[RETURN].function = rl_insert;
+
+  /* Bind the delimiter character to accept-line. */
+  old_delim_ctype = cmap[c].type;
+  old_delim_func = cmap[c].function;
+  cmap[c].type = ISFUNC;
+  cmap[c].function = rl_newline;
+
+  delim_char = c;
+}
+
+static void
+reset_eol_delim (cp)
+     char *cp;
+{
+  Keymap cmap;
+
+  cmap = rl_get_keymap ();
+
+  cmap[RETURN].type = old_newline_ctype;
+  cmap[RETURN].function = old_newline_func;
+
+  cmap[delim_char].type = old_delim_ctype;
+  cmap[delim_char].function = old_delim_func;
+}
+#endif
diff -Nru bash-4.0-orig/builtins/read.def bash-4.0/builtins/read.def
--- bash-4.0-orig/builtins/read.def	2009-01-16 05:11:21.000000000 +0100
+++ bash-4.0/builtins/read.def	2009-12-08 18:04:02.000000000 +0100
@@ -369,14 +369,14 @@
       code = setjmp (alrmbuf);
       if (code)
 	{
-#if 0
+	  /* Tricky.  The top of the unwind-protect stack is the free of
+	     input_string.  We want to run all the rest and use input_string,
+	     so we have to remove it from the stack. */
+	  remove_unwind_protect ();
 	  run_unwind_frame ("read_builtin");
-	  return (EXECUTION_FAILURE);
-#else
 	  input_string[i] = '\0';	/* make sure it's terminated */
-	  retval = 128+SIGALRM;;
+	  retval = 128+SIGALRM;
 	  goto assign_vars;
-#endif
 	}
       old_alrm = set_signal_handler (SIGALRM, sigalrm);
       add_unwind_protect (reset_alarm, (char *)NULL);
@@ -763,7 +763,10 @@
       if (*input_string == 0)
 	tofree = input_string = t;
       else
-	input_string = strip_trailing_ifs_whitespace (t1, ifs_chars, saw_escape);
+	{
+	  input_string = strip_trailing_ifs_whitespace (t1, ifs_chars, saw_escape);
+	  tofree = t;
+	}
     }
 #endif
 
diff -Nru bash-4.0-orig/builtins/return.c bash-4.0/builtins/return.c
--- bash-4.0-orig/builtins/return.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/return.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,45 @@
+/* return.c, created from return.def. */
+#line 22 "./return.def"
+
+#line 36 "./return.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+extern int last_command_exit_value;
+extern int subshell_environment;
+extern int return_catch_flag, return_catch_value;
+
+/* If we are executing a user-defined function then exit with the value
+   specified as an argument.  if no argument is given, then the last
+   exit status is used. */
+int
+return_builtin (list)
+     WORD_LIST *list;
+{
+  if (no_options (list))
+    return (EX_USAGE);
+  list = loptend;	/* skip over possible `--' */
+
+  return_catch_value = get_exitstat (list);
+
+  if (return_catch_flag)
+    longjmp (return_catch, 1);
+  else
+    {
+      builtin_error (_("can only `return' from a function or sourced script"));
+      return (EXECUTION_FAILURE);
+    }
+}
diff -Nru bash-4.0-orig/builtins/set.c bash-4.0/builtins/set.c
--- bash-4.0-orig/builtins/set.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/set.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,725 @@
+/* set.c, created from set.def. */
+#line 22 "./set.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../flags.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#if defined (READLINE)
+#  include "../input.h"
+#  include "../bashline.h"
+#  include <readline/readline.h>
+#endif
+
+#if defined (HISTORY)
+#  include "../bashhist.h"
+#endif
+
+extern int posixly_correct, ignoreeof, eof_encountered_limit;
+#if defined (HISTORY)
+extern int dont_save_function_defs;
+#endif
+#if defined (READLINE)
+extern int no_line_editing;
+#endif /* READLINE */
+
+#line 153 "./set.def"
+
+typedef int setopt_set_func_t __P((int, char *));
+typedef int setopt_get_func_t __P((char *));
+
+static void print_minus_o_option __P((char *, int, int));
+static void print_all_shell_variables __P((void));
+
+static int set_ignoreeof __P((int, char *));
+static int set_posix_mode __P((int, char *));
+
+#if defined (READLINE)
+static int set_edit_mode __P((int, char *));
+static int get_edit_mode __P((char *));
+#endif
+
+#if defined (HISTORY)
+static int bash_set_history __P((int, char *));
+#endif
+
+static const char * const on = "on";
+static const char * const off = "off";
+
+/* A struct used to match long options for set -o to the corresponding
+   option letter or internal variable.  The functions can be called to
+   dynamically generate values. */
+const struct {
+  char *name;
+  int letter;
+  int *variable;
+  setopt_set_func_t *set_func;
+  setopt_get_func_t *get_func;
+} o_options[] = {
+  { "allexport",  'a', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
+#if defined (BRACE_EXPANSION)
+  { "braceexpand",'B', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+#endif
+#if defined (READLINE)
+  { "emacs",     '\0', (int *)NULL, set_edit_mode, get_edit_mode },
+#endif
+  { "errexit",	  'e', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "errtrace",	  'E', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "functrace",  'T', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "hashall",    'h', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+#if defined (BANG_HISTORY)
+  { "histexpand", 'H', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+#endif /* BANG_HISTORY */
+#if defined (HISTORY)
+  { "history",   '\0', &enable_history_list, bash_set_history, (setopt_get_func_t *)NULL },
+#endif
+  { "ignoreeof", '\0', &ignoreeof, set_ignoreeof, (setopt_get_func_t *)NULL },
+  { "interactive-comments", '\0', &interactive_comments, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
+  { "keyword",    'k', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "monitor",	  'm', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "noclobber",  'C', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "noexec",	  'n', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "noglob",	  'f', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+#if defined (HISTORY)
+  { "nolog",     '\0', &dont_save_function_defs, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
+#endif
+#if defined (JOB_CONTROL)
+  { "notify",	  'b', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+#endif /* JOB_CONTROL */
+  { "nounset",	  'u', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "onecmd",	  't', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
+  { "physical",   'P', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "pipefail",  '\0', &pipefail_opt, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "posix",     '\0', &posixly_correct, set_posix_mode, (setopt_get_func_t *)NULL },
+  { "privileged", 'p', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  { "verbose",	  'v', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+#if defined (READLINE)
+  { "vi",        '\0', (int *)NULL, set_edit_mode, get_edit_mode },
+#endif
+  { "xtrace",	  'x', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },
+  {(char *)NULL, 0 , (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },
+};
+
+#define N_O_OPTIONS	(sizeof (o_options) / sizeof (o_options[0]))
+
+#define GET_BINARY_O_OPTION_VALUE(i, name) \
+  ((o_options[i].get_func) ? (*o_options[i].get_func) (name) \
+			   : (*o_options[i].variable))
+
+#define SET_BINARY_O_OPTION_VALUE(i, onoff, name) \
+  ((o_options[i].set_func) ? (*o_options[i].set_func) (onoff, name) \
+			   : (*o_options[i].variable = (onoff == FLAG_ON)))
+
+int
+minus_o_option_value (name)
+     char *name;
+{
+  register int	i;
+  int *on_or_off;
+
+  for (i = 0; o_options[i].name; i++)
+    {
+      if (STREQ (name, o_options[i].name))
+	{
+	  if (o_options[i].letter)
+	    {
+	      on_or_off = find_flag (o_options[i].letter);
+	      return ((on_or_off == FLAG_UNKNOWN) ? -1 : *on_or_off);
+	    }
+	  else
+	    return (GET_BINARY_O_OPTION_VALUE (i, name));
+	}
+    }
+
+  return (-1);
+}
+
+#define MINUS_O_FORMAT "%-15s\t%s\n"
+
+static void
+print_minus_o_option (name, value, pflag)
+     char *name;
+     int value, pflag;
+{
+  if (pflag == 0)
+    printf (MINUS_O_FORMAT, name, value ? on : off);
+  else
+    printf ("set %co %s\n", value ? '-' : '+', name);
+}
+
+void
+list_minus_o_opts (mode, reusable)
+     int mode, reusable;
+{
+  register int	i;
+  int *on_or_off, value;
+
+  for (i = 0; o_options[i].name; i++)
+    {
+      if (o_options[i].letter)
+	{
+	  value = 0;
+	  on_or_off = find_flag (o_options[i].letter);
+	  if (on_or_off == FLAG_UNKNOWN)
+	    on_or_off = &value;
+	  if (mode == -1 || mode == *on_or_off)
+	    print_minus_o_option (o_options[i].name, *on_or_off, reusable);
+	}
+      else
+	{
+	  value = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);
+	  if (mode == -1 || mode == value)
+	    print_minus_o_option (o_options[i].name, value, reusable);
+	}
+    }
+}
+
+char **
+get_minus_o_opts ()
+{
+  char **ret;
+  int i;
+
+  ret = strvec_create (N_O_OPTIONS + 1);
+  for (i = 0; o_options[i].name; i++)
+    ret[i] = o_options[i].name;
+  ret[i] = (char *)NULL;
+  return ret;
+}
+
+static int
+set_ignoreeof (on_or_off, option_name)
+     int on_or_off;
+     char *option_name;
+{
+  ignoreeof = on_or_off == FLAG_ON;
+  unbind_variable ("ignoreeof");
+  if (ignoreeof)
+    bind_variable ("IGNOREEOF", "10", 0); 
+  else
+    unbind_variable ("IGNOREEOF");
+  sv_ignoreeof ("IGNOREEOF");
+  return 0;
+}
+
+static int
+set_posix_mode (on_or_off, option_name)
+     int on_or_off;
+     char *option_name;
+{
+  posixly_correct = on_or_off == FLAG_ON;
+  if (posixly_correct == 0)
+    unbind_variable ("POSIXLY_CORRECT");
+  else
+    bind_variable ("POSIXLY_CORRECT", "y", 0);
+  sv_strict_posix ("POSIXLY_CORRECT");
+  return (0);
+}
+
+#if defined (READLINE)
+/* Magic.  This code `knows' how readline handles rl_editing_mode. */
+static int
+set_edit_mode (on_or_off, option_name)
+     int on_or_off;
+     char *option_name;
+{
+  int isemacs;
+
+  if (on_or_off == FLAG_ON)
+    {
+      rl_variable_bind ("editing-mode", option_name);
+
+      if (interactive)
+	with_input_from_stdin ();
+      no_line_editing = 0;
+    }
+  else
+    {
+      isemacs = rl_editing_mode == 1;
+      if ((isemacs && *option_name == 'e') || (!isemacs && *option_name == 'v'))
+	{
+	  if (interactive)
+	    with_input_from_stream (stdin, "stdin");
+	  no_line_editing = 1;
+	}
+    }
+  return 1-no_line_editing;
+}
+
+static int
+get_edit_mode (name)
+     char *name;
+{
+  return (*name == 'e' ? no_line_editing == 0 && rl_editing_mode == 1
+		       : no_line_editing == 0 && rl_editing_mode == 0);
+}
+#endif /* READLINE */
+
+#if defined (HISTORY)
+static int
+bash_set_history (on_or_off, option_name)
+     int on_or_off;
+     char *option_name;
+{
+  if (on_or_off == FLAG_ON)
+    {
+      enable_history_list = 1;
+      bash_history_enable ();
+      if (history_lines_this_session == 0)
+	load_history ();
+    }
+  else
+    {
+      enable_history_list = 0;
+      bash_history_disable ();
+    }
+  return (1 - enable_history_list);
+}
+#endif
+
+int
+set_minus_o_option (on_or_off, option_name)
+     int on_or_off;
+     char *option_name;
+{
+  register int i;
+
+  for (i = 0; o_options[i].name; i++)
+    {
+      if (STREQ (option_name, o_options[i].name))
+	{
+	  if (o_options[i].letter == 0)
+	    {
+	      SET_BINARY_O_OPTION_VALUE (i, on_or_off, option_name);
+	      return (EXECUTION_SUCCESS);
+	    }
+	  else
+	    {
+	      if (change_flag (o_options[i].letter, on_or_off) == FLAG_ERROR)
+		{
+		  sh_invalidoptname (option_name);
+		  return (EXECUTION_FAILURE);
+		}
+	      else
+		return (EXECUTION_SUCCESS);
+	    }
+
+	}
+    }
+
+  sh_invalidoptname (option_name);
+  return (EX_USAGE);
+}
+
+static void
+print_all_shell_variables ()
+{
+  SHELL_VAR **vars;
+
+  vars = all_shell_variables ();
+  if (vars)
+    {
+      print_var_list (vars);
+      free (vars);
+    }
+
+  /* POSIX.2 does not allow function names and definitions to be output when
+     `set' is invoked without options (PASC Interp #202). */
+  if (posixly_correct == 0)
+    {
+      vars = all_shell_functions ();
+      if (vars)
+	{
+	  print_func_list (vars);
+	  free (vars);
+	}
+    }
+}
+
+void
+set_shellopts ()
+{
+  char *value;
+  char tflag[N_O_OPTIONS];
+  int vsize, i, vptr, *ip, exported;
+  SHELL_VAR *v;
+
+  for (vsize = i = 0; o_options[i].name; i++)
+    {
+      tflag[i] = 0;
+      if (o_options[i].letter)
+	{
+	  ip = find_flag (o_options[i].letter);
+	  if (ip && *ip)
+	    {
+	      vsize += strlen (o_options[i].name) + 1;
+	      tflag[i] = 1;
+	    }
+	}
+      else if (GET_BINARY_O_OPTION_VALUE (i, o_options[i].name))
+	{
+	  vsize += strlen (o_options[i].name) + 1;
+	  tflag[i] = 1;
+	}
+    }
+
+  value = (char *)xmalloc (vsize + 1);
+
+  for (i = vptr = 0; o_options[i].name; i++)
+    {
+      if (tflag[i])
+	{
+	  strcpy (value + vptr, o_options[i].name);
+	  vptr += strlen (o_options[i].name);
+	  value[vptr++] = ':';
+	}
+    }
+
+  if (vptr)
+    vptr--;			/* cut off trailing colon */
+  value[vptr] = '\0';
+
+  v = find_variable ("SHELLOPTS");
+
+  /* Turn off the read-only attribute so we can bind the new value, and
+     note whether or not the variable was exported. */
+  if (v)
+    {
+      VUNSETATTR (v, att_readonly);
+      exported = exported_p (v);
+    }
+  else
+    exported = 0;
+
+  v = bind_variable ("SHELLOPTS", value, 0);
+
+  /* Turn the read-only attribute back on, and turn off the export attribute
+     if it was set implicitly by mark_modified_vars and SHELLOPTS was not
+     exported before we bound the new value. */
+  VSETATTR (v, att_readonly);
+  if (mark_modified_vars && exported == 0 && exported_p (v))
+    VUNSETATTR (v, att_exported);
+
+  free (value);
+}
+
+void
+parse_shellopts (value)
+     char *value;
+{
+  char *vname;
+  int vptr;
+
+  vptr = 0;
+  while (vname = extract_colon_unit (value, &vptr))
+    {
+      set_minus_o_option (FLAG_ON, vname);
+      free (vname);
+    }
+}
+
+void
+initialize_shell_options (no_shellopts)
+     int no_shellopts;
+{
+  char *temp;
+  SHELL_VAR *var;
+
+  if (no_shellopts == 0)
+    {
+      var = find_variable ("SHELLOPTS");
+      /* set up any shell options we may have inherited. */
+      if (var && imported_p (var))
+	{
+	  temp = (array_p (var) || assoc_p (var)) ? (char *)NULL : savestring (value_cell (var));
+	  if (temp)
+	    {
+	      parse_shellopts (temp);
+	      free (temp);
+	    }
+	}
+    }
+
+  /* Set up the $SHELLOPTS variable. */
+  set_shellopts ();
+}
+
+/* Reset the values of the -o options that are not also shell flags.  This is
+   called from execute_cmd.c:initialize_subshell() when setting up a subshell
+   to run an executable shell script without a leading `#!'. */
+void
+reset_shell_options ()
+{
+#if defined (HISTORY)
+  remember_on_history = enable_history_list = 1;
+#endif
+  ignoreeof = 0;
+}
+
+/* Set some flags from the word values in the input list.  If LIST is empty,
+   then print out the values of the variables instead.  If LIST contains
+   non-flags, then set $1 - $9 to the successive words of LIST. */
+int
+set_builtin (list)
+     WORD_LIST *list;
+{
+  int on_or_off, flag_name, force_assignment, opts_changed, rv, r;
+  register char *arg;
+  char s[3];
+
+  if (list == 0)
+    {
+      print_all_shell_variables ();
+      return (sh_chkwrite (EXECUTION_SUCCESS));
+    }
+
+  /* Check validity of flag arguments. */
+  rv = EXECUTION_SUCCESS;
+  reset_internal_getopt ();
+  while ((flag_name = internal_getopt (list, optflags)) != -1)
+    {
+      switch (flag_name)
+	{
+	  case '?':
+	    builtin_usage ();
+	    return (list_optopt == '?' ? EXECUTION_SUCCESS : EX_USAGE);
+	  default:
+	    break;
+	}
+    }
+    
+  /* Do the set command.  While the list consists of words starting with
+     '-' or '+' treat them as flags, otherwise, start assigning them to
+     $1 ... $n. */
+  for (force_assignment = opts_changed = 0; list; )
+    {
+      arg = list->word->word;
+
+      /* If the argument is `--' or `-' then signal the end of the list
+	 and remember the remaining arguments. */
+      if (arg[0] == '-' && (!arg[1] || (arg[1] == '-' && !arg[2])))
+	{
+	  list = list->next;
+
+	  /* `set --' unsets the positional parameters. */
+	  if (arg[1] == '-')
+	    force_assignment = 1;
+
+	  /* Until told differently, the old shell behaviour of
+	     `set - [arg ...]' being equivalent to `set +xv [arg ...]'
+	     stands.  Posix.2 says the behaviour is marked as obsolescent. */
+	  else
+	    {
+	      change_flag ('x', '+');
+	      change_flag ('v', '+');
+	      opts_changed = 1;
+	    }
+
+	  break;
+	}
+
+      if ((on_or_off = *arg) && (on_or_off == '-' || on_or_off == '+'))
+	{
+	  while (flag_name = *++arg)
+	    {
+	      if (flag_name == '?')
+		{
+		  builtin_usage ();
+		  return (EXECUTION_SUCCESS);
+		}
+	      else if (flag_name == 'o') /* -+o option-name */
+		{
+		  char *option_name;
+		  WORD_LIST *opt;
+
+		  opt = list->next;
+
+		  if (opt == 0)
+		    {
+		      list_minus_o_opts (-1, (on_or_off == '+'));
+		      rv = sh_chkwrite (rv);
+		      continue;
+		    }
+
+		  option_name = opt->word->word;
+
+		  if (option_name == 0 || *option_name == '\0' ||
+		      *option_name == '-' || *option_name == '+')
+		    {
+		      list_minus_o_opts (-1, (on_or_off == '+'));
+		      continue;
+		    }
+		  list = list->next; /* Skip over option name. */
+
+		  opts_changed = 1;
+		  if ((r = set_minus_o_option (on_or_off, option_name)) != EXECUTION_SUCCESS)
+		    {
+		      set_shellopts ();
+		      return (r);
+		    }
+		}
+	      else if (change_flag (flag_name, on_or_off) == FLAG_ERROR)
+		{
+		  s[0] = on_or_off;
+		  s[1] = flag_name;
+		  s[2] = '\0';
+		  sh_invalidopt (s);
+		  builtin_usage ();
+		  set_shellopts ();
+		  return (EXECUTION_FAILURE);
+		}
+	      opts_changed = 1;
+	    }
+	}
+      else
+	{
+	  break;
+	}
+      list = list->next;
+    }
+
+  /* Assigning $1 ... $n */
+  if (list || force_assignment)
+    remember_args (list, 1);
+  /* Set up new value of $SHELLOPTS */
+  if (opts_changed)
+    set_shellopts ();
+  return (rv);
+}
+
+#line 735 "./set.def"
+
+#define NEXT_VARIABLE()	any_failed++; list = list->next; continue;
+
+int
+unset_builtin (list)
+  WORD_LIST *list;
+{
+  int unset_function, unset_variable, unset_array, opt, any_failed;
+  char *name;
+
+  unset_function = unset_variable = unset_array = any_failed = 0;
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "fv")) != -1)
+    {
+      switch (opt)
+	{
+	case 'f':
+	  unset_function = 1;
+	  break;
+	case 'v':
+	  unset_variable = 1;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+  if (unset_function && unset_variable)
+    {
+      builtin_error (_("cannot simultaneously unset a function and a variable"));
+      return (EXECUTION_FAILURE);
+    }
+
+  while (list)
+    {
+      SHELL_VAR *var;
+      int tem;
+#if defined (ARRAY_VARS)
+      char *t;
+#endif
+
+      name = list->word->word;
+
+#if defined (ARRAY_VARS)
+      unset_array = 0;
+      if (!unset_function && valid_array_reference (name))
+	{
+	  t = strchr (name, '[');
+	  *t++ = '\0';
+	  unset_array++;
+	}
+#endif
+
+      /* Bash allows functions with names which are not valid identifiers
+	 to be created when not in posix mode, so check only when in posix
+	 mode when unsetting a function. */
+      if (((unset_function && posixly_correct) || !unset_function) && legal_identifier (name) == 0)
+	{
+	  sh_invalidid (name);
+	  NEXT_VARIABLE ();
+	}
+
+      var = unset_function ? find_function (name) : find_variable (name);
+
+      if (var && !unset_function && non_unsettable_p (var))
+	{
+	  builtin_error (_("%s: cannot unset"), name);
+	  NEXT_VARIABLE ();
+	}
+
+      /* Posix.2 says that unsetting readonly variables is an error. */
+      if (var && readonly_p (var))
+	{
+	  builtin_error (_("%s: cannot unset: readonly %s"),
+			 name, unset_function ? "function" : "variable");
+	  NEXT_VARIABLE ();
+	}
+
+      /* Unless the -f option is supplied, the name refers to a variable. */
+#if defined (ARRAY_VARS)
+      if (var && unset_array)
+	{
+	  if (array_p (var) == 0 && assoc_p (var) == 0)
+	    {
+	      builtin_error (_("%s: not an array variable"), name);
+	      NEXT_VARIABLE ();
+	    }
+	  else
+	    {
+	      tem = unbind_array_element (var, t);
+	      if (tem == -1)
+		any_failed++;
+	    }
+	}
+      else
+#endif /* ARRAY_VARS */
+      tem = unset_function ? unbind_func (name) : unbind_variable (name);
+
+      /* This is what Posix.2 draft 11+ says.  ``If neither -f nor -v
+	 is specified, the name refers to a variable; if a variable by
+	 that name does not exist, a function by that name, if any,
+	 shall be unset.'' */
+      if (tem == -1 && !unset_function && !unset_variable)
+	tem = unbind_func (name);
+
+      /* SUSv3, POSIX.1-2001 say:  ``Unsetting a variable or function that
+	 was not previously set shall not be considered an error.'' */
+
+      if (unset_function == 0)
+	stupidly_hack_special_variables (name);
+
+      list = list->next;
+    }
+
+  return (any_failed ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
+}
diff -Nru bash-4.0-orig/builtins/setattr.c bash-4.0/builtins/setattr.c
--- bash-4.0-orig/builtins/setattr.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/setattr.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,459 @@
+/* setattr.c, created from setattr.def. */
+#line 22 "./setattr.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+extern int posixly_correct;
+extern int array_needs_making;
+extern char *this_command_name;
+extern sh_builtin_func_t *this_shell_builtin;
+
+#ifdef ARRAY_VARS
+extern int declare_builtin __P((WORD_LIST *));
+#endif
+
+#define READONLY_OR_EXPORT \
+  (this_shell_builtin == readonly_builtin || this_shell_builtin == export_builtin)
+
+#line 70 "./setattr.def"
+
+/* For each variable name in LIST, make that variable appear in the
+   environment passed to simple commands.  If there is no LIST, then
+   print all such variables.  An argument of `-n' says to remove the
+   exported attribute from variables named in LIST.  An argument of
+  -f indicates that the names present in LIST refer to functions. */
+int
+export_builtin (list)
+     register WORD_LIST *list;
+{
+  return (set_or_show_attributes (list, att_exported, 0));
+}
+
+#line 103 "./setattr.def"
+
+/* For each variable name in LIST, make that variable readonly.  Given an
+   empty LIST, print out all existing readonly variables. */
+int
+readonly_builtin (list)
+     register WORD_LIST *list;
+{
+  return (set_or_show_attributes (list, att_readonly, 0));
+}
+
+#if defined (ARRAY_VARS)
+#  define ATTROPTS	"aAfnp"
+#else
+#  define ATTROPTS	"fnp"
+#endif
+
+/* For each variable name in LIST, make that variable have the specified
+   ATTRIBUTE.  An arg of `-n' says to remove the attribute from the the
+   remaining names in LIST (doesn't work for readonly). */
+int
+set_or_show_attributes (list, attribute, nodefs)
+     register WORD_LIST *list;
+     int attribute, nodefs;
+{
+  register SHELL_VAR *var;
+  int assign, undo, any_failed, assign_error, opt;
+  int functions_only, arrays_only, assoc_only;
+  int aflags;
+  char *name;
+#if defined (ARRAY_VARS)
+  WORD_LIST *nlist, *tlist;
+  WORD_DESC *w;
+#endif
+
+  functions_only = arrays_only = assoc_only = 0;
+  undo = any_failed = assign_error = 0;
+  /* Read arguments from the front of the list. */
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, ATTROPTS)) != -1)
+    {
+      switch (opt)
+	{
+	  case 'n':
+	    undo = 1;
+	    break;
+	  case 'f':
+	    functions_only = 1;
+	    break;
+#if defined (ARRAY_VARS)
+	  case 'a':
+	    arrays_only = 1;
+	    break;
+	  case 'A':
+	    assoc_only = 1;
+	    break;
+#endif
+	  case 'p':
+	    break;
+	  default:
+	    builtin_usage ();
+	    return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  if (list)
+    {
+      if (attribute & att_exported)
+	array_needs_making = 1;
+
+      /* Cannot undo readonly status, silently disallowed. */
+      if (undo && (attribute & att_readonly))
+	attribute &= ~att_readonly;
+
+      while (list)
+	{
+	  name = list->word->word;
+
+	  if (functions_only)		/* xxx -f name */
+	    {
+	      var = find_function (name);
+	      if (var == 0)
+		{
+		  builtin_error (_("%s: not a function"), name);
+		  any_failed++;
+		}
+	      else
+		SETVARATTR (var, attribute, undo);
+
+	      list = list->next;
+	      continue;
+	    }
+
+	  /* xxx [-np] name[=value] */
+	  assign = assignment (name, 0);
+
+	  aflags = 0;
+	  if (assign)
+	    {
+	      name[assign] = '\0';
+	      if (name[assign - 1] == '+')
+		{
+		  aflags |= ASS_APPEND;
+		  name[assign - 1] = '\0';
+		}
+	    }
+
+	  if (legal_identifier (name) == 0)
+	    {
+	      sh_invalidid (name);
+	      if (assign)
+		assign_error++;
+	      else
+		any_failed++;
+	      list = list->next;
+	      continue;
+	    }
+
+	  if (assign)	/* xxx [-np] name=value */
+	    {
+	      name[assign] = '=';
+	      if (aflags & ASS_APPEND)
+		name[assign - 1] = '+';
+#if defined (ARRAY_VARS)
+	      /* Let's try something here.  Turn readonly -a xxx=yyy into
+		 declare -ra xxx=yyy and see what that gets us. */
+	      if (arrays_only || assoc_only)
+		{
+		  tlist = list->next;
+		  list->next = (WORD_LIST *)NULL;
+		  w = arrays_only ? make_word ("-ra") : make_word ("-rA");
+		  nlist = make_word_list (w, list);
+		  opt = declare_builtin (nlist);
+		  if (opt != EXECUTION_SUCCESS)
+		    assign_error++;
+		  list->next = tlist;
+		  dispose_word (w);
+		  free (nlist);
+		}
+	      else
+#endif
+	      /* This word has already been expanded once with command
+		 and parameter expansion.  Call do_assignment_no_expand (),
+		 which does not do command or parameter substitution.  If
+		 the assignment is not performed correctly, flag an error. */
+	      if (do_assignment_no_expand (name) == 0)
+		assign_error++;
+	      name[assign] = '\0';
+	      if (aflags & ASS_APPEND)
+		name[assign - 1] = '\0';
+	    }
+
+	  set_var_attribute (name, attribute, undo);
+	  list = list->next;
+	}
+    }
+  else
+    {
+      SHELL_VAR **variable_list;
+      register int i;
+
+      if ((attribute & att_function) || functions_only)
+	{
+	  variable_list = all_shell_functions ();
+	  if (attribute != att_function)
+	    attribute &= ~att_function;	/* so declare -xf works, for example */
+	}
+      else
+	variable_list = all_shell_variables ();
+
+#if defined (ARRAY_VARS)
+      if (attribute & att_array)
+	{
+	  arrays_only++;
+	  if (attribute != att_array)
+	    attribute &= ~att_array;
+	}
+      else if (attribute & att_assoc)
+	{
+	  assoc_only++;
+	  if (attribute != att_assoc)
+	    attribute &= ~att_assoc;
+	}
+#endif
+
+      if (variable_list)
+	{
+	  for (i = 0; var = variable_list[i]; i++)
+	    {
+#if defined (ARRAY_VARS)
+	      if (arrays_only && array_p (var) == 0)
+		continue;
+	      else if (assoc_only && assoc_p (var) == 0)
+		continue;
+#endif
+	      if ((var->attributes & attribute))
+		{
+		  show_var_attributes (var, READONLY_OR_EXPORT, nodefs);
+		  if (any_failed = sh_chkwrite (any_failed))
+		    break;
+		}
+	    }
+	  free (variable_list);
+	}
+    }
+
+  return (assign_error ? EX_BADASSIGN
+		       : ((any_failed == 0) ? EXECUTION_SUCCESS
+  					    : EXECUTION_FAILURE));
+}
+
+/* Show all variable variables (v == 1) or functions (v == 0) with
+   attributes. */
+int
+show_all_var_attributes (v, nodefs)
+     int v, nodefs;
+{
+  SHELL_VAR **variable_list, *var;
+  int any_failed;
+  register int i;
+
+  variable_list = v ? all_shell_variables () : all_shell_functions ();
+  if (variable_list == 0)  
+    return (EXECUTION_SUCCESS);
+
+  for (i = any_failed = 0; var = variable_list[i]; i++)
+    {
+      show_var_attributes (var, READONLY_OR_EXPORT, nodefs);
+      if (any_failed = sh_chkwrite (any_failed))
+        break;
+    }
+  free (variable_list);
+  return (any_failed == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
+}
+
+/* Show the attributes for shell variable VAR.  If NODEFS is non-zero,
+   don't show function definitions along with the name.  If PATTR is
+   non-zero, it indicates we're being called from `export' or `readonly'.
+   In POSIX mode, this prints the name of the calling builtin (`export'
+   or `readonly') instead of `declare', and doesn't print function defs
+   when called by `export' or `readonly'. */
+int
+show_var_attributes (var, pattr, nodefs)
+     SHELL_VAR *var;
+     int pattr, nodefs;
+{
+  char flags[16], *x;
+  int i;
+
+  i = 0;
+
+  /* pattr == 0 means we are called from `declare'. */
+  if (pattr == 0 || posixly_correct == 0)
+    {
+#if defined (ARRAY_VARS)
+      if (array_p (var))
+	flags[i++] = 'a';
+
+      if (assoc_p (var))
+	flags[i++] = 'A';
+#endif
+
+      if (function_p (var))
+	flags[i++] = 'f';
+
+      if (integer_p (var))
+	flags[i++] = 'i';
+
+      if (readonly_p (var))
+	flags[i++] = 'r';
+
+      if (trace_p (var))
+	flags[i++] = 't';
+
+      if (exported_p (var))
+	flags[i++] = 'x';
+
+      if (capcase_p (var))
+	flags[i++] = 'c';
+
+      if (lowercase_p (var))
+	flags[i++] = 'l';
+
+      if (uppercase_p (var))
+	flags[i++] = 'u';
+    }
+  else
+    {
+#if defined (ARRAY_VARS)
+      if (array_p (var))
+	flags[i++] = 'a';
+
+      if (assoc_p (var))
+	flags[i++] = 'A';
+#endif
+
+      if (function_p (var))
+	flags[i++] = 'f';
+    }
+
+  flags[i] = '\0';
+
+  /* If we're printing functions with definitions, print the function def
+     first, then the attributes, instead of printing output that can't be
+     reused as input to recreate the current state. */
+  if (function_p (var) && nodefs == 0 && (pattr == 0 || posixly_correct == 0))
+    {
+      printf ("%s\n", named_function_string (var->name, function_cell (var), FUNC_MULTILINE|FUNC_EXTERNAL));
+      nodefs++;
+      if (pattr == 0 && i == 1 && flags[0] == 'f')
+	return 0;		/* don't print `declare -f name' */
+    }
+
+  if (pattr == 0 || posixly_correct == 0)
+    printf ("declare -%s ", i ? flags : "-");
+  else if (i)
+    printf ("%s -%s ", this_command_name, flags);
+  else
+    printf ("%s ", this_command_name);
+
+#if defined (ARRAY_VARS)
+  if (array_p (var))
+    print_array_assignment (var, 1);
+  else if (assoc_p (var))
+    print_assoc_assignment (var, 1);
+  else
+#endif
+  /* force `readonly' and `export' to not print out function definitions
+     when in POSIX mode. */
+  if (nodefs || (function_p (var) && pattr != 0 && posixly_correct))
+    printf ("%s\n", var->name);
+  else if (function_p (var))
+    printf ("%s\n", named_function_string (var->name, function_cell (var), FUNC_MULTILINE|FUNC_EXTERNAL));
+  else if (invisible_p (var))
+    printf ("%s\n", var->name);
+  else
+    {
+      x = sh_double_quote (var_isset (var) ? value_cell (var) : "");
+      printf ("%s=%s\n", var->name, x);
+      free (x);
+    }
+  return (0);
+}
+
+int
+show_name_attributes (name, nodefs)
+     char *name;
+     int nodefs;
+{
+  SHELL_VAR *var;
+
+  var = find_variable_internal (name, 1);
+
+  if (var && invisible_p (var) == 0)
+    {
+      show_var_attributes (var, READONLY_OR_EXPORT, nodefs);
+      return (0);
+    }
+  else
+    return (1);
+}
+
+void
+set_var_attribute (name, attribute, undo)
+     char *name;
+     int attribute, undo;
+{
+  SHELL_VAR *var, *tv;
+  char *tvalue;
+
+  if (undo)
+    var = find_variable (name);
+  else
+    {
+      tv = find_tempenv_variable (name);
+      /* XXX -- need to handle case where tv is a temp variable in a
+	 function-scope context, since function_env has been merged into
+	 the local variables table. */
+      if (tv && tempvar_p (tv))
+	{
+	  tvalue = var_isset (tv) ? savestring (value_cell (tv)) : savestring ("");
+
+	  var = bind_variable (tv->name, tvalue, 0);
+	  var->attributes |= tv->attributes & ~att_tempvar;
+	  VSETATTR (tv, att_propagate);
+	  if (var->context != 0)
+	    VSETATTR (var, att_propagate);
+	  SETVARATTR (tv, attribute, undo);	/* XXX */
+
+	  stupidly_hack_special_variables (tv->name);
+
+	  free (tvalue);
+	}
+      else
+	{
+	  var = find_variable_internal (name, 0);
+	  if (var == 0)
+	    {
+	      var = bind_variable (name, (char *)NULL, 0);
+	      VSETATTR (var, att_invisible);
+	    }
+	  else if (var->context != 0)
+	    VSETATTR (var, att_propagate);
+	}
+    }
+
+  if (var)
+    SETVARATTR (var, attribute, undo);
+
+  if (var && (exported_p (var) || (attribute & att_exported)))
+    array_needs_making++;	/* XXX */
+}
diff -Nru bash-4.0-orig/builtins/shift.c bash-4.0/builtins/shift.c
--- bash-4.0-orig/builtins/shift.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/shift.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,72 @@
+/* shift.c, created from shift.def. */
+#line 22 "./shift.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+
+#line 49 "./shift.def"
+
+int print_shift_error;
+
+/* Shift the arguments ``left''.  Shift DOLLAR_VARS down then take one
+   off of REST_OF_ARGS and place it into DOLLAR_VARS[9].  If LIST has
+   anything in it, it is a number which says where to start the
+   shifting.  Return > 0 if `times' > $#, otherwise 0. */
+int
+shift_builtin (list)
+     WORD_LIST *list;
+{
+  intmax_t times;
+  register int count;
+  WORD_LIST *temp;
+
+  if (get_numeric_arg (list, 0, &times) == 0)
+    return (EXECUTION_FAILURE);
+
+  if (times == 0)
+    return (EXECUTION_SUCCESS);
+  else if (times < 0)
+    {
+      sh_erange (list ? list->word->word : NULL, _("shift count"));
+      return (EXECUTION_FAILURE);
+    }
+  else if (times > number_of_args ())
+    {
+      if (print_shift_error)
+	sh_erange (list ? list->word->word : NULL, _("shift count"));
+      return (EXECUTION_FAILURE);
+    }
+
+  while (times-- > 0)
+    {
+      if (dollar_vars[1])
+	free (dollar_vars[1]);
+
+      for (count = 1; count < 9; count++)
+	dollar_vars[count] = dollar_vars[count + 1];
+
+      if (rest_of_args)
+	{
+	  temp = rest_of_args;
+	  dollar_vars[9] = savestring (temp->word->word);
+	  rest_of_args = rest_of_args->next;
+	  temp->next = (WORD_LIST *)NULL;
+	  dispose_words (temp);
+	}
+      else
+	dollar_vars[9] = (char *)NULL;
+    }
+  return (EXECUTION_SUCCESS);
+}
diff -Nru bash-4.0-orig/builtins/shopt.c bash-4.0/builtins/shopt.c
--- bash-4.0-orig/builtins/shopt.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/shopt.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,543 @@
+/* shopt.c, created from shopt.def. */
+#line 22 "./shopt.def"
+
+#line 43 "./shopt.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+
+#include "version.h"
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../flags.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#if defined (HISTORY)
+#  include "../bashhist.h"
+#endif
+
+#define UNSETOPT	0
+#define SETOPT		1
+
+#define OPTFMT		"%-15s\t%s\n"
+
+extern int allow_null_glob_expansion, fail_glob_expansion, glob_dot_filenames;
+extern int cdable_vars, mail_warning, source_uses_path;
+extern int no_exit_on_failed_exec, print_shift_error;
+extern int check_hashed_filenames, promptvars;
+extern int cdspelling, expand_aliases;
+extern int extended_quote;
+extern int check_window_size;
+extern int glob_ignore_case, match_ignore_case;
+extern int hup_on_exit;
+extern int xpg_echo;
+extern int gnu_error_format;
+extern int check_jobs_at_exit;
+extern int autocd;
+extern int glob_star;
+
+#if defined (EXTENDED_GLOB)
+extern int extended_glob;
+#endif
+
+#if defined (READLINE)
+extern int hist_verify, history_reediting, perform_hostname_completion;
+extern int no_empty_command_completion;
+extern int force_fignore;
+extern int dircomplete_spelling;
+
+extern int enable_hostname_completion __P((int));
+#endif
+
+#if defined (PROGRAMMABLE_COMPLETION)
+extern int prog_completion_enabled;
+#endif
+
+#if defined (RESTRICTED_SHELL)
+extern char *shell_name;
+#endif
+
+#if defined (DEBUGGER)
+extern int debugging_mode;
+#endif
+
+static void shopt_error __P((char *));
+
+static int set_shellopts_after_change __P((int));
+
+static int set_compatibility_level __P((int));
+
+#if defined (RESTRICTED_SHELL)
+static int set_restricted_shell __P((int));
+#endif
+
+static int shopt_login_shell;
+static int shopt_compat31;
+static int shopt_compat32;
+
+typedef int shopt_set_func_t __P((int));
+
+static struct {
+  char *name;
+  int  *value;
+  shopt_set_func_t *set_func;
+} shopt_vars[] = {
+  { "autocd", &autocd, (shopt_set_func_t *)NULL },
+  { "cdable_vars", &cdable_vars, (shopt_set_func_t *)NULL },
+  { "cdspell", &cdspelling, (shopt_set_func_t *)NULL },
+  { "checkhash", &check_hashed_filenames, (shopt_set_func_t *)NULL },
+#if defined (JOB_CONTROL)
+  { "checkjobs", &check_jobs_at_exit, (shopt_set_func_t *)NULL },
+#endif
+  { "checkwinsize", &check_window_size, (shopt_set_func_t *)NULL },
+#if defined (HISTORY)
+  { "cmdhist", &command_oriented_history, (shopt_set_func_t *)NULL },
+#endif
+  { "compat31", &shopt_compat31, set_compatibility_level },
+  { "compat32", &shopt_compat32, set_compatibility_level },
+#if defined (READLINE)
+  { "dirspell", &dircomplete_spelling, (shopt_set_func_t *)NULL },
+#endif
+  { "dotglob", &glob_dot_filenames, (shopt_set_func_t *)NULL },
+  { "execfail", &no_exit_on_failed_exec, (shopt_set_func_t *)NULL },
+  { "expand_aliases", &expand_aliases, (shopt_set_func_t *)NULL },
+#if defined (DEBUGGER)
+  { "extdebug", &debugging_mode, (shopt_set_func_t *)NULL },
+#endif
+#if defined (EXTENDED_GLOB)
+  { "extglob", &extended_glob, (shopt_set_func_t *)NULL },
+#endif
+  { "extquote", &extended_quote, (shopt_set_func_t *)NULL },
+  { "failglob", &fail_glob_expansion, (shopt_set_func_t *)NULL },
+#if defined (READLINE)
+  { "force_fignore", &force_fignore, (shopt_set_func_t *)NULL },
+#endif
+  { "globstar", &glob_star, (shopt_set_func_t *)NULL },
+  { "gnu_errfmt", &gnu_error_format, (shopt_set_func_t *)NULL },
+#if defined (HISTORY)
+  { "histappend", &force_append_history, (shopt_set_func_t *)NULL },
+#endif
+#if defined (READLINE)
+  { "histreedit", &history_reediting, (shopt_set_func_t *)NULL },
+  { "histverify", &hist_verify, (shopt_set_func_t *)NULL },
+  { "hostcomplete", &perform_hostname_completion, enable_hostname_completion },
+#endif
+  { "huponexit", &hup_on_exit, (shopt_set_func_t *)NULL },
+  { "interactive_comments", &interactive_comments, set_shellopts_after_change },
+#if defined (HISTORY)
+  { "lithist", &literal_history, (shopt_set_func_t *)NULL },
+#endif
+  { "login_shell", &shopt_login_shell, set_login_shell },
+  { "mailwarn", &mail_warning, (shopt_set_func_t *)NULL },
+#if defined (READLINE)
+  { "no_empty_cmd_completion", &no_empty_command_completion, (shopt_set_func_t *)NULL },
+#endif
+  { "nocaseglob", &glob_ignore_case, (shopt_set_func_t *)NULL },
+  { "nocasematch", &match_ignore_case, (shopt_set_func_t *)NULL },
+  { "nullglob",	&allow_null_glob_expansion, (shopt_set_func_t *)NULL },
+#if defined (PROGRAMMABLE_COMPLETION)
+  { "progcomp", &prog_completion_enabled, (shopt_set_func_t *)NULL },
+#endif
+  { "promptvars", &promptvars, (shopt_set_func_t *)NULL },
+#if defined (RESTRICTED_SHELL)
+  { "restricted_shell", &restricted_shell, set_restricted_shell },
+#endif
+  { "shift_verbose", &print_shift_error, (shopt_set_func_t *)NULL },
+  { "sourcepath", &source_uses_path, (shopt_set_func_t *)NULL },
+  { "xpg_echo", &xpg_echo, (shopt_set_func_t *)NULL },
+  { (char *)0, (int *)0, (shopt_set_func_t *)NULL }
+};
+
+static const char * const on = "on";
+static const char * const off = "off";
+
+static int find_shopt __P((char *));
+static int toggle_shopts __P((int, WORD_LIST *, int));
+static void print_shopt __P((char *, int, int));
+static int list_shopts __P((WORD_LIST *, int));
+static int list_some_shopts __P((int, int));
+static int list_shopt_o_options __P((WORD_LIST *, int));
+static int list_some_o_options __P((int, int));
+static int set_shopt_o_options __P((int, WORD_LIST *, int));
+
+#define SFLAG	0x01
+#define UFLAG	0x02
+#define QFLAG	0x04
+#define OFLAG	0x08
+#define PFLAG	0x10
+
+int
+shopt_builtin (list)
+     WORD_LIST *list;
+{
+  int opt, flags, rval;
+
+  flags = 0;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "psuoq")) != -1)
+    {
+      switch (opt)
+	{
+	case 's':
+	  flags |= SFLAG;
+	  break;
+	case 'u':
+	  flags |= UFLAG;
+	  break;
+	case 'q':
+	  flags |= QFLAG;
+	  break;
+	case 'o':
+	  flags |= OFLAG;
+	  break;
+	case 'p':
+	  flags |= PFLAG;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  if ((flags & (SFLAG|UFLAG)) == (SFLAG|UFLAG))
+    {
+      builtin_error (_("cannot set and unset shell options simultaneously"));
+      return (EXECUTION_FAILURE);
+    }
+
+  rval = EXECUTION_SUCCESS;
+  if ((flags & OFLAG) && ((flags & (SFLAG|UFLAG)) == 0))	/* shopt -o */
+    rval = list_shopt_o_options (list, flags);
+  else if (list && (flags & OFLAG))		/* shopt -so args */
+    rval = set_shopt_o_options ((flags & SFLAG) ? FLAG_ON : FLAG_OFF, list, flags & QFLAG);
+  else if (flags & OFLAG)	/* shopt -so */
+    rval = list_some_o_options ((flags & SFLAG) ? 1 : 0, flags);
+  else if (list && (flags & (SFLAG|UFLAG)))	/* shopt -su args */
+    rval = toggle_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, list, flags & QFLAG);
+  else if ((flags & (SFLAG|UFLAG)) == 0)	/* shopt [args] */
+    rval = list_shopts (list, flags);
+  else						/* shopt -su */
+    rval = list_some_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, flags);
+  return (rval);
+}
+
+/* Reset the options managed by `shopt' to the values they would have at
+   shell startup. */
+void
+reset_shopt_options ()
+{
+  allow_null_glob_expansion = glob_dot_filenames = 0;
+  cdable_vars = mail_warning = 0;
+  no_exit_on_failed_exec = print_shift_error = 0;
+  check_hashed_filenames = cdspelling = expand_aliases = check_window_size = 0;
+
+  source_uses_path = promptvars = 1;
+
+#if defined (EXTENDED_GLOB)
+  extended_glob = 0;
+#endif
+
+#if defined (HISTORY)
+  literal_history = force_append_history = 0;
+  command_oriented_history = 1;
+#endif
+
+#if defined (READLINE)
+  hist_verify = history_reediting = 0;
+  perform_hostname_completion = 1;
+#endif
+
+  shopt_login_shell = login_shell;
+}
+
+static int
+find_shopt (name)
+     char *name;
+{
+  int i;
+
+  for (i = 0; shopt_vars[i].name; i++)
+    if (STREQ (name, shopt_vars[i].name))
+      return i;
+  return -1;
+}
+
+static void
+shopt_error (s)
+     char *s;
+{
+  builtin_error (_("%s: invalid shell option name"), s);
+}
+
+static int
+toggle_shopts (mode, list, quiet)
+     int mode;
+     WORD_LIST *list;
+     int quiet;
+{
+  WORD_LIST *l;
+  int ind, rval;
+
+  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
+    {
+      ind = find_shopt (l->word->word);
+      if (ind < 0)
+	{
+	  shopt_error (l->word->word);
+	  rval = EXECUTION_FAILURE;
+	}
+      else
+	{
+	  *shopt_vars[ind].value = mode;	/* 1 for set, 0 for unset */
+	  if (shopt_vars[ind].set_func)
+	    (*shopt_vars[ind].set_func) (mode);
+	}
+    }
+  return (rval);
+}
+
+static void
+print_shopt (name, val, flags)
+     char *name;
+     int val, flags;
+{
+  if (flags & PFLAG)
+    printf ("shopt %s %s\n", val ? "-s" : "-u", name);
+  else
+    printf (OPTFMT, name, val ? on : off);
+}
+
+/* List the values of all or any of the `shopt' options.  Returns 0 if
+   all were listed or all variables queried were on; 1 otherwise. */
+static int
+list_shopts (list, flags)
+     WORD_LIST *list;
+     int flags;
+{
+  WORD_LIST *l;
+  int i, val, rval;
+
+  if (list == 0)
+    {
+      for (i = 0; shopt_vars[i].name; i++)
+	{
+	  val = *shopt_vars[i].value;
+	  if ((flags & QFLAG) == 0)
+	    print_shopt (shopt_vars[i].name, val, flags);
+	}
+      return (sh_chkwrite (EXECUTION_SUCCESS));
+    }
+
+  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
+    {
+      i = find_shopt (l->word->word);
+      if (i < 0)
+	{
+	  shopt_error (l->word->word);
+	  rval = EXECUTION_FAILURE;
+	  continue;
+	}
+      val = *shopt_vars[i].value;
+      if (val == 0)
+	rval = EXECUTION_FAILURE;
+      if ((flags & QFLAG) == 0)
+	print_shopt (l->word->word, val, flags);
+    }
+
+  return (sh_chkwrite (rval));
+}
+
+static int
+list_some_shopts (mode, flags)
+     int mode, flags;
+{
+  int val, i;
+
+  for (i = 0; shopt_vars[i].name; i++)
+    {
+      val = *shopt_vars[i].value;
+      if (((flags & QFLAG) == 0) && mode == val)
+	print_shopt (shopt_vars[i].name, val, flags);
+    }
+  return (sh_chkwrite (EXECUTION_SUCCESS));
+}
+
+static int
+list_shopt_o_options (list, flags)
+     WORD_LIST *list;
+     int flags;
+{
+  WORD_LIST *l;
+  int val, rval;
+
+  if (list == 0)
+    {
+      if ((flags & QFLAG) == 0)
+	list_minus_o_opts (-1, (flags & PFLAG));
+      return (sh_chkwrite (EXECUTION_SUCCESS));
+    }
+
+  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
+    {
+      val = minus_o_option_value (l->word->word);
+      if (val == -1)
+	{
+	  sh_invalidoptname (l->word->word);
+	  rval = EXECUTION_FAILURE;
+	  continue;
+	}
+      if (val == 0)
+	rval = EXECUTION_FAILURE;
+      if ((flags & QFLAG) == 0)
+	{
+	  if (flags & PFLAG)
+	    printf ("set %co %s\n", val ? '-' : '+', l->word->word);
+	  else
+	    printf (OPTFMT, l->word->word, val ? on : off);
+	}
+    }
+  return (sh_chkwrite (rval));
+}
+
+static int
+list_some_o_options (mode, flags)
+     int mode, flags;
+{
+  if ((flags & QFLAG) == 0)
+    list_minus_o_opts (mode, (flags & PFLAG));
+  return (sh_chkwrite (EXECUTION_SUCCESS));
+}
+
+static int
+set_shopt_o_options (mode, list, quiet)
+     int mode;
+     WORD_LIST *list;
+     int quiet;
+{
+  WORD_LIST *l;
+  int rval;
+
+  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)
+    {
+      if (set_minus_o_option (mode, l->word->word) == EXECUTION_FAILURE)
+	rval = EXECUTION_FAILURE;
+    }
+  set_shellopts ();
+  return rval;
+}
+
+/* If we set or unset interactive_comments with shopt, make sure the
+   change is reflected in $SHELLOPTS. */
+static int
+set_shellopts_after_change (mode)
+     int mode;
+{
+  set_shellopts ();
+  return (0);
+}
+
+static int
+set_compatibility_level (mode)
+     int mode;
+{
+  /* Need to change logic here as we add more compatibility levels */
+  if (shopt_compat31)
+    shell_compatibility_level = 31;
+  else if (shopt_compat32)
+    shell_compatibility_level = 32;
+  else
+    shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
+  return 0;
+}
+
+#if defined (RESTRICTED_SHELL)
+/* Don't allow the value of restricted_shell to be modified. */
+
+static int
+set_restricted_shell (mode)
+     int mode;
+{
+  static int save_restricted = -1;
+
+  if (save_restricted == -1)
+    save_restricted = shell_is_restricted (shell_name);
+
+  restricted_shell = save_restricted;
+  return (0);
+}
+#endif /* RESTRICTED_SHELL */
+
+/* Not static so shell.c can call it to initialize shopt_login_shell */
+int
+set_login_shell (mode)
+     int mode;
+{
+  shopt_login_shell = login_shell != 0;
+  return (0);
+}
+
+char **
+get_shopt_options ()
+{
+  char **ret;
+  int n, i;
+
+  n = sizeof (shopt_vars) / sizeof (shopt_vars[0]);
+  ret = strvec_create (n + 1);
+  for (i = 0; shopt_vars[i].name; i++)
+    ret[i] = savestring (shopt_vars[i].name);
+  ret[i] = (char *)NULL;
+  return ret;
+}
+
+/*
+ * External interface for other parts of the shell.  NAME is a string option;
+ * MODE is 0 if we want to unset an option; 1 if we want to set an option.
+ * REUSABLE is 1 if we want to print output in a form that may be reused.
+ */
+int
+shopt_setopt (name, mode)
+     char *name;
+     int mode;
+{
+  WORD_LIST *wl;
+  int r;
+
+  wl = add_string_to_list (name, (WORD_LIST *)NULL);
+  r = toggle_shopts (mode, wl, 0);
+  dispose_words (wl);
+  return r;
+}
+
+int
+shopt_listopt (name, reusable)
+     char *name;
+     int reusable;
+{
+  int i;
+
+  if (name == 0)
+    return (list_shopts ((WORD_LIST *)NULL, reusable ? PFLAG : 0));
+
+  i = find_shopt (name);
+  if (i < 0)
+    {
+      shopt_error (name);
+      return (EXECUTION_FAILURE);
+    }
+
+  print_shopt (name, *shopt_vars[i].value, reusable ? PFLAG : 0);
+  return (sh_chkwrite (EXECUTION_SUCCESS));
+}
diff -Nru bash-4.0-orig/builtins/source.c bash-4.0/builtins/source.c
--- bash-4.0-orig/builtins/source.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/source.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,144 @@
+/* source.c, created from source.def. */
+#line 22 "./source.def"
+
+#line 37 "./source.def"
+
+#line 53 "./source.def"
+
+#include <config.h>
+
+#include "../bashtypes.h"
+#include "posixstat.h"
+#include "filecntl.h"
+#if ! defined(_MINIX) && defined (HAVE_SYS_FILE_H)
+#  include <sys/file.h>
+#endif
+#include <errno.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../flags.h"
+#include "../findcmd.h"
+#include "common.h"
+#include "bashgetopt.h"
+#include "../trap.h"
+
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+extern int posixly_correct;
+
+static void maybe_pop_dollar_vars __P((void));
+
+/* If non-zero, `.' uses $PATH to look up the script to be sourced. */
+int source_uses_path = 1;
+
+/* If non-zero, `.' looks in the current directory if the filename argument
+   is not found in the $PATH. */
+int source_searches_cwd = 1;
+
+/* If this . script is supplied arguments, we save the dollar vars and
+   replace them with the script arguments for the duration of the script's
+   execution.  If the script does not change the dollar vars, we restore
+   what we saved.  If the dollar vars are changed in the script, and we are
+   not executing a shell function, we leave the new values alone and free
+   the saved values. */
+static void
+maybe_pop_dollar_vars ()
+{
+  if (variable_context == 0 && (dollar_vars_changed () & ARGS_SETBLTIN))
+    dispose_saved_dollar_vars ();
+  else
+    pop_dollar_vars ();
+  if (debugging_mode)
+    pop_args ();	/* restore BASH_ARGC and BASH_ARGV */
+  set_dollar_vars_unchanged ();
+}
+
+/* Read and execute commands from the file passed as argument.  Guess what.
+   This cannot be done in a subshell, since things like variable assignments
+   take place in there.  So, I open the file, place it into a large string,
+   close the file, and then execute the string. */
+int
+source_builtin (list)
+     WORD_LIST *list;
+{
+  int result;
+  char *filename, *debug_trap;
+
+  if (no_options (list))
+    return (EX_USAGE);
+  list = loptend;
+
+  if (list == 0)
+    {
+      builtin_error (_("filename argument required"));
+      builtin_usage ();
+      return (EX_USAGE);
+    }
+
+#if defined (RESTRICTED_SHELL)
+  if (restricted && strchr (list->word->word, '/'))
+    {
+      sh_restricted (list->word->word);
+      return (EXECUTION_FAILURE);
+    }
+#endif
+
+  filename = (char *)NULL;
+  /* XXX -- should this be absolute_pathname? */
+  if (posixly_correct && strchr (list->word->word, '/'))
+    filename = savestring (list->word->word);
+  else if (absolute_pathname (list->word->word))
+    filename = savestring (list->word->word);
+  else if (source_uses_path)
+    filename = find_path_file (list->word->word);
+  if (filename == 0)
+    {
+      if (source_searches_cwd == 0)
+	{
+	  builtin_error (_("%s: file not found"), list->word->word);
+	  return (EXECUTION_FAILURE);
+	}
+      else
+	filename = savestring (list->word->word);
+    }
+
+  begin_unwind_frame ("source");
+  add_unwind_protect ((Function *)xfree, filename);
+
+  if (list->next)
+    {
+      push_dollar_vars ();
+      add_unwind_protect ((Function *)maybe_pop_dollar_vars, (char *)NULL);
+      remember_args (list->next, 1);
+      if (debugging_mode)
+	push_args (list->next);	/* Update BASH_ARGV and BASH_ARGC */
+    }
+  set_dollar_vars_unchanged ();
+
+  /* Don't inherit the DEBUG trap unless function_trace_mode (overloaded)
+     is set.  XXX - should sourced files inherit the RETURN trap?  Functions
+     don't. */
+  debug_trap = TRAP_STRING (DEBUG_TRAP);
+  if (debug_trap && function_trace_mode == 0)
+    {
+      debug_trap = savestring (debug_trap);
+      add_unwind_protect (xfree, debug_trap);
+      add_unwind_protect (set_debug_trap, debug_trap);
+      restore_default_signal (DEBUG_TRAP);
+    }
+
+  result = source_file (filename, (list && list->next));
+
+  run_unwind_frame ("source");
+
+  return (result);
+}
diff -Nru bash-4.0-orig/builtins/suspend.c bash-4.0/builtins/suspend.c
--- bash-4.0-orig/builtins/suspend.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/suspend.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,94 @@
+/* suspend.c, created from suspend.def. */
+#line 22 "./suspend.def"
+
+#line 38 "./suspend.def"
+
+#include <config.h>
+
+#if defined (JOB_CONTROL)
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashtypes.h"
+#include <signal.h>
+#include "../bashintl.h"
+#include "../shell.h"
+#include "../jobs.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+static sighandler suspend_continue __P((int));
+
+static SigHandler *old_cont;
+#if 0
+static SigHandler *old_stop;
+#endif
+
+/* Continue handler. */
+static sighandler
+suspend_continue (sig)
+     int sig;
+{
+  set_signal_handler (SIGCONT, old_cont);
+#if 0
+  set_signal_handler (SIGSTOP, old_stop);
+#endif
+  SIGRETURN (0);
+}
+
+/* Suspending the shell.  If -f is the arg, then do the suspend
+   no matter what.  Otherwise, complain if a login shell. */
+int
+suspend_builtin (list)
+     WORD_LIST *list;
+{
+  int opt, force;
+
+  reset_internal_getopt ();
+  force = 0;
+  while ((opt = internal_getopt (list, "f")) != -1)
+    switch (opt)
+      {
+      case 'f':
+	force++;
+	break;
+      default:
+	builtin_usage ();
+	return (EX_USAGE);
+      }
+      
+  list = loptend;
+
+  if (job_control == 0)
+    {
+      sh_nojobs (_("cannot suspend"));
+      return (EXECUTION_FAILURE);
+    }
+
+  if (force == 0)  
+    {
+      no_args (list);
+
+      if (login_shell)
+	{
+	  builtin_error (_("cannot suspend a login shell"));
+	  return (EXECUTION_FAILURE);
+	}
+    }
+
+  /* XXX - should we put ourselves back into the original pgrp now?  If so,
+     call end_job_control() here and do the right thing in suspend_continue
+     (that is, call restart_job_control()). */
+  old_cont = (SigHandler *)set_signal_handler (SIGCONT, suspend_continue);
+#if 0
+  old_stop = (SigHandler *)set_signal_handler (SIGSTOP, SIG_DFL);
+#endif
+  killpg (shell_pgrp, SIGSTOP);
+  return (EXECUTION_SUCCESS);
+}
+
+#endif /* JOB_CONTROL */
diff -Nru bash-4.0-orig/builtins/test.c bash-4.0/builtins/test.c
--- bash-4.0-orig/builtins/test.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/test.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,53 @@
+/* test.c, created from test.def. */
+#line 22 "./test.def"
+
+#line 98 "./test.def"
+
+#line 108 "./test.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../test.h"
+#include "common.h"
+
+extern char *this_command_name;
+
+/* TEST/[ builtin. */
+int
+test_builtin (list)
+     WORD_LIST *list;
+{
+  char **argv;
+  int argc, result;
+
+  /* We let Matthew Bradburn and Kevin Braunsdorf's code do the
+     actual test command.  So turn the list of args into an array
+     of strings, since that is what their code wants. */
+  if (list == 0)
+    {
+      if (this_command_name[0] == '[' && !this_command_name[1])
+	{
+	  builtin_error (_("missing `]'"));
+	  return (EX_BADUSAGE);
+	}
+
+      return (EXECUTION_FAILURE);
+    }
+
+  argv = make_builtin_argv  (list, &argc);
+  result = test_command (argc, argv);
+  free ((char *)argv);
+
+  return (result);
+}
diff -Nru bash-4.0-orig/builtins/times.c bash-4.0/builtins/times.c
--- bash-4.0-orig/builtins/times.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/times.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,90 @@
+/* times.c, created from times.def. */
+#line 22 "./times.def"
+
+#line 34 "./times.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include "../bashtypes.h"
+#include "../shell.h"
+
+#include <posixtime.h>
+
+#if defined (HAVE_SYS_TIMES_H)
+#  include <sys/times.h>
+#endif /* HAVE_SYS_TIMES_H */
+
+#if defined (HAVE_SYS_RESOURCE_H) && !defined (RLIMTYPE)
+#  include <sys/resource.h>
+#endif
+
+#include "common.h"
+
+/* Print the totals for system and user time used. */
+int
+times_builtin (list)
+     WORD_LIST *list;
+{
+#if defined (HAVE_GETRUSAGE) && defined (HAVE_TIMEVAL) && defined (RUSAGE_SELF)
+  struct rusage self, kids;
+
+  USE_VAR(list);
+
+  if (no_options (list))
+    return (EX_USAGE);
+
+  getrusage (RUSAGE_SELF, &self);
+  getrusage (RUSAGE_CHILDREN, &kids);	/* terminated child processes */
+
+  print_timeval (stdout, &self.ru_utime);
+  putchar (' ');
+  print_timeval (stdout, &self.ru_stime);
+  putchar ('\n');
+  print_timeval (stdout, &kids.ru_utime);
+  putchar (' ');
+  print_timeval (stdout, &kids.ru_stime);
+  putchar ('\n');
+
+#else
+#  if defined (HAVE_TIMES)
+  /* This uses the POSIX.1/XPG5 times(2) interface, which fills in a 
+     `struct tms' with values of type clock_t. */
+  struct tms t;
+
+  USE_VAR(list);
+
+  if (no_options (list))
+    return (EX_USAGE);
+
+  times (&t);
+
+  print_clock_t (stdout, t.tms_utime);
+  putchar (' ');
+  print_clock_t (stdout, t.tms_stime);
+  putchar ('\n');
+  print_clock_t (stdout, t.tms_cutime);
+  putchar (' ');
+  print_clock_t (stdout, t.tms_cstime);
+  putchar ('\n');
+
+#  else /* !HAVE_TIMES */
+
+  USE_VAR(list);
+
+  if (no_options (list))
+    return (EX_USAGE);
+  printf ("0.00 0.00\n0.00 0.00\n");
+
+#  endif /* HAVE_TIMES */
+#endif /* !HAVE_TIMES */
+
+  return (sh_chkwrite (EXECUTION_SUCCESS));
+}
diff -Nru bash-4.0-orig/builtins/trap.c bash-4.0/builtins/trap.c
--- bash-4.0-orig/builtins/trap.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/trap.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,231 @@
+/* trap.c, created from trap.def. */
+#line 22 "./trap.def"
+
+#line 54 "./trap.def"
+
+#include <config.h>
+
+#if defined (HAVE_UNISTD_H)
+#  ifdef _MINIX
+#    include <sys/types.h>
+#  endif
+#  include <unistd.h>
+#endif
+
+#include "../bashtypes.h"
+#include <signal.h>
+#include <stdio.h>
+#include "../bashansi.h"
+
+#include "../shell.h"
+#include "../trap.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+static void showtrap __P((int));
+static int display_traps __P((WORD_LIST *));
+
+/* The trap command:
+
+   trap <arg> <signal ...>
+   trap <signal ...>
+   trap -l
+   trap -p [sigspec ...]
+   trap [--]
+
+   Set things up so that ARG is executed when SIGNAL(s) N is recieved.
+   If ARG is the empty string, then ignore the SIGNAL(s).  If there is
+   no ARG, then set the trap for SIGNAL(s) to its original value.  Just
+   plain "trap" means to print out the list of commands associated with
+   each signal number.  Single arg of "-l" means list the signal names. */
+
+/* Possible operations to perform on the list of signals.*/
+#define SET 0			/* Set this signal to first_arg. */
+#define REVERT 1		/* Revert to this signals original value. */
+#define IGNORE 2		/* Ignore this signal. */
+
+extern int posixly_correct;
+
+int
+trap_builtin (list)
+     WORD_LIST *list;
+{
+  int list_signal_names, display, result, opt;
+
+  list_signal_names = display = 0;
+  result = EXECUTION_SUCCESS;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "lp")) != -1)
+    {
+      switch (opt)
+	{
+	case 'l':
+	  list_signal_names++;
+	  break;
+	case 'p':
+	  display++;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  opt = DSIG_NOCASE|DSIG_SIGPREFIX;	/* flags for decode_signal */
+
+  if (list_signal_names)
+    return (sh_chkwrite (display_signal_list ((WORD_LIST *)NULL, 1)));
+  else if (display || list == 0)
+    return (sh_chkwrite (display_traps (list)));
+  else
+    {
+      char *first_arg;
+      int operation, sig, first_signal;
+
+      operation = SET;
+      first_arg = list->word->word;
+      first_signal = first_arg && *first_arg && all_digits (first_arg) && signal_object_p (first_arg, opt);
+
+      /* Backwards compatibility.  XXX - question about whether or not we
+	 should throw an error if an all-digit argument doesn't correspond
+	 to a valid signal number (e.g., if it's `50' on a system with only
+	 32 signals).  */
+      if (first_signal)
+	operation = REVERT;
+      /* When in posix mode, the historical behavior of looking for a
+	 missing first argument is disabled.  To revert to the original
+	 signal handling disposition, use `-' as the first argument. */
+      else if (posixly_correct == 0 && first_arg && *first_arg &&
+		(*first_arg != '-' || first_arg[1]) &&
+		signal_object_p (first_arg, opt) && list->next == 0)
+	operation = REVERT;
+      else
+	{
+	  list = list->next;
+	  if (list == 0)
+	    {
+	      builtin_usage ();
+	      return (EX_USAGE);
+	    }
+	  else if (*first_arg == '\0')
+	    operation = IGNORE;
+	  else if (first_arg[0] == '-' && !first_arg[1])
+	    operation = REVERT;
+	}
+
+      while (list)
+	{
+	  sig = decode_signal (list->word->word, opt);
+
+	  if (sig == NO_SIG)
+	    {
+	      sh_invalidsig (list->word->word);
+	      result = EXECUTION_FAILURE;
+	    }
+	  else
+	    {
+	      switch (operation)
+		{
+		  case SET:
+		    set_signal (sig, first_arg);
+		    break;
+
+		  case REVERT:
+		    restore_default_signal (sig);
+
+		    /* Signals that the shell treats specially need special
+		       handling. */
+		    switch (sig)
+		      {
+		      case SIGINT:
+			if (interactive)
+			  set_signal_handler (SIGINT, sigint_sighandler);
+			else
+			  set_signal_handler (SIGINT, termsig_sighandler);
+			break;
+
+		      case SIGQUIT:
+			/* Always ignore SIGQUIT. */
+			set_signal_handler (SIGQUIT, SIG_IGN);
+			break;
+		      case SIGTERM:
+#if defined (JOB_CONTROL)
+		      case SIGTTIN:
+		      case SIGTTOU:
+		      case SIGTSTP:
+#endif /* JOB_CONTROL */
+			if (interactive)
+			  set_signal_handler (sig, SIG_IGN);
+			break;
+		      }
+		    break;
+
+		  case IGNORE:
+		    ignore_signal (sig);
+		    break;
+		}
+	    }
+	  list = list->next;
+	}
+    }
+
+  return (result);
+}
+
+static void
+showtrap (i)
+     int i;
+{
+  char *t, *p, *sn;
+
+  p = trap_list[i];
+  if (p == (char *)DEFAULT_SIG)
+    return;
+
+  t = (p == (char *)IGNORE_SIG) ? (char *)NULL : sh_single_quote (p);
+  sn = signal_name (i);
+  /* Make sure that signals whose names are unknown (for whatever reason)
+     are printed as signal numbers. */
+  if (STREQN (sn, "SIGJUNK", 7) || STREQN (sn, "unknown", 7))
+    printf ("trap -- %s %d\n", t ? t : "''", i);
+  else if (posixly_correct)
+    {
+      if (STREQN (sn, "SIG", 3))
+	printf ("trap -- %s %s\n", t ? t : "''", sn+3);
+      else
+	printf ("trap -- %s %s\n", t ? t : "''", sn);
+    }
+  else
+    printf ("trap -- %s %s\n", t ? t : "''", sn);
+
+  FREE (t);
+}
+
+static int
+display_traps (list)
+     WORD_LIST *list;
+{
+  int result, i;
+
+  if (list == 0)
+    {
+      for (i = 0; i < BASH_NSIG; i++)
+	showtrap (i);
+      return (EXECUTION_SUCCESS);
+    }
+
+  for (result = EXECUTION_SUCCESS; list; list = list->next)
+    {
+      i = decode_signal (list->word->word, DSIG_NOCASE|DSIG_SIGPREFIX);
+      if (i == NO_SIG)
+	{
+	  sh_invalidsig (list->word->word);
+	  result = EXECUTION_FAILURE;
+	}
+      else
+	showtrap (i);
+    }
+
+  return (result);
+}
diff -Nru bash-4.0-orig/builtins/type.c bash-4.0/builtins/type.c
--- bash-4.0-orig/builtins/type.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/type.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,356 @@
+/* type.c, created from type.def. */
+#line 22 "./type.def"
+
+#line 52 "./type.def"
+
+#include <config.h>
+
+#include "../bashtypes.h"
+#include "posixstat.h"
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include "../bashansi.h"
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "../findcmd.h"
+#include "../hashcmd.h"
+
+#if defined (ALIAS)
+#include "../alias.h"
+#endif /* ALIAS */
+
+#include "common.h"
+#include "bashgetopt.h"
+
+extern int find_reserved_word __P((char *));
+
+extern char *this_command_name;
+extern int expand_aliases, posixly_correct;
+
+/* For each word in LIST, find out what the shell is going to do with
+   it as a simple command. i.e., which file would this shell use to
+   execve, or if it is a builtin command, or an alias.  Possible flag
+   arguments:
+	-t		Returns the "type" of the object, one of
+			`alias', `keyword', `function', `builtin',
+			or `file'.
+
+	-p		Returns the pathname of the file if -type is
+			a file.
+
+	-a		Returns all occurrences of words, whether they
+			be a filename in the path, alias, function,
+			or builtin.
+
+	-f		Suppress shell function lookup, like `command'.
+
+	-P		Force a path search even in the presence of other
+			definitions.
+
+   Order of evaluation:
+	alias
+	keyword
+	function
+	builtin
+	file
+ */
+
+int
+type_builtin (list)
+     WORD_LIST *list;
+{
+  int dflags, any_failed, opt;
+  WORD_LIST *this;
+
+  if (list == 0)
+    return (EXECUTION_SUCCESS);
+
+  dflags = CDESC_SHORTDESC;	/* default */
+  any_failed = 0;
+
+  /* Handle the obsolescent `-type', `-path', and `-all' by prescanning
+     the arguments and converting those options to the form that
+     internal_getopt recognizes. Converts `--type', `--path', and `--all'
+     also. THIS SHOULD REALLY GO AWAY. */
+  for (this = list; this && this->word->word[0] == '-'; this = this->next)
+    {
+      char *flag = &(this->word->word[1]);
+
+      if (STREQ (flag, "type") || STREQ (flag, "-type"))
+	{
+	  this->word->word[1] = 't';
+	  this->word->word[2] = '\0';
+	}
+      else if (STREQ (flag, "path") || STREQ (flag, "-path"))
+	{
+	  this->word->word[1] = 'p';
+	  this->word->word[2] = '\0';
+	}
+      else if (STREQ (flag, "all") || STREQ (flag, "-all"))
+	{
+	  this->word->word[1] = 'a';
+	  this->word->word[2] = '\0';
+	}
+    }
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "afptP")) != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  dflags |= CDESC_ALL;
+	  break;
+	case 'f':
+	  dflags |= CDESC_NOFUNCS;
+	  break;
+	case 'p':
+	  dflags |= CDESC_PATH_ONLY;
+	  dflags &= ~(CDESC_TYPE|CDESC_SHORTDESC);
+	  break;
+	case 't':
+	  dflags |= CDESC_TYPE;
+	  dflags &= ~(CDESC_PATH_ONLY|CDESC_SHORTDESC);
+	  break;
+	case 'P':	/* shorthand for type -ap */
+	  dflags |= (CDESC_PATH_ONLY|CDESC_FORCE_PATH);
+	  dflags &= ~(CDESC_TYPE|CDESC_SHORTDESC);
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+  list = loptend;
+
+  while (list)
+    {
+      int found;
+
+      found = describe_command (list->word->word, dflags);
+
+      if (!found && (dflags & (CDESC_PATH_ONLY|CDESC_TYPE)) == 0)
+	sh_notfound (list->word->word);
+
+      any_failed += found == 0;
+      list = list->next;
+    }
+
+  opt = (any_failed == 0) ? EXECUTION_SUCCESS : EXECUTION_FAILURE;
+  return (sh_chkwrite (opt));
+}
+
+/*
+ * Describe COMMAND as required by the type and command builtins.
+ *
+ * Behavior is controlled by DFLAGS.  Flag values are
+ *	CDESC_ALL	print all descriptions of a command
+ *	CDESC_SHORTDESC	print the description for type and command -V
+ *	CDESC_REUSABLE	print in a format that may be reused as input
+ *	CDESC_TYPE	print the type for type -t
+ *	CDESC_PATH_ONLY	print the path for type -p
+ *	CDESC_FORCE_PATH	force a path search for type -P
+ *	CDESC_NOFUNCS	skip function lookup for type -f
+ *	CDESC_ABSPATH	convert to absolute path, no ./ prefix
+ *
+ * CDESC_ALL says whether or not to look for all occurrences of COMMAND, or
+ * return after finding it once.
+ */
+int
+describe_command (command, dflags)
+     char *command;
+     int dflags;
+{
+  int found, i, found_file, f, all;
+  char *full_path, *x;
+  SHELL_VAR *func;
+#if defined (ALIAS)
+  alias_t *alias;
+#endif
+
+  all = (dflags & CDESC_ALL) != 0;
+  found = found_file = 0;
+  full_path = (char *)NULL;
+
+#if defined (ALIAS)
+  /* Command is an alias? */
+  if (((dflags & CDESC_FORCE_PATH) == 0) && expand_aliases && (alias = find_alias (command)))
+    {
+      if (dflags & CDESC_TYPE)
+	puts ("alias");
+      else if (dflags & CDESC_SHORTDESC)
+	printf (_("%s is aliased to `%s'\n"), command, alias->value);
+      else if (dflags & CDESC_REUSABLE)
+	{
+	  x = sh_single_quote (alias->value);
+	  printf ("alias %s=%s\n", command, x);
+	  free (x);
+	}
+
+      found = 1;
+
+      if (all == 0)
+	return (1);
+    }
+#endif /* ALIAS */
+
+  /* Command is a shell reserved word? */
+  if (((dflags & CDESC_FORCE_PATH) == 0) && (i = find_reserved_word (command)) >= 0)
+    {
+      if (dflags & CDESC_TYPE)
+	puts ("keyword");
+      else if (dflags & CDESC_SHORTDESC)
+	printf (_("%s is a shell keyword\n"), command);
+      else if (dflags & CDESC_REUSABLE)
+	printf ("%s\n", command);
+
+      found = 1;
+
+      if (all == 0)
+	return (1);
+    }
+
+  /* Command is a function? */
+  if (((dflags & (CDESC_FORCE_PATH|CDESC_NOFUNCS)) == 0) && (func = find_function (command)))
+    {
+      if (dflags & CDESC_TYPE)
+	puts ("function");
+      else if (dflags & CDESC_SHORTDESC)
+	{
+	  char *result;
+
+	  printf (_("%s is a function\n"), command);
+
+	  /* We're blowing away THE_PRINTED_COMMAND here... */
+
+	  result = named_function_string (command, function_cell (func), FUNC_MULTILINE|FUNC_EXTERNAL);
+	  printf ("%s\n", result);
+	}
+      else if (dflags & CDESC_REUSABLE)
+	printf ("%s\n", command);
+
+      found = 1;
+
+      if (all == 0)
+	return (1);
+    }
+
+  /* Command is a builtin? */
+  if (((dflags & CDESC_FORCE_PATH) == 0) && find_shell_builtin (command))
+    {
+      if (dflags & CDESC_TYPE)
+	puts ("builtin");
+      else if (dflags & CDESC_SHORTDESC)
+	printf (_("%s is a shell builtin\n"), command);
+      else if (dflags & CDESC_REUSABLE)
+	printf ("%s\n", command);
+
+      found = 1;
+
+      if (all == 0)
+	return (1);
+    }
+
+  /* Command is a disk file? */
+  /* If the command name given is already an absolute command, just
+     check to see if it is executable. */
+  if (absolute_program (command))
+    {
+      f = file_status (command);
+      if (f & FS_EXECABLE)
+	{
+	  if (dflags & CDESC_TYPE)
+	    puts ("file");
+	  else if (dflags & CDESC_SHORTDESC)
+	    printf (_("%s is %s\n"), command, command);
+	  else if (dflags & (CDESC_REUSABLE|CDESC_PATH_ONLY))
+	    printf ("%s\n", command);
+
+	  /* There's no use looking in the hash table or in $PATH,
+	     because they're not consulted when an absolute program
+	     name is supplied. */
+	  return (1);
+	}
+    }
+
+  /* If the user isn't doing "-a", then we might care about
+     whether the file is present in our hash table. */
+  if (all == 0 || (dflags & CDESC_FORCE_PATH))
+    {
+      if (full_path = phash_search (command))
+	{
+	  if (dflags & CDESC_TYPE)
+	    puts ("file");
+	  else if (dflags & CDESC_SHORTDESC)
+	    printf (_("%s is hashed (%s)\n"), command, full_path);
+	  else if (dflags & (CDESC_REUSABLE|CDESC_PATH_ONLY))
+	    printf ("%s\n", full_path);
+
+	  free (full_path);
+	  return (1);
+	}
+    }
+
+  /* Now search through $PATH. */
+  while (1)
+    {
+      if (all == 0)
+	full_path = find_user_command (command);
+      else
+	full_path =
+	  user_command_matches (command, FS_EXEC_ONLY, found_file);
+	  /* XXX - should that be FS_EXEC_PREFERRED? */
+
+      if (!full_path)
+	break;
+
+      /* If we found the command as itself by looking through $PATH, it
+	 probably doesn't exist.  Check whether or not the command is an
+	 executable file.  If it's not, don't report a match.  This is
+	 the default posix mode behavior */
+      if (STREQ (full_path, command) || posixly_correct)
+	{
+	  f = file_status (full_path);
+	  if ((f & FS_EXECABLE) == 0)
+	    {
+	      free (full_path);
+	      full_path = (char *)NULL;
+	      if (all == 0)
+		break;
+	    }
+	  else if (ABSPATH (full_path))
+	    ;	/* placeholder; don't need to do anything yet */
+	  else if (dflags & (CDESC_REUSABLE|CDESC_PATH_ONLY|CDESC_SHORTDESC))
+	    {
+	      f = MP_DOCWD | ((dflags & CDESC_ABSPATH) ? MP_RMDOT : 0);
+	      full_path = sh_makepath ((char *)NULL, full_path, f);
+	    }
+	}
+      /* If we require a full path and don't have one, make one */
+      else if ((dflags & CDESC_ABSPATH) && ABSPATH (full_path) == 0)
+	full_path = sh_makepath ((char *)NULL, full_path, MP_DOCWD|MP_RMDOT);
+
+      found_file++;
+      found = 1;
+
+      if (dflags & CDESC_TYPE)
+	puts ("file");
+      else if (dflags & CDESC_SHORTDESC)
+	printf (_("%s is %s\n"), command, full_path);
+      else if (dflags & (CDESC_REUSABLE|CDESC_PATH_ONLY))
+	printf ("%s\n", full_path);
+
+      free (full_path);
+      full_path = (char *)NULL;
+
+      if (all == 0)
+	break;
+    }
+
+  return (found);
+}
diff -Nru bash-4.0-orig/builtins/ulimit.c bash-4.0/builtins/ulimit.c
--- bash-4.0-orig/builtins/ulimit.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/ulimit.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,710 @@
+/* ulimit.c, created from ulimit.def. */
+#line 22 "./ulimit.def"
+
+#line 67 "./ulimit.def"
+
+#if !defined (_MINIX)
+
+#include <config.h>
+
+#include "../bashtypes.h"
+#ifndef _MINIX
+#  include <sys/param.h>
+#endif
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "common.h"
+#include "bashgetopt.h"
+#include "pipesize.h"
+
+#if !defined (errno)
+extern int errno;
+#endif
+
+/* For some reason, HPUX chose to make these definitions visible only if
+   _KERNEL is defined, so we define _KERNEL before including <sys/resource.h>
+   and #undef it afterward. */
+#if defined (HAVE_RESOURCE)
+#  include <sys/time.h>
+#  if defined (HPUX) && defined (RLIMIT_NEEDS_KERNEL)
+#    define _KERNEL
+#  endif
+#  include <sys/resource.h>
+#  if defined (HPUX) && defined (RLIMIT_NEEDS_KERNEL)
+#    undef _KERNEL
+#  endif
+#elif defined (HAVE_SYS_TIMES_H)
+#  include <sys/times.h>
+#endif
+
+#if defined (HAVE_LIMITS_H)
+#  include <limits.h>
+#endif
+
+/* Check for the most basic symbols.  If they aren't present, this
+   system's <sys/resource.h> isn't very useful to us. */
+#if !defined (RLIMIT_FSIZE) || !defined (HAVE_GETRLIMIT)
+#  undef HAVE_RESOURCE
+#endif
+
+#if !defined (RLIMTYPE)
+#  define RLIMTYPE long
+#  define string_to_rlimtype(s) strtol(s, (char **)NULL, 10)
+#  define print_rlimtype(num, nl) printf ("%ld%s", num, nl ? "\n" : "")
+#endif
+
+/* Some systems use RLIMIT_NOFILE, others use RLIMIT_OFILE */
+#if defined (HAVE_RESOURCE) && defined (RLIMIT_OFILE) && !defined (RLIMIT_NOFILE)
+#  define RLIMIT_NOFILE RLIMIT_OFILE
+#endif /* HAVE_RESOURCE && RLIMIT_OFILE && !RLIMIT_NOFILE */
+
+/* Some systems have these, some do not. */
+#ifdef RLIMIT_FSIZE
+#  define RLIMIT_FILESIZE	RLIMIT_FSIZE
+#else
+#  define RLIMIT_FILESIZE	256
+#endif
+
+#define RLIMIT_PIPESIZE	257
+
+#ifdef RLIMIT_NOFILE
+#  define RLIMIT_OPENFILES	RLIMIT_NOFILE
+#else
+#  define RLIMIT_OPENFILES	258
+#endif
+
+#ifdef RLIMIT_VMEM
+#  define RLIMIT_VIRTMEM	RLIMIT_VMEM
+#  define RLIMIT_VMBLKSZ	1024
+#else
+#  ifdef RLIMIT_AS
+#    define RLIMIT_VIRTMEM	RLIMIT_AS
+#    define RLIMIT_VMBLKSZ	1024
+#  else
+#    define RLIMIT_VIRTMEM	259
+#    define RLIMIT_VMBLKSZ	1
+#  endif
+#endif
+
+#ifdef RLIMIT_NPROC
+#  define RLIMIT_MAXUPROC	RLIMIT_NPROC
+#else
+#  define RLIMIT_MAXUPROC	260
+#endif
+
+#if !defined (RLIM_INFINITY)
+#  define RLIM_INFINITY 0x7fffffff
+#endif
+
+#if !defined (RLIM_SAVED_CUR)
+#  define RLIM_SAVED_CUR RLIM_INFINITY
+#endif
+
+#if !defined (RLIM_SAVED_MAX)
+#  define RLIM_SAVED_MAX RLIM_INFINITY
+#endif
+
+#define LIMIT_HARD 0x01
+#define LIMIT_SOFT 0x02
+
+/* "Blocks" are defined as 512 bytes when in Posix mode and 1024 bytes
+   otherwise. */
+#define POSIXBLK	-2
+
+#define BLOCKSIZE(x)	(((x) == POSIXBLK) ? (posixly_correct ? 512 : 1024) : (x))
+
+extern int posixly_correct;
+
+static int _findlim __P((int));
+
+static int ulimit_internal __P((int, char *, int, int));
+
+static int get_limit __P((int, RLIMTYPE *, RLIMTYPE *));
+static int set_limit __P((int, RLIMTYPE, int));
+
+static void printone __P((int, RLIMTYPE, int));
+static void print_all_limits __P((int));
+
+static int set_all_limits __P((int, RLIMTYPE));
+
+static int filesize __P((RLIMTYPE *));
+static int pipesize __P((RLIMTYPE *));
+static int getmaxuprc __P((RLIMTYPE *));
+static int getmaxvm __P((RLIMTYPE *, RLIMTYPE *));
+
+typedef struct {
+  int  option;			/* The ulimit option for this limit. */
+  int  parameter;		/* Parameter to pass to get_limit (). */
+  int  block_factor;		/* Blocking factor for specific limit. */
+  const char * const description;	/* Descriptive string to output. */
+  const char * const units;	/* scale */
+} RESOURCE_LIMITS;
+
+static RESOURCE_LIMITS limits[] = {
+#ifdef RLIMIT_PTHREAD
+  { 'T',	RLIMIT_PTHREAD,  1,	"number of threads",	(char *)NULL },
+#endif
+#ifdef RLIMIT_SBSIZE
+  { 'b',	RLIMIT_SBSIZE,  1,	"socket buffer size",	"bytes" },
+#endif
+#ifdef RLIMIT_CORE
+  { 'c',	RLIMIT_CORE,  POSIXBLK,	"core file size",	"blocks" },
+#endif
+#ifdef RLIMIT_DATA
+  { 'd',	RLIMIT_DATA,  1024,	"data seg size",	"kbytes" },
+#endif
+#ifdef RLIMIT_NICE
+  { 'e',	RLIMIT_NICE,  1,	"scheduling priority",	(char *)NULL },
+#endif
+  { 'f',	RLIMIT_FILESIZE, POSIXBLK,	"file size",		"blocks" },
+#ifdef RLIMIT_SIGPENDING
+  { 'i',	RLIMIT_SIGPENDING, 1,	"pending signals",	(char *)NULL },
+#endif
+#ifdef RLIMIT_MEMLOCK
+  { 'l',	RLIMIT_MEMLOCK, 1024,	"max locked memory",	"kbytes" },
+#endif
+#ifdef RLIMIT_RSS
+  { 'm',	RLIMIT_RSS,   1024,	"max memory size",	"kbytes" },
+#endif /* RLIMIT_RSS */
+  { 'n',	RLIMIT_OPENFILES, 1,	"open files",		(char *)NULL},
+  { 'p',	RLIMIT_PIPESIZE, 512,	"pipe size", 		"512 bytes" },
+#ifdef RLIMIT_MSGQUEUE
+  { 'q',	RLIMIT_MSGQUEUE, 1,	"POSIX message queues",	"bytes" },
+#endif
+#ifdef RLIMIT_RTPRIO
+  { 'r',	RLIMIT_RTPRIO,  1,	"real-time priority",	(char *)NULL },
+#endif
+#ifdef RLIMIT_STACK
+  { 's',	RLIMIT_STACK, 1024,	"stack size",		"kbytes" },
+#endif
+#ifdef RLIMIT_CPU
+  { 't',	RLIMIT_CPU,      1,	"cpu time",		"seconds" },
+#endif /* RLIMIT_CPU */
+  { 'u',	RLIMIT_MAXUPROC, 1,	"max user processes",	(char *)NULL },
+#if defined (HAVE_RESOURCE)
+  { 'v',	RLIMIT_VIRTMEM, RLIMIT_VMBLKSZ, "virtual memory", "kbytes" },
+#endif
+#ifdef RLIMIT_SWAP
+  { 'w',	RLIMIT_SWAP,	1024,	"swap size",		"kbytes" },
+#endif
+#ifdef RLIMIT_LOCKS
+  { 'x',	RLIMIT_LOCKS,	1,	"file locks",		(char *)NULL },
+#endif
+  { -1, -1, -1, (char *)NULL, (char *)NULL }
+};
+#define NCMDS	(sizeof(limits) / sizeof(limits[0]))
+
+typedef struct _cmd {
+  int cmd;
+  char *arg;
+} ULCMD;
+
+static ULCMD *cmdlist;
+static int ncmd;
+static int cmdlistsz;
+
+#if !defined (HAVE_RESOURCE) && !defined (HAVE_ULIMIT)
+long
+ulimit (cmd, newlim)
+     int cmd;
+     long newlim;
+{
+  errno = EINVAL;
+  return -1;
+}
+#endif /* !HAVE_RESOURCE && !HAVE_ULIMIT */
+
+static int
+_findlim (opt)
+     int opt;
+{
+  register int i;
+
+  for (i = 0; limits[i].option > 0; i++)
+    if (limits[i].option == opt)
+      return i;
+  return -1;
+}
+
+static char optstring[4 + 2 * NCMDS];
+
+/* Report or set limits associated with certain per-process resources.
+   See the help documentation in builtins.c for a full description. */
+int
+ulimit_builtin (list)
+     register WORD_LIST *list;
+{
+  register char *s;
+  int c, limind, mode, opt, all_limits;
+
+  mode = 0;
+
+  all_limits = 0;
+
+  /* Idea stolen from pdksh -- build option string the first time called. */
+  if (optstring[0] == 0)
+    {
+      s = optstring;
+      *s++ = 'a'; *s++ = 'S'; *s++ = 'H';
+      for (c = 0; limits[c].option > 0; c++)
+	{
+	  *s++ = limits[c].option;
+	  *s++ = ';';
+	}
+      *s = '\0';
+    }
+
+  /* Initialize the command list. */
+  if (cmdlistsz == 0)
+    cmdlist = (ULCMD *)xmalloc ((cmdlistsz = 16) * sizeof (ULCMD));
+  ncmd = 0;
+
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, optstring)) != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  all_limits++;
+	  break;
+
+	/* -S and -H are modifiers, not real options.  */
+	case 'S':
+	  mode |= LIMIT_SOFT;
+	  break;
+
+	case 'H':
+	  mode |= LIMIT_HARD;
+	  break;
+
+	case '?':
+	  builtin_usage ();
+	  return (EX_USAGE);
+
+	default:
+	  if (ncmd >= cmdlistsz)
+	    cmdlist = (ULCMD *)xrealloc (cmdlist, (cmdlistsz *= 2) * sizeof (ULCMD));
+	  cmdlist[ncmd].cmd = opt;
+	  cmdlist[ncmd++].arg = list_optarg;
+	  break;
+	}
+    }
+  list = loptend;
+
+  if (all_limits)
+    {
+#ifdef NOTYET
+      if (list)		/* setting */
+        {
+          if (STREQ (list->word->word, "unlimited") == 0)
+            {
+              builtin_error (_("%s: invalid limit argument"), list->word->word);
+              return (EXECUTION_FAILURE);
+            }
+          return (set_all_limits (mode == 0 ? LIMIT_SOFT|LIMIT_HARD : mode, RLIM_INFINITY));
+        }
+#endif
+      print_all_limits (mode == 0 ? LIMIT_SOFT : mode);
+      return (sh_chkwrite (EXECUTION_SUCCESS));
+    }
+
+  /* default is `ulimit -f' */
+  if (ncmd == 0)
+    {
+      cmdlist[ncmd].cmd = 'f';
+      /* `ulimit something' is same as `ulimit -f something' */
+      cmdlist[ncmd++].arg = list ? list->word->word : (char *)NULL;
+      if (list)
+	list = list->next;
+    }
+
+  /* verify each command in the list. */
+  for (c = 0; c < ncmd; c++)
+    {
+      limind = _findlim (cmdlist[c].cmd);
+      if (limind == -1)
+	{
+	  builtin_error (_("`%c': bad command"), cmdlist[c].cmd);
+	  return (EX_USAGE);
+	}
+    }
+
+  for (c = 0; c < ncmd; c++)
+    if (ulimit_internal (cmdlist[c].cmd, cmdlist[c].arg, mode, ncmd > 1) == EXECUTION_FAILURE)
+      return (EXECUTION_FAILURE);
+
+  return (EXECUTION_SUCCESS);
+}
+
+static int
+ulimit_internal (cmd, cmdarg, mode, multiple)
+     int cmd;
+     char *cmdarg;
+     int mode, multiple;
+{
+  int opt, limind, setting;
+  int block_factor;
+  RLIMTYPE soft_limit, hard_limit, real_limit, limit;
+
+  setting = cmdarg != 0;
+  limind = _findlim (cmd);
+  if (mode == 0)
+    mode = setting ? (LIMIT_HARD|LIMIT_SOFT) : LIMIT_SOFT;
+  opt = get_limit (limind, &soft_limit, &hard_limit);
+  if (opt < 0)
+    {
+      builtin_error (_("%s: cannot get limit: %s"), limits[limind].description,
+						 strerror (errno));
+      return (EXECUTION_FAILURE);
+    }
+
+  if (setting == 0)	/* print the value of the specified limit */
+    {
+      printone (limind, (mode & LIMIT_SOFT) ? soft_limit : hard_limit, multiple);
+      return (EXECUTION_SUCCESS);
+    }
+ 
+  /* Setting the limit. */
+  if (STREQ (cmdarg, "hard"))
+    real_limit = hard_limit;
+  else if (STREQ (cmdarg, "soft"))
+    real_limit = soft_limit;
+  else if (STREQ (cmdarg, "unlimited"))
+    real_limit = RLIM_INFINITY;
+  else if (all_digits (cmdarg))
+    {
+      limit = string_to_rlimtype (cmdarg);
+      block_factor = BLOCKSIZE(limits[limind].block_factor);
+      real_limit = limit * block_factor;
+
+      if ((real_limit / block_factor) != limit)
+	{
+	  sh_erange (cmdarg, _("limit"));
+	  return (EXECUTION_FAILURE);
+	}
+    }
+  else
+    {
+      sh_invalidnum (cmdarg);
+      return (EXECUTION_FAILURE);
+    }
+
+  if (set_limit (limind, real_limit, mode) < 0)
+    {
+      builtin_error (_("%s: cannot modify limit: %s"), limits[limind].description,
+						    strerror (errno));
+      return (EXECUTION_FAILURE);
+    }
+
+  return (EXECUTION_SUCCESS);
+}
+
+static int
+get_limit (ind, softlim, hardlim)
+     int ind;
+     RLIMTYPE *softlim, *hardlim;
+{
+  RLIMTYPE value;
+#if defined (HAVE_RESOURCE)
+  struct rlimit limit;
+#endif
+
+  if (limits[ind].parameter >= 256)
+    {
+      switch (limits[ind].parameter)
+	{
+	case RLIMIT_FILESIZE:
+	  if (filesize (&value) < 0)
+	    return -1;
+	  break;
+	case RLIMIT_PIPESIZE:
+	  if (pipesize (&value) < 0)
+	    return -1;
+	  break;
+	case RLIMIT_OPENFILES:
+	  value = (RLIMTYPE)getdtablesize ();
+	  break;
+	case RLIMIT_VIRTMEM:
+	  return (getmaxvm (softlim, hardlim));
+	case RLIMIT_MAXUPROC:
+	  if (getmaxuprc (&value) < 0)
+	    return -1;
+	  break;
+	default:
+	  errno = EINVAL;
+	  return -1;
+	}
+      *softlim = *hardlim = value;
+      return (0);
+    }
+  else
+    {
+#if defined (HAVE_RESOURCE)
+      if (getrlimit (limits[ind].parameter, &limit) < 0)
+	return -1;
+      *softlim = limit.rlim_cur;
+      *hardlim = limit.rlim_max;
+#  if defined (HPUX9)
+      if (limits[ind].parameter == RLIMIT_FILESIZE)
+	{
+	  *softlim *= 512;
+	  *hardlim *= 512;			/* Ugh. */
+	}
+      else
+#  endif /* HPUX9 */
+      return 0;
+#else
+      errno = EINVAL;
+      return -1;
+#endif
+    }
+}
+
+static int
+set_limit (ind, newlim, mode)
+     int ind;
+     RLIMTYPE newlim;
+     int mode;
+{
+#if defined (HAVE_RESOURCE)
+   struct rlimit limit;
+   RLIMTYPE val;
+#endif
+
+  if (limits[ind].parameter >= 256)
+    switch (limits[ind].parameter)
+      {
+      case RLIMIT_FILESIZE:
+#if !defined (HAVE_RESOURCE)
+	return (ulimit (2, newlim / 512L));
+#else
+	errno = EINVAL;
+	return -1;
+#endif
+
+      case RLIMIT_OPENFILES:
+#if defined (HAVE_SETDTABLESIZE)
+#  if defined (__CYGWIN__)
+	/* Grrr... Cygwin declares setdtablesize as void. */
+	setdtablesize (newlim);
+	return 0;
+#  else
+	return (setdtablesize (newlim));
+#  endif
+#endif
+      case RLIMIT_PIPESIZE:
+      case RLIMIT_VIRTMEM:
+      case RLIMIT_MAXUPROC:
+      default:
+	errno = EINVAL;
+	return -1;
+      }
+  else
+    {
+#if defined (HAVE_RESOURCE)
+      if (getrlimit (limits[ind].parameter, &limit) < 0)
+	return -1;
+#  if defined (HPUX9)
+      if (limits[ind].parameter == RLIMIT_FILESIZE)
+	newlim /= 512;				/* Ugh. */
+#  endif /* HPUX9 */
+      val = (current_user.euid != 0 && newlim == RLIM_INFINITY &&
+	       (mode & LIMIT_HARD) == 0 &&		/* XXX -- test */
+	       (limit.rlim_cur <= limit.rlim_max))
+		 ? limit.rlim_max : newlim;
+      if (mode & LIMIT_SOFT)
+	limit.rlim_cur = val;
+      if (mode & LIMIT_HARD)
+	limit.rlim_max = val;
+	  
+      return (setrlimit (limits[ind].parameter, &limit));
+#else
+      errno = EINVAL;
+      return -1;
+#endif
+    }
+}
+
+static int
+getmaxvm (softlim, hardlim)
+     RLIMTYPE *softlim, *hardlim;
+{
+#if defined (HAVE_RESOURCE)
+  struct rlimit datalim, stacklim;
+
+  if (getrlimit (RLIMIT_DATA, &datalim) < 0)
+    return -1;
+
+  if (getrlimit (RLIMIT_STACK, &stacklim) < 0)
+    return -1;
+
+  /* Protect against overflow. */
+  *softlim = (datalim.rlim_cur / 1024L) + (stacklim.rlim_cur / 1024L);
+  *hardlim = (datalim.rlim_max / 1024L) + (stacklim.rlim_max / 1024L);
+  return 0;
+#else
+  errno = EINVAL;
+  return -1;
+#endif /* HAVE_RESOURCE */
+}
+
+static int
+filesize(valuep)
+     RLIMTYPE *valuep;
+{
+#if !defined (HAVE_RESOURCE)
+  long result;
+  if ((result = ulimit (1, 0L)) < 0)
+    return -1;
+  else
+    *valuep = (RLIMTYPE) result * 512;
+  return 0;
+#else
+  errno = EINVAL;
+  return -1;
+#endif
+}
+
+static int
+pipesize (valuep)
+     RLIMTYPE *valuep;
+{
+#if defined (PIPE_BUF)
+  /* This is defined on Posix systems. */
+  *valuep = (RLIMTYPE) PIPE_BUF;
+  return 0;
+#else
+#  if defined (_POSIX_PIPE_BUF)
+  *valuep = (RLIMTYPE) _POSIX_PIPE_BUF;
+  return 0;
+#  else
+#    if defined (PIPESIZE)
+  /* This is defined by running a program from the Makefile. */
+  *valuep = (RLIMTYPE) PIPESIZE;
+  return 0;
+#    else
+  errno = EINVAL;
+  return -1;  
+#    endif /* PIPESIZE */
+#  endif /* _POSIX_PIPE_BUF */
+#endif /* PIPE_BUF */
+}
+
+static int
+getmaxuprc (valuep)
+     RLIMTYPE *valuep;
+{
+  long maxchild;
+
+  maxchild = getmaxchild ();
+  if (maxchild < 0)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+  else
+    {
+      *valuep = (RLIMTYPE) maxchild;
+      return 0;
+    }
+}
+
+static void
+print_all_limits (mode)
+     int mode;
+{
+  register int i;
+  RLIMTYPE softlim, hardlim;
+
+  if (mode == 0)
+    mode |= LIMIT_SOFT;
+
+  for (i = 0; limits[i].option > 0; i++)
+    {
+      if (get_limit (i, &softlim, &hardlim) == 0)
+	printone (i, (mode & LIMIT_SOFT) ? softlim : hardlim, 1);
+      else if (errno != EINVAL)
+	builtin_error ("%s: cannot get limit: %s", limits[i].description,
+						   strerror (errno));
+    }
+}
+
+static void
+printone (limind, curlim, pdesc)
+     int limind;
+     RLIMTYPE curlim;
+     int pdesc;
+{
+  char unitstr[64];
+  int factor;
+
+  factor = BLOCKSIZE(limits[limind].block_factor);
+  if (pdesc)
+    {
+      if (limits[limind].units)
+	sprintf (unitstr, "(%s, -%c) ", limits[limind].units, limits[limind].option);
+      else
+        sprintf (unitstr, "(-%c) ", limits[limind].option);
+
+      printf ("%-20s %16s", limits[limind].description, unitstr);
+    }
+  if (curlim == RLIM_INFINITY)
+    puts ("unlimited");
+  else if (curlim == RLIM_SAVED_MAX)
+    puts ("hard");
+  else if (curlim == RLIM_SAVED_CUR)
+    puts ("soft");
+  else
+    print_rlimtype ((curlim / factor), 1);
+}
+
+/* Set all limits to NEWLIM.  NEWLIM currently must be RLIM_INFINITY, which
+   causes all limits to be set as high as possible depending on mode (like
+   csh `unlimit').  Returns -1 if NEWLIM is invalid, 0 if all limits
+   were set successfully, and 1 if at least one limit could not be set.
+
+   To raise all soft limits to their corresponding hard limits, use
+	ulimit -S -a unlimited
+   To attempt to raise all hard limits to infinity (superuser-only), use
+	ulimit -H -a unlimited
+   To attempt to raise all soft and hard limits to infinity, use
+	ulimit -a unlimited
+*/
+
+static int
+set_all_limits (mode, newlim)
+     int mode;
+     RLIMTYPE newlim;
+{
+  register int i;
+  int retval = 0;
+
+  if (newlim != RLIM_INFINITY)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+  
+  if (mode == 0)
+    mode = LIMIT_SOFT|LIMIT_HARD;
+
+  for (retval = i = 0; limits[i].option > 0; i++)
+    if (set_limit (i, newlim, mode) < 0)
+      {
+	builtin_error (_("%s: cannot modify limit: %s"), limits[i].description,
+						      strerror (errno));
+	retval = 1;
+      }
+  return retval;
+}
+
+#endif /* !_MINIX */
diff -Nru bash-4.0-orig/builtins/umask.c bash-4.0/builtins/umask.c
--- bash-4.0-orig/builtins/umask.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/umask.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,280 @@
+/* umask.c, created from umask.def. */
+#line 22 "./umask.def"
+
+#line 41 "./umask.def"
+
+#include <config.h>
+
+#include "../bashtypes.h"
+#include "filecntl.h"
+#if ! defined(_MINIX) && defined (HAVE_SYS_FILE_H)
+#  include <sys/file.h>
+#endif
+
+#if defined (HAVE_UNISTD_H)
+#include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include <chartypes.h>
+
+#include "../bashintl.h"
+
+#include "../shell.h"
+#include "posixstat.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+#ifdef __LCC__
+#define mode_t int
+#endif
+
+/* **************************************************************** */
+/*                                                                  */
+/*                     UMASK Builtin and Helpers                    */
+/*                                                                  */
+/* **************************************************************** */
+
+static void print_symbolic_umask __P((mode_t));
+static int symbolic_umask __P((WORD_LIST *));
+
+/* Set or display the mask used by the system when creating files.  Flag
+   of -S means display the umask in a symbolic mode. */
+int
+umask_builtin (list)
+     WORD_LIST *list;
+{
+  int print_symbolically, opt, umask_value, pflag;
+  mode_t umask_arg;
+
+  print_symbolically = pflag = 0;
+  reset_internal_getopt ();
+  while ((opt = internal_getopt (list, "Sp")) != -1)
+    {
+      switch (opt)
+	{
+	case 'S':
+	  print_symbolically++;
+	  break;
+	case 'p':
+	  pflag++;
+	  break;
+	default:
+	  builtin_usage ();
+	  return (EX_USAGE);
+	}
+    }
+
+  list = loptend;
+
+  if (list)
+    {
+      if (DIGIT (*list->word->word))
+	{
+	  umask_value = read_octal (list->word->word);
+
+	  /* Note that other shells just let you set the umask to zero
+	     by specifying a number out of range.  This is a problem
+	     with those shells.  We don't change the umask if the input
+	     is lousy. */
+	  if (umask_value == -1)
+	    {
+	      sh_erange (list->word->word, _("octal number"));
+	      return (EXECUTION_FAILURE);
+	    }
+	}
+      else
+	{
+	  umask_value = symbolic_umask (list);
+	  if (umask_value == -1)
+	    return (EXECUTION_FAILURE);
+	}
+      umask_arg = (mode_t)umask_value;
+      umask (umask_arg);
+      if (print_symbolically)
+	print_symbolic_umask (umask_arg);
+    }
+  else				/* Display the UMASK for this user. */
+    {
+      umask_arg = umask (022);
+      umask (umask_arg);
+
+      if (pflag)
+	printf ("umask%s ", (print_symbolically ? " -S" : ""));
+      if (print_symbolically)
+	print_symbolic_umask (umask_arg);
+      else
+	printf ("%04lo\n", (unsigned long)umask_arg);
+    }
+
+  return (sh_chkwrite (EXECUTION_SUCCESS));
+}
+
+/* Print the umask in a symbolic form.  In the output, a letter is
+   printed if the corresponding bit is clear in the umask. */
+static void
+print_symbolic_umask (um)
+     mode_t um;
+{
+  char ubits[4], gbits[4], obits[4];		/* u=rwx,g=rwx,o=rwx */
+  int i;
+
+  i = 0;
+  if ((um & S_IRUSR) == 0)
+    ubits[i++] = 'r';
+  if ((um & S_IWUSR) == 0)
+    ubits[i++] = 'w';
+  if ((um & S_IXUSR) == 0)
+    ubits[i++] = 'x';
+  ubits[i] = '\0';
+
+  i = 0;
+  if ((um & S_IRGRP) == 0)
+    gbits[i++] = 'r';
+  if ((um & S_IWGRP) == 0)
+    gbits[i++] = 'w';
+  if ((um & S_IXGRP) == 0)
+    gbits[i++] = 'x';
+  gbits[i] = '\0';
+
+  i = 0;
+  if ((um & S_IROTH) == 0)
+    obits[i++] = 'r';
+  if ((um & S_IWOTH) == 0)
+    obits[i++] = 'w';
+  if ((um & S_IXOTH) == 0)
+    obits[i++] = 'x';
+  obits[i] = '\0';
+
+  printf ("u=%s,g=%s,o=%s\n", ubits, gbits, obits);
+}
+
+int
+parse_symbolic_mode (mode, initial_bits)
+     char *mode;
+     int initial_bits;
+{
+  int who, op, perm, bits, c;
+  char *s;
+
+  for (s = mode, bits = initial_bits;;)
+    {
+      who = op = perm = 0;
+
+      /* Parse the `who' portion of the symbolic mode clause. */
+      while (member (*s, "agou"))
+	{
+	  switch (c = *s++)
+	    {
+	    case 'u':
+	      who |= S_IRWXU;
+	      continue;
+	    case 'g':
+	      who |= S_IRWXG;
+	      continue;
+	    case 'o':
+	      who |= S_IRWXO;
+	      continue;
+	    case 'a':
+	      who |= S_IRWXU | S_IRWXG | S_IRWXO;
+	      continue;
+	    default:
+	      break;
+	    }
+	}
+
+      /* The operation is now sitting in *s. */
+      op = *s++;
+      switch (op)
+	{
+	case '+':
+	case '-':
+	case '=':
+	  break;
+	default:
+	  builtin_error (_("`%c': invalid symbolic mode operator"), op);
+	  return (-1);
+	}
+
+      /* Parse out the `perm' section of the symbolic mode clause. */
+      while (member (*s, "rwx"))
+	{
+	  c = *s++;
+
+	  switch (c)
+	    {
+	    case 'r':
+	      perm |= S_IRUGO;
+	      break;
+	    case 'w':
+	      perm |= S_IWUGO;
+	      break;
+	    case 'x':
+	      perm |= S_IXUGO;
+	      break;
+	    }
+	}
+
+      /* Now perform the operation or return an error for a
+	 bad permission string. */
+      if (!*s || *s == ',')
+	{
+	  if (who)
+	    perm &= who;
+
+	  switch (op)
+	    {
+	    case '+':
+	      bits |= perm;
+	      break;
+	    case '-':
+	      bits &= ~perm;
+	      break;
+	    case '=':
+	      if (who == 0)
+		who = S_IRWXU | S_IRWXG | S_IRWXO;
+	      bits &= ~who;
+	      bits |= perm;
+	      break;
+
+	    /* No other values are possible. */
+	    }
+
+	  if (*s == '\0')
+	    break;
+	  else
+	    s++;	/* skip past ',' */
+	}
+      else
+	{
+	  builtin_error (_("`%c': invalid symbolic mode character"), *s);
+	  return (-1);
+	}
+    }
+
+  return (bits);
+}
+
+/* Set the umask from a symbolic mode string similar to that accepted
+   by chmod.  If the -S argument is given, then print the umask in a
+   symbolic form. */
+static int
+symbolic_umask (list)
+     WORD_LIST *list;
+{
+  int um, bits;
+
+  /* Get the initial umask.  Don't change it yet. */
+  um = umask (022);
+  umask (um);
+
+  /* All work is done with the complement of the umask -- it's
+     more intuitive and easier to deal with.  It is complemented
+     again before being returned. */
+  bits = parse_symbolic_mode (list->word->word, ~um & 0777);
+  if (bits == -1)
+    return (-1);
+
+  um = ~bits & 0777;
+  return (um);
+}
diff -Nru bash-4.0-orig/builtins/wait.c bash-4.0/builtins/wait.c
--- bash-4.0-orig/builtins/wait.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/builtins/wait.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,138 @@
+/* wait.c, created from wait.def. */
+#line 38 "./wait.def"
+
+#line 53 "./wait.def"
+
+#include <config.h>
+
+#include "../bashtypes.h"
+#include <signal.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include <chartypes.h>
+
+#include "../bashansi.h"
+
+#include "../shell.h"
+#include "../jobs.h"
+#include "common.h"
+#include "bashgetopt.h"
+
+extern int wait_signal_received;
+
+procenv_t wait_intr_buf;
+
+/* Wait for the pid in LIST to stop or die.  If no arguments are given, then
+   wait for all of the active background processes of the shell and return
+   0.  If a list of pids or job specs are given, return the exit status of
+   the last one waited for. */
+
+#define WAIT_RETURN(s) \
+  do \
+    { \
+      interrupt_immediately = old_interrupt_immediately;\
+      return (s);\
+    } \
+  while (0)
+
+int
+wait_builtin (list)
+     WORD_LIST *list;
+{
+  int status, code;
+  volatile int old_interrupt_immediately;
+
+  USE_VAR(list);
+
+  if (no_options (list))
+    return (EX_USAGE);
+  list = loptend;
+
+  old_interrupt_immediately = interrupt_immediately;
+  interrupt_immediately++;
+
+  /* POSIX.2 says:  When the shell is waiting (by means of the wait utility)
+     for asynchronous commands to complete, the reception of a signal for
+     which a trap has been set shall cause the wait utility to return
+     immediately with an exit status greater than 128, after which the trap
+     associated with the signal shall be taken.
+
+     We handle SIGINT here; it's the only one that needs to be treated
+     specially (I think), since it's handled specially in {no,}jobs.c. */
+  code = setjmp (wait_intr_buf);
+  if (code)
+    {
+      status = 128 + wait_signal_received;
+      WAIT_RETURN (status);
+    }
+
+  /* We support jobs or pids.
+     wait <pid-or-job> [pid-or-job ...] */
+
+  /* But wait without any arguments means to wait for all of the shell's
+     currently active background processes. */
+  if (list == 0)
+    {
+      wait_for_background_pids ();
+      WAIT_RETURN (EXECUTION_SUCCESS);
+    }
+
+  status = EXECUTION_SUCCESS;
+  while (list)
+    {
+      pid_t pid;
+      char *w;
+      intmax_t pid_value;
+
+      w = list->word->word;
+      if (DIGIT (*w))
+	{
+	  if (legal_number (w, &pid_value) && pid_value == (pid_t)pid_value)
+	    {
+	      pid = (pid_t)pid_value;
+	      status = wait_for_single_pid (pid);
+	    }
+	  else
+	    {
+	      sh_badpid (w);
+	      WAIT_RETURN (EXECUTION_FAILURE);
+	    }
+	}
+#if defined (JOB_CONTROL)
+      else if (*w && *w == '%')
+	/* Must be a job spec.  Check it out. */
+	{
+	  int job;
+	  sigset_t set, oset;
+
+	  BLOCK_CHILD (set, oset);
+	  job = get_job_spec (list);
+
+	  if (INVALID_JOB (job))
+	    {
+	      if (job != DUP_JOB)
+		sh_badjob (list->word->word);
+	      UNBLOCK_CHILD (oset);
+	      status = 127;	/* As per Posix.2, section 4.70.2 */
+	      list = list->next;
+	      continue;
+	    }
+
+	  /* Job spec used.  Wait for the last pid in the pipeline. */
+	  UNBLOCK_CHILD (oset);
+	  status = wait_for_job (job);
+	}
+#endif /* JOB_CONTROL */
+      else
+	{
+	  sh_badpid (w);
+	  status = EXECUTION_FAILURE;
+	}
+      list = list->next;
+    }
+
+  WAIT_RETURN (status);
+}
diff -Nru bash-4.0-orig/config-bot.h bash-4.0/config-bot.h
--- bash-4.0-orig/config-bot.h	2009-01-04 20:32:23.000000000 +0100
+++ bash-4.0/config-bot.h	2009-12-08 18:04:03.000000000 +0100
@@ -3,7 +3,7 @@
 
 /* Copyright (C) 1989-2009 Free Software Foundation, Inc.
 
-   This file is part of GNU Bash, the Bourne Again SHell.
+   This file is part of GNU Bash, the Bourne gain SHell.
 
    Bash is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
diff -Nru bash-4.0-orig/config.h bash-4.0/config.h
--- bash-4.0-orig/config.h	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/config.h	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,1084 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h -- Configuration file for bash. */
+
+/* Copyright (C) 1987-2009 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Bash is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+/* Configuration feature settings controllable by autoconf. */
+
+/* Define JOB_CONTROL if your operating system supports
+   BSD-like job control. */
+#define JOB_CONTROL 1
+
+/* Define ALIAS if you want the alias features. */
+#define ALIAS 1
+
+/* Define PUSHD_AND_POPD if you want those commands to be compiled in.
+   (Also the `dirs' commands.) */
+#define PUSHD_AND_POPD 1
+
+/* Define BRACE_EXPANSION if you want curly brace expansion a la Csh:
+   foo{a,b} -> fooa foob.  Even if this is compiled in (the default) you
+   can turn it off at shell startup with `-nobraceexpansion', or during
+   shell execution with `set +o braceexpand'. */
+#define BRACE_EXPANSION 1
+
+/* Define READLINE to get the nifty/glitzy editing features.
+   This is on by default.  You can turn it off interactively
+   with the -nolineediting flag. */
+#define READLINE 1
+
+/* Define BANG_HISTORY if you want to have Csh style "!" history expansion.
+   This is unrelated to READLINE. */
+#define BANG_HISTORY 1
+
+/* Define HISTORY if you want to have access to previously typed commands.
+
+   If both HISTORY and READLINE are defined, you can get at the commands
+   with line editing commands, and you can directly manipulate the history
+   from the command line.
+
+   If only HISTORY is defined, the `fc' and `history' builtins are
+   available. */
+#define HISTORY 1
+
+/* Define this if you want completion that puts all alternatives into
+   a brace expansion shell expression. */
+#if defined (BRACE_EXPANSION) && defined (READLINE)
+#  define BRACE_COMPLETION
+#endif /* BRACE_EXPANSION */
+
+/* Define DEFAULT_ECHO_TO_XPG if you want the echo builtin to interpret
+   the backslash-escape characters by default, like the XPG Single Unix
+   Specification V2 for echo.
+   This requires that V9_ECHO be defined. */
+/* #undef DEFAULT_ECHO_TO_XPG */
+
+/* Define HELP_BUILTIN if you want the `help' shell builtin and the long
+   documentation strings compiled into the shell. */
+#define HELP_BUILTIN 1
+
+/* Define RESTRICTED_SHELL if you want the generated shell to have the
+   ability to be a restricted one.  The shell thus generated can become
+   restricted by being run with the name "rbash", or by setting the -r
+   flag. */
+#define RESTRICTED_SHELL 1
+
+/* Define DISABLED_BUILTINS if you want "builtin foo" to always run the
+   shell builtin "foo", even if it has been disabled with "enable -n foo". */
+/* #undef DISABLED_BUILTINS */
+
+/* Define PROCESS_SUBSTITUTION if you want the K*rn shell-like process
+   substitution features "<(file)". */
+/* Right now, you cannot do this on machines without fully operational
+   FIFO support.  This currently include NeXT and Alliant. */
+#define PROCESS_SUBSTITUTION 1
+
+/* Define PROMPT_STRING_DECODE if you want the backslash-escaped special
+   characters in PS1 and PS2 expanded.  Variable expansion will still be
+   performed. */
+#define PROMPT_STRING_DECODE 1
+
+/* Define SELECT_COMMAND if you want the Korn-shell style `select' command:
+    select word in word_list; do command_list; done */
+#define SELECT_COMMAND 1
+
+/* Define COMMAND_TIMING of you want the ksh-style `time' reserved word and
+   the ability to time pipelines, functions, and builtins. */
+#define COMMAND_TIMING 1
+
+/* Define ARRAY_VARS if you want ksh-style one-dimensional array variables. */
+#define ARRAY_VARS 1
+
+/* Define DPAREN_ARITHMETIC if you want the ksh-style ((...)) arithmetic
+   evaluation command. */
+#define DPAREN_ARITHMETIC 1
+
+/* Define EXTENDED_GLOB if you want the ksh-style [*+@?!](patlist) extended
+   pattern matching. */
+#define EXTENDED_GLOB 1
+
+/* Define COND_COMMAND if you want the ksh-style [[...]] conditional
+   command. */
+#define COND_COMMAND 1
+
+/* Define COND_REGEXP if you want extended regular expression matching and the
+   =~ binary operator in the [[...]] conditional command. */
+#define COND_REGEXP 1
+
+/* Define COPROCESS_SUPPORT if you want support for ksh-like coprocesses and
+   the `coproc' reserved word */
+#define COPROCESS_SUPPORT 1
+
+/* Define ARITH_FOR_COMMAND if you want the ksh93-style
+    for (( init; test; step )) do list; done
+   arithmetic for command. */
+#define ARITH_FOR_COMMAND 1
+
+/* Define NETWORK_REDIRECTIONS if you want /dev/(tcp|udp)/host/port to open
+   socket connections when used in redirections */
+#define NETWORK_REDIRECTIONS 1
+
+/* Define PROGRAMMABLE_COMPLETION for the programmable completion features
+   and the complete builtin. */
+#define PROGRAMMABLE_COMPLETION 1
+
+/* Define NO_MULTIBYTE_SUPPORT to not compile in support for multibyte
+   characters, even if the OS supports them. */
+#define NO_MULTIBYTE_SUPPORT 1
+
+/* Define DEBUGGER if you want to compile in some features used only by the
+   bash debugger. */
+#define DEBUGGER 1
+
+/* Define STRICT_POSIX if you want bash to be strictly posix.2 conformant by
+   default (except for echo; that is controlled separately). */
+/* #undef STRICT_POSIX */
+
+/* Define MEMSCRAMBLE if you want the bash malloc and free to scramble
+   memory contents on malloc() and free(). */
+#define MEMSCRAMBLE 1
+
+/* Define AFS if you are using Transarc's AFS. */
+/* #undef AFS */
+
+/* Define for case-modifying variable attributes; variables modified on
+   assignment */
+#define CASEMOD_ATTRS 1
+
+/* Define for case-modifying word expansions */
+#define CASEMOD_EXPANSIONS 1
+
+#undef ENABLE_NLS
+
+/* End of configuration settings controllable by autoconf. */
+/* Other settable options appear in config-top.h. */
+
+#include "config-top.h"
+
+/* Beginning of autoconf additions. */
+
+/* Characteristics of the C compiler */
+/* #undef const */
+
+/* #undef inline */
+
+#define restrict __restrict
+
+/* #undef volatile */
+
+/* Define if cpp supports the ANSI-C stringizing `#' operator */
+#define HAVE_STRINGIZE 1
+
+/* Define if the compiler supports `long double' variables. */
+#define HAVE_LONG_DOUBLE 1
+
+#define PROTOTYPES 1
+
+/* #undef __CHAR_UNSIGNED__ */
+
+/* Define if the compiler supports `long long' variables. */
+#define HAVE_LONG_LONG 1
+
+#define HAVE_UNSIGNED_LONG_LONG 1
+
+/* The number of bytes in a int.  */
+#define SIZEOF_INT 4
+
+/* The number of bytes in a long.  */
+#define SIZEOF_LONG 4
+
+/* The number of bytes in a pointer to char.  */
+#define SIZEOF_CHAR_P 8
+
+/* The number of bytes in a double (hopefully 8). */
+#define SIZEOF_DOUBLE 8
+
+/* The number of bytes in a `long long', if we have one. */
+#define SIZEOF_LONG_LONG 8
+
+/* System paths */
+
+#define DEFAULT_MAIL_DIRECTORY "/var/mail"
+
+/* Characteristics of the system's header files and libraries that affect
+   the compilation environment. */
+
+/* Define if the system does not provide POSIX.1 features except
+   with this defined.  */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define if you need to in order for stat and other things to work.  */
+/* #undef _POSIX_SOURCE */
+
+/* Define to use GNU libc extensions */
+#define _GNU_SOURCE 1
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+/* Memory management functions. */
+
+/* Define if using the bash version of malloc in lib/malloc/malloc.c */
+/* #undef USING_BASH_MALLOC */
+
+/* #undef DISABLE_MALLOC_WRAPPERS */
+
+/* Define if using alloca.c.  */
+/* #undef C_ALLOCA */
+
+/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
+   This function is required for alloca.c support on those systems.  */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define if you have alloca, as a function or macro.  */
+#define HAVE_ALLOCA 1
+
+/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
+#define HAVE_ALLOCA_H 1
+
+
+/* SYSTEM TYPES */
+
+/* Define to `long' if <sys/types.h> doesn't define.  */
+/* #undef off_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef mode_t */
+
+/* Define to `int' if <signal.h> doesn't define. */
+/* #undef sigset_t */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef pid_t */
+
+/* Define to `short' if <sys/types.h> doesn't define.  */
+#define bits16_t short
+
+/* Define to `unsigned short' if <sys/types.h> doesn't define.  */
+#define u_bits16_t unsigned short
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#define bits32_t int
+
+/* Define to `unsigned int' if <sys/types.h> doesn't define.  */
+#define u_bits32_t unsigned int
+
+/* Define to `double' if <sys/types.h> doesn't define. */
+#define bits64_t char *
+
+/* Define to `unsigned int' if <sys/types.h> doesn't define. */
+/* #undef u_int */
+
+/* Define to `unsigned long' if <sys/types.h> doesn't define.  */
+/* #undef u_long */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef ptrdiff_t */
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+/* #undef size_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef ssize_t */
+
+/* Define to `long' if <stdint.h> doesn't define. */
+/* #undef intmax_t */
+
+/* Define to `unsigned long' if <stdint.h> doesn't define. */
+/* #undef uintmax_t */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef uid_t */
+
+/* Define to `long' if <sys/types.h> doesn't define.  */
+/* #undef clock_t */
+
+/* Define to `long' if <sys/types.h> doesn't define.  */
+/* #undef time_t */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef gid_t */
+
+/* Define to `unsigned int' if <sys/socket.h> doesn't define. */
+/* #undef socklen_t */
+
+/* Define to `int' if <signal.h> doesn't define. */
+/* #undef sig_atomic_t */
+
+#define HAVE_MBSTATE_T 1
+
+/* Define if you have quad_t in <sys/types.h>. */
+#undef HAVE_QUAD_T
+
+/* Define if you have wchar_t in <wctype.h>. */
+#undef HAVE_WCHAR_T
+
+/* Define if you have wctype_t in <wctype.h>. */
+#undef HAVE_WCTYPE_T
+
+/* Define if you have wint_t in <wctype.h>. */
+#undef HAVE_WINT_T
+
+/* #undef RLIMTYPE */
+
+/* Define to the type of elements in the array set by `getgroups'.
+   Usually this is either `int' or `gid_t'.  */
+#define GETGROUPS_T gid_t
+
+/* Characteristics of the machine archictecture. */
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+    STACK_DIRECTION > 0 => grows toward higher addresses
+    STACK_DIRECTION < 0 => grows toward lower addresses
+    STACK_DIRECTION = 0 => direction of growth unknown
+ */
+/* #undef STACK_DIRECTION */
+
+/* Define if the machine architecture is big-endian. */
+/* #undef WORDS_BIGENDIAN */
+
+/* Check for the presence of certain non-function symbols in the system
+   libraries. */
+
+/* Define if `sys_siglist' is declared by <signal.h> or <unistd.h>.  */
+#define HAVE_DECL_SYS_SIGLIST 1
+/* #undef SYS_SIGLIST_DECLARED */
+
+/* Define if `_sys_siglist' is declared by <signal.h> or <unistd.h>.  */
+#define UNDER_SYS_SIGLIST_DECLARED 1
+
+#define HAVE_SYS_SIGLIST 1
+
+#define HAVE_UNDER_SYS_SIGLIST 1
+
+#define HAVE_SYS_ERRLIST 1
+
+/* #undef HAVE_TZNAME */
+/* #undef HAVE_DECL_TZNAME */
+
+/* Characteristics of some of the system structures. */
+
+#define HAVE_STRUCT_DIRENT_D_INO 1
+
+#define HAVE_STRUCT_DIRENT_D_FILENO 1
+
+/* #undef HAVE_STRUCT_DIRENT_D_NAMLEN */
+
+/* #undef TIOCSTAT_IN_SYS_IOCTL */
+
+#define FIONREAD_IN_SYS_IOCTL 1
+
+#define GWINSZ_IN_SYS_IOCTL 1
+
+#define STRUCT_WINSIZE_IN_SYS_IOCTL 1
+
+/* #undef TM_IN_SYS_TIME */
+
+/* #undef STRUCT_WINSIZE_IN_TERMIOS */
+
+/* #undef SPEED_T_IN_SYS_TYPES */
+
+#define TERMIOS_LDISC 1
+
+#define TERMIO_LDISC 1
+
+#define HAVE_STRUCT_STAT_ST_BLOCKS 1
+
+#define HAVE_STRUCT_TM_TM_ZONE 1
+#define HAVE_TM_ZONE 1
+
+#define HAVE_TIMEVAL 1
+
+#define HAVE_STRUCT_TIMEZONE 1
+
+/* Characteristics of definitions in the system header files. */
+
+#define HAVE_GETPW_DECLS 1
+
+/* #undef HAVE_RESOURCE */
+
+/* #undef HAVE_LIBC_FNM_EXTMATCH */
+
+#define HAVE_DECL_CONFSTR 1
+
+#define HAVE_DECL_PRINTF 1
+
+#define HAVE_DECL_SBRK 1
+
+#define HAVE_DECL_STRCPY 1
+
+#define HAVE_DECL_STRSIGNAL 1
+
+#define HAVE_DECL_STRTOLD 0
+
+/* #undef PRI_MACROS_BROKEN */
+
+/* #undef STRTOLD_BROKEN */
+
+/* Define if WCONTINUED is defined in system headers, but rejected by waitpid */
+/* #undef WCONTINUED_BROKEN */
+
+/* These are checked with BASH_CHECK_DECL */
+
+#define HAVE_DECL_STRTOIMAX 1
+#define HAVE_DECL_STRTOL 1
+#define HAVE_DECL_STRTOLL 1
+#define HAVE_DECL_STRTOUL 1
+#define HAVE_DECL_STRTOULL 1
+#define HAVE_DECL_STRTOUMAX 1
+
+/* Characteristics of system calls and C library functions. */
+
+/* Define if the `getpgrp' function takes no argument.  */
+#define GETPGRP_VOID 1
+
+/* #undef NAMED_PIPES_MISSING */
+
+/* #undef OPENDIR_NOT_ROBUST */
+
+/* #undef PGRP_PIPE */
+
+/* Define if the setvbuf function takes the buffering type as its second
+   argument and the buffer pointer as the third, as on System V
+   before release 3.  */
+/* #undef SETVBUF_REVERSED */
+
+/* #undef STAT_MACROS_BROKEN */
+
+#define ULIMIT_MAXFDS 1
+
+#define CAN_REDEFINE_GETENV 1
+
+#define HAVE_STD_PUTENV 1
+
+#define HAVE_STD_UNSETENV 1
+
+#define HAVE_PRINTF_A_FORMAT 1
+
+#define CTYPE_NON_ASCII 1
+
+/* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
+#define HAVE_LANGINFO_CODESET 1
+
+/* Characteristics of properties exported by the kernel. */
+
+/* Define if the kernel can exec files beginning with #! */
+#define HAVE_HASH_BANG_EXEC 1
+
+/* Define if you have the /dev/fd devices to map open files into the file system. */
+#define HAVE_DEV_FD 1
+
+/* Defined to /dev/fd or /proc/self/fd (linux). */
+#define DEV_FD_PREFIX "/dev/fd/"
+
+/* Define if you have the /dev/stdin device. */
+#define HAVE_DEV_STDIN 1
+
+
+/* Type and behavior of signal handling functions. */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define if return type of signal handlers is void */
+#define VOID_SIGHANDLER 1
+
+/* #undef MUST_REINSTALL_SIGHANDLERS */
+
+/* #undef HAVE_BSD_SIGNALS */
+
+#define HAVE_POSIX_SIGNALS 1
+
+/* #undef HAVE_USG_SIGHOLD */
+
+/* #undef UNUSABLE_RT_SIGNALS */
+
+
+/* Presence of system and C library functions. */
+
+/* Define if you have the asprintf function.  */
+#define HAVE_ASPRINTF 1
+
+/* Define if you have the bcopy function.  */
+/* #undef HAVE_BCOPY */
+
+/* Define if you have the bzero function.  */
+/* #undef HAVE_BZERO */
+
+/* Define if you have the confstr function.  */
+#define HAVE_CONFSTR 1
+
+/* Define if you have the dlclose function.  */
+/* #undef HAVE_DLCLOSE */
+
+/* Define if you have the dlopen function.  */
+/* #undef HAVE_DLOPEN */
+
+/* Define if you have the dlsym function.  */
+/* #undef HAVE_DLSYM */
+
+/* Define if you don't have vprintf but do have _doprnt.  */
+/* #undef HAVE_DOPRNT */
+
+/* Define if you have the dup2 function.  */
+#define HAVE_DUP2 1
+
+/* Define if you have the eaccess function.  */
+/* #undef HAVE_EACCESS */
+
+/* Define if you have the fcntl function.  */
+#define HAVE_FCNTL 1
+
+/* Define if you have the fdprintf function. */
+/* #undef HAVE_FDPRINTF */
+
+/* Define if you have the fpurge/__fpurge function.  */
+#define HAVE_FPURGE 1
+/* #undef HAVE___FPURGE */
+#define HAVE_DECL_FPURGE 1
+
+/* Define if you have the getaddrinfo function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define if you have the getcwd function.  */
+#define HAVE_GETCWD 1
+
+/* Define if you have the getdtablesize function.  */
+#define HAVE_GETDTABLESIZE 1
+
+/* Define if you have the getgroups function.  */
+/* #undef HAVE_GETGROUPS */
+
+/* Define if you have the gethostbyname function.  */
+#define HAVE_GETHOSTBYNAME 1
+
+/* Define if you have the gethostname function.  */
+#define HAVE_GETHOSTNAME 1
+
+/* Define if you have the getpagesize function.  */
+#define HAVE_GETPAGESIZE 1
+
+/* Define if you have the getpeername function.  */
+/* #undef HAVE_GETPEERNAME */
+
+/* Define if you have the getpwent function. */
+#define HAVE_GETPWENT 1
+
+/* Define if you have the getpwnam function. */
+#define HAVE_GETPWNAM 1
+
+/* Define if you have the getpwuid function. */
+#define HAVE_GETPWUID 1
+
+/* Define if you have the getrlimit function.  */
+#define HAVE_GETRLIMIT 1
+
+/* Define if you have the getrusage function.  */
+#define HAVE_GETRUSAGE 1
+
+/* Define if you have the getservbyname function.  */
+#define HAVE_GETSERVBYNAME 1
+
+/* Define if you have the getservent function.  */
+/* #undef HAVE_GETSERVENT */
+
+/* Define if you have the gettimeofday function.  */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define if you have the getwd function.  */
+/* #undef HAVE_GETWD */
+
+/* Define if you have the inet_aton function.  */
+#define HAVE_INET_ATON 1
+
+/* Define if you have the isascii function. */
+#define HAVE_ISASCII 1
+
+/* Define if you have the isblank function.  */
+#define HAVE_ISBLANK 1
+
+/* Define if you have the isgraph function.  */
+#define HAVE_ISGRAPH 1
+
+/* Define if you have the isinf function in libc */
+#define HAVE_ISINF_IN_LIBC 1
+
+/* Define if you have the isnan function in libc */
+#define HAVE_ISNAN_IN_LIBC 1
+
+/* Define if you have the isprint function.  */
+#define HAVE_ISPRINT 1
+
+/* Define if you have the isspace function.  */
+#define HAVE_ISSPACE 1
+
+/* Define if you have the iswctype function.  */
+#define HAVE_ISWCTYPE 1
+
+/* Define if you have the iswlower function.  */
+#define HAVE_ISWLOWER 1
+
+/* Define if you have the iswupper function.  */
+#define HAVE_ISWUPPER 1
+
+/* Define if you have the isxdigit function.  */
+#define HAVE_ISXDIGIT 1
+
+/* Define if you have the kill function.  */
+#define HAVE_KILL 1
+
+/* Define if you have the killpg function.  */
+#define HAVE_KILLPG 1
+
+/* Define if you have the lstat function. */
+#define HAVE_LSTAT 1
+
+/* Define if you have the mbrlen function. */
+#define HAVE_MBRLEN 1
+
+/* Define if you have the mbrtowc function. */
+#define HAVE_MBRTOWC 1
+
+/* Define if you have the mbscmp function. */
+/* #undef HAVE_MBSCMP */
+
+/* Define if you have the mbsrtowcs function. */
+#define HAVE_MBSRTOWCS 1
+
+/* Define if you have the memmove function.  */
+#define HAVE_MEMMOVE 1
+
+/* Define if you have the memset function.  */
+#define HAVE_MEMSET 1
+
+/* Define if you have the mkfifo function.  */
+#define HAVE_MKFIFO 1
+
+/* Define if you have the pathconf function. */
+/* #undef HAVE_PATHCONF */
+
+/* Define if you have the putenv function.  */
+#define HAVE_PUTENV 1
+
+/* Define if you have the raise function. */
+#define HAVE_RAISE 1
+
+/* Define if you have the readlink function. */
+#define HAVE_READLINK 1
+
+/* Define if you have the regcomp function. */
+#define HAVE_REGCOMP 1
+
+/* Define if you have the regexec function. */
+#define HAVE_REGEXEC 1
+
+/* Define if you have the rename function. */
+#define HAVE_RENAME 1
+
+/* Define if you have the sbrk function. */
+#define HAVE_SBRK 1
+
+/* Define if you have the select function.  */
+#define HAVE_SELECT 1
+
+/* Define if you have the setdtablesize function.  */
+/* #undef HAVE_SETDTABLESIZE */
+
+/* Define if you have the setenv function.  */
+#define HAVE_SETENV 1
+
+/* Define if you have the setitimer function.  */
+/* #undef HAVE_SETITIMER */
+
+/* Define if you have the setlinebuf function.  */
+#define HAVE_SETLINEBUF 1
+
+/* Define if you have the setlocale function.  */
+#define HAVE_SETLOCALE 1
+
+/* Define if you have the setostype function.  */
+/* #undef HAVE_SETOSTYPE */
+
+/* Define if you have the setregid function.  */
+/* #undef HAVE_SETREGID */
+#define HAVE_DECL_SETREGID 1
+
+/* Define if you have the setvbuf function.  */
+#define HAVE_SETVBUF 1
+
+/* Define if you have the siginterrupt function.  */
+#define HAVE_SIGINTERRUPT 1
+
+/* Define if you have the POSIX.1-style sigsetjmp function.  */
+#undef HAVE_POSIX_SIGSETJMP
+
+/* Define if you have the snprintf function.  */
+#define HAVE_SNPRINTF 1
+
+/* Define if you have the strcasecmp function.  */
+#define HAVE_STRCASECMP 1
+
+/* Define if you have the strchr function.  */
+#define HAVE_STRCHR 1
+
+/* Define if you have the strcoll function.  */
+/* #undef HAVE_STRCOLL */
+
+/* Define if you have the strerror function.  */
+#define HAVE_STRERROR 1
+
+/* Define if you have the strftime function. */
+#define HAVE_STRFTIME 1
+
+/* Define if you have the strnlen function. */
+#define HAVE_STRNLEN 1
+
+/* Define if you have the strpbrk function. */
+#define HAVE_STRPBRK 1
+
+/* Define if you have the strstr function. */
+#define HAVE_STRSTR 1
+
+/* Define if you have the strtod function. */
+#define HAVE_STRTOD 1
+
+/* Define if you have the strtoimax function. */
+#define HAVE_STRTOIMAX 1
+
+/* Define if you have the strtol function. */
+#define HAVE_STRTOL 1
+
+/* Define if you have the strtoll function. */
+#define HAVE_STRTOLL 1
+
+/* Define if you have the strtoul function. */
+#define HAVE_STRTOUL 1
+
+/* Define if you have the strtoull function. */
+#define HAVE_STRTOULL 1
+
+/* Define if you have the strtoumax function. */
+#define HAVE_STRTOUMAX 1
+
+/* Define if you have the strsignal function or macro. */
+#define HAVE_STRSIGNAL 1
+
+/* Define if you have the sysconf function. */
+#define HAVE_SYSCONF 1
+
+/* Define if you have the tcgetattr function.  */
+#define HAVE_TCGETATTR 1
+
+/* Define if you have the tcgetpgrp function.  */
+#define HAVE_TCGETPGRP 1
+
+/* Define if you have the times function.  */
+/* #undef HAVE_TIMES */
+
+/* Define if you have the towlower function.  */
+#define HAVE_TOWLOWER 1
+
+/* Define if you have the towupper function.  */
+#define HAVE_TOWUPPER 1
+
+/* Define if you have the ttyname function.  */
+#define HAVE_TTYNAME 1
+
+/* Define if you have the tzset function. */
+#define HAVE_TZSET 1
+
+/* Define if you have the ulimit function. */
+/* #undef HAVE_ULIMIT */
+
+/* Define if you have the uname function. */
+#define HAVE_UNAME 1
+
+/* Define if you have the unsetenv function.  */
+#define HAVE_UNSETENV 1
+
+/* Define if you have the vasprintf function.  */
+#define HAVE_VASPRINTF 1
+
+/* Define if you have the vprintf function.  */
+#define HAVE_VPRINTF 1
+
+/* Define if you have the vsnprintf function.  */
+#define HAVE_VSNPRINTF 1
+
+/* Define if you have the waitpid function. */
+#define HAVE_WAITPID 1
+
+/* Define if you have the wait3 function.  */
+#define HAVE_WAIT3 1
+
+/* Define if you have the wcrtomb function.  */
+#define HAVE_WCRTOMB 1
+
+/* Define if you have the wcscoll function.  */
+#define HAVE_WCSCOLL 1
+
+/* Define if you have the wcsdup function.  */
+#define HAVE_WCSDUP 1
+
+/* Define if you have the wctype function.  */
+#define HAVE_WCTYPE 1
+
+/* Define if you have the wcwidth function.  */
+#define HAVE_WCWIDTH 1
+
+/* Presence of certain system include files. */
+
+/* Define if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define if you have the <dirent.h> header file.  */
+#define HAVE_DIRENT_H 1
+
+/* Define if you have the <dlfcn.h> header file.  */
+/* #undef HAVE_DLFCN_H */
+
+/* Define if you have the <grp.h> header file.  */
+/* #undef HAVE_GRP_H */
+
+/* Define if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if you have the <langinfo.h> header file.  */
+#define HAVE_LANGINFO_H 1
+
+/* Define if you have the <libintl.h> header file. */
+/* #undef HAVE_LIBINTL_H */
+
+/* Define if you have the <limits.h> header file.  */
+#define HAVE_LIMITS_H 1
+
+/* Define if you have the <locale.h> header file.  */
+#define HAVE_LOCALE_H 1
+
+/* Define if you have the <ndir.h> header file.  */
+/* #undef HAVE_NDIR_H */
+
+/* Define if you have the <netdh.h> header file. */
+/* #undef HAVE_NETDB_H */
+
+/* Define if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define if you have the <pwd.h> header file. */
+#define HAVE_PWD_H 1
+
+/* Define if you have the <regex.h> header file. */
+#define HAVE_REGEX_H 1
+
+/* Define if you have the <stdlib.h> header file.  */
+#define HAVE_STDLIB_H 1
+
+/* Define if you have the <stdarg.h> header file.  */
+#define HAVE_STDARG_H 1
+
+/* Define if you have the <string.h> header file.  */
+#define HAVE_STRING_H 1
+
+/* Define if you have the <strings.h> header file.  */
+#define HAVE_STRINGS_H 1
+
+/* Define if you have the <memory.h> header file.  */
+#define HAVE_MEMORY_H 1
+
+/* Define if you have the <stddef.h> header file. */
+#define HAVE_STDDEF_H 1
+
+/* Define if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define if you have the <sys/dir.h> header file.  */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define if you have the <sys/file.h> header file.  */
+#undef HAVE_SYS_FILE_H
+
+/* Define if you have the <sys/ndir.h> header file.  */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define if you have the <sys/param.h> header file.  */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define if you have the <sys/pte.h> header file.  */
+/* #undef HAVE_SYS_PTE_H */
+
+/* Define if you have the <sys/ptem.h> header file.  */
+/* #undef HAVE_SYS_PTEM_H */
+
+/* Define if you have the <sys/resource.h> header file.  */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define if you have the <sys/select.h> header file.  */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define if you have the <sys/socket.h> header file.  */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define if you have the <sys/stream.h> header file.  */
+/* #undef HAVE_SYS_STREAM_H */
+
+/* Define if you have <sys/time.h> */
+#define HAVE_SYS_TIME_H 1
+
+#define TIME_WITH_SYS_TIME 1
+
+/* Define if you have <sys/times.h> */
+/* #undef HAVE_SYS_TIMES_H */
+
+/* Define if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define if you have the <termcap.h> header file.  */
+#define HAVE_TERMCAP_H 1
+
+/* Define if you have the <termio.h> header file.  */
+#define HAVE_TERMIO_H 1
+
+/* Define if you have the <termios.h> header file.  */
+#define HAVE_TERMIOS_H 1
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
+
+/* Define if you have the <varargs.h> header file.  */
+/* #undef HAVE_VARARGS_H */
+
+/* Define if you have the <wchar.h> header file.  */
+#undef HAVE_WCHAR_H
+
+/* Define if you have the <varargs.h> header file.  */
+#undef HAVE_WCTYPE_H
+
+/* Presence of certain system libraries. */
+
+/* #undef HAVE_LIBDL */
+
+/* #undef HAVE_LIBSUN */
+
+/* #undef HAVE_LIBSOCKET */
+
+
+/* Define if on MINIX.  */
+/* #undef _MINIX */
+
+/* Are we running SVR5 (UnixWare 7)? */
+/* #undef SVR5 */
+
+/* Are we running SVR4.2? */
+/* #undef SVR4_2 */
+
+/* Are we running some version of SVR4? */
+/* #undef SVR4 */
+
+/* Define if job control is unusable or unsupported. */
+/* #undef JOB_CONTROL_MISSING */
+
+/* Do we need to define _KERNEL to get the RLIMIT_* defines from
+   <sys/resource.h>? */
+/* #undef RLIMIT_NEEDS_KERNEL */
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Do strcoll(3) and strcmp(3) give different results in the default locale? */
+/* #undef STRCOLL_BROKEN */
+
+/* #undef DUP2_BROKEN */
+
+/* #undef GETCWD_BROKEN */
+
+/* Additional defines for configuring lib/intl, maintained by autoscan/autoheader */
+
+/* Define if you have the <argz.h> header file. */
+#define HAVE_ARGZ_H 1
+
+/* Define if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define if you have the <stdio_ext.h> header file. */
+#define HAVE_STDIO_EXT_H 1
+
+/* Define if you have the `dcgettext' function. */
+#define HAVE_DCGETTEXT 1
+
+/* Define if you have the `localeconv' function. */
+#define HAVE_LOCALECONV 1
+
+/* Define if your system has a working `malloc' function. */
+/* #undef HAVE_MALLOC */
+
+/* Define if you have the `mempcpy' function. */
+#define HAVE_MEMPCPY 1
+
+/* Define if you have a working `mmap' system call. */
+#define HAVE_MMAP 1
+
+/* Define if you have the `munmap' function. */
+#define HAVE_MUNMAP 1
+
+/* Define if you have the `nl_langinfo' function. */
+/* #undef HAVE_NL_LANGINFO */
+
+/* Define if you have the `stpcpy' function. */
+#define HAVE_STPCPY 1
+
+/* Define if you have the `strcspn' function. */
+#define HAVE_STRCSPN 1
+
+/* Define if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define if you have the `__argz_count' function. */
+#define HAVE___ARGZ_COUNT 1
+
+/* Define if you have the `__argz_next' function. */
+#define HAVE___ARGZ_NEXT 1
+
+/* Define if you have the `__argz_stringify' function. */
+#define HAVE___ARGZ_STRINGIFY 1
+
+/* End additions for lib/intl */
+
+#include "config-bot.h"
+
+#endif /* _CONFIG_H_ */
diff -Nru bash-4.0-orig/doc/bash.1 bash-4.0/doc/bash.1
--- bash-4.0-orig/doc/bash.1	2009-02-18 21:13:56.000000000 +0100
+++ bash-4.0/doc/bash.1	2009-12-08 18:04:03.000000000 +0100
@@ -8257,9 +8257,10 @@
 Exit after reading and executing one command.
 .TP 8
 .B \-u
-Treat unset variables as an error when performing
+Treat unset variables and parameters other than the special
+parameters "@" and "*" as an error when performing
 parameter expansion.  If expansion is attempted on an
-unset variable, the shell prints an error message, and,
+unset variable or parameter, the shell prints an error message, and,
 if not interactive, exits with a non-zero status.
 .TP 8
 .B \-v
diff -Nru bash-4.0-orig/doc/bashref.texi bash-4.0/doc/bashref.texi
--- bash-4.0-orig/doc/bashref.texi	2009-02-18 21:14:43.000000000 +0100
+++ bash-4.0/doc/bashref.texi	2009-12-08 18:04:03.000000000 +0100
@@ -4138,7 +4138,8 @@
 Exit after reading and executing one command.
 
 @item -u
-Treat unset variables as an error when performing parameter expansion.
+Treat unset variables and parameters other than the special parameters
+@samp{@@} or @samp{*} as an error when performing parameter expansion.
 An error message will be written to the standard error, and a non-interactive
 shell will exit.
 
diff -Nru bash-4.0-orig/eval.c bash-4.0/eval.c
--- bash-4.0-orig/eval.c	2009-01-04 20:32:26.000000000 +0100
+++ bash-4.0/eval.c	2009-12-08 18:04:03.000000000 +0100
@@ -142,7 +142,7 @@
 	      dispose_command (global_command);
 	      global_command = (COMMAND *)NULL;
 	    }
-	  else if (current_command = global_command)
+	  else if ((current_command = global_command))
 	    {
 	      global_command = (COMMAND *)NULL;
 	      current_command_number++;
diff -Nru bash-4.0-orig/execute_cmd.c bash-4.0/execute_cmd.c
--- bash-4.0-orig/execute_cmd.c	2009-02-13 22:41:41.000000000 +0100
+++ bash-4.0/execute_cmd.c	2009-12-08 18:04:03.000000000 +0100
@@ -568,6 +568,7 @@
 
       /* Fork a subshell, turn off the subshell bit, turn off job
 	 control and call execute_command () on the command again. */
+      line_number_for_err_trap = line_number;
       paren_pid = make_child (savestring (make_command_string (command)),
 			      asynchronous);
       if (paren_pid == 0)
@@ -610,7 +611,10 @@
 	      if (user_subshell && was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
 		{
 		  last_command_exit_value = exec_result;
+		  save_line_number = line_number;
+		  line_number = line_number_for_err_trap;
 		  run_error_trap ();
+		  line_number = save_line_number;
 		}
 
 	      if (user_subshell && ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
@@ -766,7 +770,9 @@
       if (was_error_trap && ignore_return == 0 && invert == 0 && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)
 	{
 	  last_command_exit_value = exec_result;
+	  line_number = line_number_for_err_trap;
 	  run_error_trap ();
+	  line_number = save_line_number;
 	}
 
       if (ignore_return == 0 && invert == 0 &&
@@ -2105,6 +2111,7 @@
   REDIRECT *rp;
   COMMAND *tc, *second;
   int ignore_return, exec_result, was_error_trap, invert;
+  volatile int save_line_number;
 
   ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;
 
@@ -2174,12 +2181,16 @@
       invert = (command->flags & CMD_INVERT_RETURN) != 0;
       ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;
 
+      line_number_for_err_trap = line_number;
       exec_result = execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close);
 
       if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
 	{
 	  last_command_exit_value = exec_result;
+	  save_line_number = line_number;
+	  line_number = line_number_for_err_trap;
 	  run_error_trap ();
+	  line_number = save_line_number;
 	}
 
       if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
@@ -2930,7 +2941,7 @@
 		  retval = execute_command (clauses->action);
 		}
 	      while ((clauses->flags & CASEPAT_FALLTHROUGH) && (clauses = clauses->next));
-	      if ((clauses->flags & CASEPAT_TESTNEXT) == 0)
+	      if (clauses == 0 || (clauses->flags & CASEPAT_TESTNEXT) == 0)
 		EXIT_CASE ();
 	      else
 		break;
diff -Nru bash-4.0-orig/externs.h bash-4.0/externs.h
--- bash-4.0-orig/externs.h	2009-01-19 00:29:29.000000000 +0100
+++ bash-4.0/externs.h	2009-12-08 18:04:03.000000000 +0100
@@ -24,6 +24,8 @@
 #if !defined (_EXTERNS_H_)
 #  define _EXTERNS_H_
 
+#include <stdio.h>
+
 #include "stdc.h"
 
 /* Functions from expr.c. */
@@ -192,6 +194,8 @@
 extern char *fmtumax __P((uintmax_t, int, char *, size_t, int));
 
 /* Declarations for functions defined in lib/sh/fpurge.c */
+
+#if defined NEED_FPURGE_DECL
 #if !HAVE_DECL_FPURGE
 
 #if HAVE_FPURGE
@@ -200,7 +204,7 @@
 extern int fpurge __P((FILE *stream));
 
 #endif /* HAVE_DECL_FPURGE */
-
+#endif /* NEED_FPURGE_DECL */
 
 /* Declarations for functions defined in lib/sh/getcwd.c */
 #if !defined (HAVE_GETCWD)
diff -Nru bash-4.0-orig/externs.h.orig bash-4.0/externs.h.orig
--- bash-4.0-orig/externs.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/externs.h.orig	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,452 @@
+/* externs.h -- extern function declarations which do not appear in their
+   own header file. */
+
+/* Copyright (C) 1993-2009 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Bash is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/* Make sure that this is included *after* config.h! */
+
+#if !defined (_EXTERNS_H_)
+#  define _EXTERNS_H_
+
+#include <stdio.h>
+
+#include "stdc.h"
+
+/* Functions from expr.c. */
+extern intmax_t evalexp __P((char *, int *));
+
+/* Functions from print_cmd.c. */
+#define FUNC_MULTILINE	0x01
+#define FUNC_EXTERNAL	0x02
+
+extern char *make_command_string __P((COMMAND *));
+extern char *named_function_string __P((char *, COMMAND *, int));
+
+extern void print_command __P((COMMAND *));
+extern void print_simple_command __P((SIMPLE_COM *));
+extern void print_word_list __P((WORD_LIST *, char *));
+
+/* debugger support */
+extern void print_for_command_head __P((FOR_COM *));
+#if defined (SELECT_COMMAND)
+extern void print_select_command_head __P((SELECT_COM *));
+#endif
+extern void print_case_command_head __P((CASE_COM *));
+#if defined (DPAREN_ARITHMETIC)
+extern void print_arith_command __P((WORD_LIST *));
+#endif
+#if defined (COND_COMMAND)
+extern void print_cond_command __P((COND_COM *));
+#endif
+
+/* set -x support */
+extern char *indirection_level_string __P((void));
+extern void xtrace_print_assignment __P((char *, char *, int, int));
+extern void xtrace_print_word_list __P((WORD_LIST *, int));
+extern void xtrace_print_for_command_head __P((FOR_COM *));
+#if defined (SELECT_COMMAND)
+extern void xtrace_print_select_command_head __P((SELECT_COM *));
+#endif
+extern void xtrace_print_case_command_head __P((CASE_COM *));
+#if defined (DPAREN_ARITHMETIC)
+extern void xtrace_print_arith_cmd __P((WORD_LIST *));
+#endif
+#if defined (COND_COMMAND)
+extern void xtrace_print_cond_term __P((int, int, WORD_DESC *, char *, char *));
+#endif
+
+/* Functions from shell.c. */
+extern void exit_shell __P((int)) __attribute__((__noreturn__));
+extern void sh_exit __P((int)) __attribute__((__noreturn__));
+extern void disable_priv_mode __P((void));
+extern void unbind_args __P((void));
+
+#if defined (RESTRICTED_SHELL)
+extern int shell_is_restricted __P((char *));
+extern int maybe_make_restricted __P((char *));
+#endif
+
+extern void unset_bash_input __P((int));
+extern void get_current_user_info __P((void));
+
+/* Functions from eval.c. */
+extern int reader_loop __P((void));
+extern int parse_command __P((void));
+extern int read_command __P((void));
+
+/* Functions from braces.c. */
+#if defined (BRACE_EXPANSION)
+extern char **brace_expand __P((char *));
+#endif
+
+/* Miscellaneous functions from parse.y */
+extern int yyparse __P((void));
+extern int return_EOF __P((void));
+extern char *xparse_dolparen __P((char *, char *, int *, int));
+extern void reset_parser __P((void));
+extern WORD_LIST *parse_string_to_word_list __P((char *, int, const char *));
+
+extern void free_pushed_string_input __P((void));
+
+extern char *decode_prompt_string __P((char *));
+
+extern int get_current_prompt_level __P((void));
+extern void set_current_prompt_level __P((int));
+
+#if defined (HISTORY)
+extern char *history_delimiting_chars __P((void));
+#endif
+
+/* Declarations for functions defined in locale.c */
+extern void set_default_locale __P((void));
+extern void set_default_locale_vars __P((void));
+extern int set_locale_var __P((char *, char *));
+extern int set_lang __P((char *, char *));
+extern void set_default_lang __P((void));
+extern char *get_locale_var __P((char *));
+extern char *localetrans __P((char *, int, int *));
+extern char *mk_msgstr __P((char *, int *));
+extern char *localeexpand __P((char *, int, int, int, int *));
+
+/* Declarations for functions defined in list.c. */
+extern void list_walk __P((GENERIC_LIST *, sh_glist_func_t *));
+extern void wlist_walk __P((WORD_LIST *, sh_icpfunc_t *));
+extern GENERIC_LIST *list_reverse ();
+extern int list_length ();
+extern GENERIC_LIST *list_append ();
+extern GENERIC_LIST *list_remove ();
+
+/* Declarations for functions defined in stringlib.c */
+extern int find_string_in_alist __P((char *, STRING_INT_ALIST *, int));
+extern char *find_token_in_alist __P((int, STRING_INT_ALIST *, int));
+extern int find_index_in_alist __P((char *, STRING_INT_ALIST *, int));
+
+extern char *substring __P((char *, int, int));
+extern char *strsub __P((char *, char *, char *, int));
+extern char *strcreplace __P((char *, int, char *, int));
+extern void strip_leading __P((char *));
+extern void strip_trailing __P((char *, int, int));
+extern void xbcopy __P((char *, char *, int));
+
+/* Functions from version.c. */
+extern char *shell_version_string __P((void));
+extern void show_shell_version __P((int));
+
+/* Functions from the bash library, lib/sh/libsh.a.  These should really
+   go into a separate include file. */
+
+/* declarations for functions defined in lib/sh/casemod.c */
+extern char *sh_modcase __P((const char *, char *, int));
+
+/* Defines for flags argument to sh_modcase.  These need to agree with what's
+   in lib/sh/casemode.c */
+#define CASE_LOWER	0x0001
+#define CASE_UPPER	0x0002
+#define CASE_CAPITALIZE	0x0004
+#define CASE_UNCAP	0x0008
+#define CASE_TOGGLE	0x0010
+#define CASE_TOGGLEALL	0x0020
+#define CASE_UPFIRST	0x0040
+#define CASE_LOWFIRST	0x0080
+
+#define CASE_USEWORDS	0x1000
+
+/* declarations for functions defined in lib/sh/clktck.c */
+extern long get_clk_tck __P((void));
+
+/* declarations for functions defined in lib/sh/clock.c */
+extern void clock_t_to_secs ();
+extern void print_clock_t ();
+
+/* Declarations for functions defined in lib/sh/fdprintf.c */
+extern void fdprintf __P((int, const char *, ...))  __attribute__((__format__ (printf, 2, 3)));
+
+/* Declarations for functions defined in lib/sh/fmtulong.c */
+#define FL_PREFIX     0x01    /* add 0x, 0X, or 0 prefix as appropriate */
+#define FL_ADDBASE    0x02    /* add base# prefix to converted value */
+#define FL_HEXUPPER   0x04    /* use uppercase when converting to hex */
+#define FL_UNSIGNED   0x08    /* don't add any sign */
+
+extern char *fmtulong __P((unsigned long int, int, char *, size_t, int));
+
+/* Declarations for functions defined in lib/sh/fmtulong.c */
+#if defined (HAVE_LONG_LONG)
+extern char *fmtullong __P((unsigned long long int, int, char *, size_t, int));
+#endif
+
+/* Declarations for functions defined in lib/sh/fmtumax.c */
+extern char *fmtumax __P((uintmax_t, int, char *, size_t, int));
+
+/* Declarations for functions defined in lib/sh/fpurge.c */
+#if !HAVE_DECL_FPURGE
+
+#if HAVE_FPURGE
+#  define fpurge _bash_fpurge
+#endif
+extern int fpurge __P((FILE *stream));
+
+#endif /* HAVE_DECL_FPURGE */
+
+
+/* Declarations for functions defined in lib/sh/getcwd.c */
+#if !defined (HAVE_GETCWD)
+extern char *getcwd __P((char *, size_t));
+#endif
+
+/* Declarations for functions defined in lib/sh/input_avail.c */
+extern int input_avail __P((int));
+
+/* Declarations for functions defined in lib/sh/itos.c */
+extern char *inttostr __P((intmax_t, char *, size_t));
+extern char *itos __P((intmax_t));
+extern char *uinttostr __P((uintmax_t, char *, size_t));
+extern char *uitos __P((uintmax_t));
+
+/* declarations for functions defined in lib/sh/makepath.c */
+#define MP_DOTILDE	0x01
+#define MP_DOCWD	0x02
+#define MP_RMDOT	0x04
+#define MP_IGNDOT	0x08
+
+extern char *sh_makepath __P((const char *, const char *, int));
+
+/* declarations for functions defined in lib/sh/netconn.c */
+extern int isnetconn __P((int));
+
+/* declarations for functions defined in lib/sh/netopen.c */
+extern int netopen __P((char *));
+
+/* Declarations for  functions defined in lib/sh/oslib.c */
+
+#if !defined (HAVE_DUP2) || defined (DUP2_BROKEN)
+extern int dup2 __P((int, int));
+#endif
+
+#if !defined (HAVE_GETDTABLESIZE)
+extern int getdtablesize __P((void));
+#endif /* !HAVE_GETDTABLESIZE */
+
+#if !defined (HAVE_GETHOSTNAME)
+extern int gethostname __P((char *, int));
+#endif /* !HAVE_GETHOSTNAME */
+
+extern int getmaxgroups __P((void));
+extern long getmaxchild __P((void));
+
+/* declarations for functions defined in lib/sh/pathcanon.c */
+#define PATH_CHECKDOTDOT	0x0001
+#define PATH_CHECKEXISTS	0x0002
+#define PATH_HARDPATH		0x0004
+#define PATH_NOALLOC		0x0008
+
+extern char *sh_canonpath __P((char *, int));
+
+/* declarations for functions defined in lib/sh/pathphys.c */
+extern char *sh_physpath __P((char *, int));
+extern char *sh_realpath __P((const char *, char *));
+
+/* declarations for functions defined in lib/sh/setlinebuf.c */
+#ifdef NEED_SH_SETLINEBUF_DECL
+extern int sh_setlinebuf __P((FILE *));
+#endif
+
+/* declarations for functions defined in lib/sh/shaccess.c */
+extern int sh_eaccess __P((char *, int));
+
+/* declarations for functions defined in lib/sh/shmatch.c */
+extern int sh_regmatch __P((const char *, const char *, int));
+
+/* defines for flags argument to sh_regmatch. */
+#define SHMAT_SUBEXP		0x001	/* save subexpressions in SH_REMATCH */
+#define SHMAT_PWARN		0x002	/* print a warning message on invalid regexp */
+
+/* declarations for functions defined in lib/sh/shquote.c */
+extern char *sh_single_quote __P((char *));
+extern char *sh_double_quote __P((char *));
+extern char *sh_mkdoublequoted __P((const char *, int, int));
+extern char *sh_un_double_quote __P((char *));
+extern char *sh_backslash_quote __P((char *));
+extern char *sh_backslash_quote_for_double_quotes __P((char *));
+extern int sh_contains_shell_metas __P((char *));
+
+/* declarations for functions defined in lib/sh/spell.c */
+extern int spname __P((char *, char *));
+extern char *dirspell __P((char *));
+
+/* declarations for functions defined in lib/sh/strcasecmp.c */
+#if !defined (HAVE_STRCASECMP)
+extern int strncasecmp __P((const char *, const char *, int));
+extern int strcasecmp __P((const char *, const char *));
+#endif /* HAVE_STRCASECMP */
+
+/* declarations for functions defined in lib/sh/strerror.c */
+#if !defined (HAVE_STRERROR) && !defined (strerror)
+extern char *strerror __P((int));
+#endif
+
+/* declarations for functions defined in lib/sh/strftime.c */
+#if !defined (HAVE_STRFTIME) && defined (NEED_STRFTIME_DECL)
+extern size_t strftime __P((char *, size_t, const char *, const struct tm *));
+#endif
+
+/* declarations for functions defined in lib/sh/strindex.c */
+extern char *strindex __P((const char *, const char *));
+
+/* declarations for functions and structures defined in lib/sh/stringlist.c */
+
+/* This is a general-purpose argv-style array struct. */
+typedef struct _list_of_strings {
+  char **list;
+  int list_size;
+  int list_len;
+} STRINGLIST;
+
+typedef int sh_strlist_map_func_t __P((char *));
+
+extern STRINGLIST *strlist_create __P((int));
+extern STRINGLIST *strlist_resize __P((STRINGLIST *, int));
+extern void strlist_flush __P((STRINGLIST *));
+extern void strlist_dispose __P((STRINGLIST *));
+extern int strlist_remove __P((STRINGLIST *, char *));
+extern STRINGLIST *strlist_copy __P((STRINGLIST *));
+extern STRINGLIST *strlist_merge __P((STRINGLIST *, STRINGLIST *));
+extern STRINGLIST *strlist_append __P((STRINGLIST *, STRINGLIST *));
+extern STRINGLIST *strlist_prefix_suffix __P((STRINGLIST *, char *, char *));
+extern void strlist_print __P((STRINGLIST *, char *));
+extern void strlist_walk __P((STRINGLIST *, sh_strlist_map_func_t *));
+extern void strlist_sort __P((STRINGLIST *));
+
+/* declarations for functions defined in lib/sh/stringvec.c */
+
+extern char **strvec_create __P((int));
+extern char **strvec_resize __P((char **, int));
+extern void strvec_flush __P((char **));
+extern void strvec_dispose __P((char **));
+extern int strvec_remove __P((char **, char *));
+extern int strvec_len __P((char **));
+extern int strvec_search __P((char **, char *));
+extern char **strvec_copy __P((char **));
+extern int strvec_strcmp __P((char **, char **));
+extern void strvec_sort __P((char **));
+
+extern char **strvec_from_word_list __P((WORD_LIST *, int, int, int *));
+extern WORD_LIST *strvec_to_word_list __P((char **, int, int));
+
+/* declarations for functions defined in lib/sh/strnlen.c */
+#if !defined (HAVE_STRNLEN)
+extern size_t strnlen __P((const char *, size_t));
+#endif
+
+/* declarations for functions defined in lib/sh/strpbrk.c */
+#if !defined (HAVE_STRPBRK)
+extern char *strpbrk __P((const char *, const char *));
+#endif
+
+/* declarations for functions defined in lib/sh/strtod.c */
+#if !defined (HAVE_STRTOD)
+extern double strtod __P((const char *, char **));
+#endif
+
+/* declarations for functions defined in lib/sh/strtol.c */
+#if !HAVE_DECL_STRTOL
+extern long strtol __P((const char *, char **, int));
+#endif
+
+/* declarations for functions defined in lib/sh/strtoll.c */
+#if defined (HAVE_LONG_LONG) && !HAVE_DECL_STRTOLL
+extern long long strtoll __P((const char *, char **, int));
+#endif
+
+/* declarations for functions defined in lib/sh/strtoul.c */
+#if !HAVE_DECL_STRTOUL
+extern unsigned long strtoul __P((const char *, char **, int));
+#endif
+
+/* declarations for functions defined in lib/sh/strtoull.c */
+#if defined (HAVE_LONG_LONG) && !HAVE_DECL_STRTOULL
+extern unsigned long long strtoull __P((const char *, char **, int));
+#endif
+
+/* declarations for functions defined in lib/sh/strimax.c */
+#if !HAVE_DECL_STRTOIMAX
+extern intmax_t strtoimax __P((const char *, char **, int));
+#endif
+
+/* declarations for functions defined in lib/sh/strumax.c */
+#if !HAVE_DECL_STRTOUMAX
+extern uintmax_t strtoumax __P((const char *, char **, int));
+#endif
+
+/* declarations for functions defined in lib/sh/strtrans.c */
+extern char *ansicstr __P((char *, int, int, int *, int *));
+extern char *ansic_quote __P((char *, int, int *));
+extern int ansic_shouldquote __P((const char *));
+extern char *ansiexpand __P((char *, int, int, int *));
+
+/* declarations for functions defined in lib/sh/timeval.c.  No prototypes
+   so we don't have to count on having a definition of struct timeval in
+   scope when this file is included. */
+extern void timeval_to_secs ();
+extern void print_timeval ();
+
+/* declarations for functions defined in lib/sh/tmpfile.c */
+#define MT_USETMPDIR		0x0001
+#define MT_READWRITE		0x0002
+#define MT_USERANDOM		0x0004
+
+extern char *sh_mktmpname __P((char *, int));
+extern int sh_mktmpfd __P((char *, int, char **));
+/* extern FILE *sh_mktmpfp __P((char *, int, char **)); */
+
+/* declarations for functions defined in lib/sh/uconvert.c */
+extern int uconvert __P((char *, long *, long *));
+
+/* declarations for functions defined in lib/sh/ufuncs.c */
+extern unsigned int falarm __P((unsigned int, unsigned int));
+extern unsigned int fsleep __P((unsigned int, unsigned int));
+
+/* declarations for functions defined in lib/sh/winsize.c */
+extern void get_new_window_size __P((int, int *, int *));
+
+/* declarations for functions defined in lib/sh/xstrchr.c */
+#undef xstrchr
+extern char *xstrchr __P((const char *, int));
+
+/* declarations for functions defined in lib/sh/zcatfd.c */
+extern int zcatfd __P((int, int, char *));
+
+/* declarations for functions defined in lib/sh/zgetline.c */
+extern ssize_t zgetline __P((int, char **, size_t *, int));
+
+/* declarations for functions defined in lib/sh/zmapfd.c */
+extern int zmapfd __P((int, char **, char *));
+
+/* declarations for functions defined in lib/sh/zread.c */
+extern ssize_t zread __P((int, char *, size_t));
+extern ssize_t zreadretry __P((int, char *, size_t));
+extern ssize_t zreadintr __P((int, char *, size_t));
+extern ssize_t zreadc __P((int, char *));
+extern ssize_t zreadcintr __P((int, char *));
+extern void zreset __P((void));
+extern void zsyncfd __P((int));
+
+/* declarations for functions defined in lib/sh/zwrite.c */
+extern int zwrite __P((int, char *, size_t));
+
+#endif /* _EXTERNS_H_ */
diff -Nru bash-4.0-orig/jobs.c bash-4.0/jobs.c
--- bash-4.0-orig/jobs.c	2009-01-29 23:09:49.000000000 +0100
+++ bash-4.0/jobs.c	2009-12-08 18:04:03.000000000 +0100
@@ -442,7 +442,7 @@
   old_pipeline = the_pipeline;
   the_pipeline = saved_pipeline;
   already_making_children = saved_already_making_children;
-  if (discard)
+  if (discard && old_pipeline)
     discard_pipeline (old_pipeline);
 }
 
@@ -4202,4 +4202,23 @@
   sh_closepipe (pgrp_pipe);
 }
 
+void
+save_pgrp_pipe (p, clear)
+     int *p;
+     int clear;
+{
+  p[0] = pgrp_pipe[0];
+  p[1] = pgrp_pipe[1];
+  if (clear)
+    pgrp_pipe[0] = pgrp_pipe[1] = -1;
+}
+
+void
+restore_pgrp_pipe (p)
+     int *p;
+{
+  pgrp_pipe[0] = p[0];
+  pgrp_pipe[1] = p[1];
+}
+
 #endif /* PGRP_PIPE */
diff -Nru bash-4.0-orig/jobs.h bash-4.0/jobs.h
--- bash-4.0-orig/jobs.h	2009-01-04 20:32:29.000000000 +0100
+++ bash-4.0/jobs.h	2009-12-08 18:04:03.000000000 +0100
@@ -235,6 +235,8 @@
 extern void init_job_stats __P((void));
 
 extern void close_pgrp_pipe __P((void));
+extern void save_pgrp_pipe __P((int *, int));
+extern void restore_pgrp_pipe __P((int *));
 
 #if defined (JOB_CONTROL)
 extern int job_control;
diff -Nru bash-4.0-orig/lib/glob/glob.c bash-4.0/lib/glob/glob.c
--- bash-4.0-orig/lib/glob/glob.c	2009-01-04 20:32:30.000000000 +0100
+++ bash-4.0/lib/glob/glob.c	2009-12-08 18:06:14.000000000 +0100
@@ -356,7 +356,7 @@
 	*np = 0;
       if (ep)
         *ep = 0;
-      if (r)
+      if (r && r != &glob_error_return)
 	free (r);
       return (struct globval *)0;
     }
@@ -665,7 +665,9 @@
       (void) closedir (d);
     }
 
-  /* compat: if GX_ALLDIRS, add the passed directory also */
+  /* compat: if GX_ADDCURDIR, add the passed directory also.  Add an empty
+     directory name as a placeholder if GX_NULLDIR (in which case the passed
+     directory name is "."). */
   if (add_current)
     {
       sdlen = strlen (dir);
@@ -917,11 +919,14 @@
 	{
 	  char **temp_results;
 
+	  /* XXX -- we've recursively scanned any directories resulting from
+	     a `**', so turn off the flag.  We turn it on again below if
+	     filename is `**' */
 	  /* Scan directory even on a NULL filename.  That way, `*h/'
 	     returns only directories ending in `h', instead of all
 	     files ending in `h' with a `/' appended. */
 	  dname = directories[i];
-	  dflags = flags & ~GX_MARKDIRS;
+	  dflags = flags & ~(GX_MARKDIRS|GX_ALLDIRS|GX_ADDCURDIR);
 	  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
 	    dflags |= GX_ALLDIRS|GX_ADDCURDIR;
 	  if (dname[0] == '\0' && filename[0])
@@ -942,7 +947,12 @@
 	      char **array;
 	      register unsigned int l;
 
-	      array = glob_dir_to_array (directories[i], temp_results, flags);
+	      /* If we're expanding **, we don't need to glue the directory
+		 name to the results; we've already done it in glob_vector */
+	      if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
+		array = temp_results;
+	      else
+		array = glob_dir_to_array (directories[i], temp_results, flags);
 	      l = 0;
 	      while (array[l] != NULL)
 		++l;
@@ -959,7 +969,8 @@
 	      result[result_size - 1] = NULL;
 
 	      /* Note that the elements of ARRAY are not freed.  */
-	      free ((char *) array);
+	      if (array != temp_results)
+		free ((char *) array);
 	    }
 	}
       /* Free the directories.  */
@@ -1003,11 +1014,24 @@
 
       /* Just return what glob_vector () returns appended to the
 	 directory name. */
+      /* If flags & GX_ALLDIRS, we're called recursively */
       dflags = flags & ~GX_MARKDIRS;
       if (directory_len == 0)
 	dflags |= GX_NULLDIR;
       if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
-	dflags |= GX_ALLDIRS|GX_ADDCURDIR;
+	{
+	  dflags |= GX_ALLDIRS|GX_ADDCURDIR;
+#if 0
+	  /* If we want all directories (dflags & GX_ALLDIRS) and we're not
+	     being called recursively as something like `echo **/*.o'
+	     ((flags & GX_ALLDIRS) == 0), we want to prevent glob_vector from
+	     adding a null directory name to the front of the temp_results
+	     array.  We turn off ADDCURDIR if not called recursively and
+	     dlen == 0 */
+#endif
+	  if (directory_len == 0 && (flags & GX_ALLDIRS) == 0)
+	    dflags &= ~GX_ADDCURDIR;
+	}
       temp_results = glob_vector (filename,
 				  (directory_len == 0 ? "." : directory_name),
 				  dflags);
diff -Nru bash-4.0-orig/lib/readline/display.c bash-4.0/lib/readline/display.c
--- bash-4.0-orig/lib/readline/display.c	2009-01-04 20:32:32.000000000 +0100
+++ bash-4.0/lib/readline/display.c	2009-12-08 18:04:03.000000000 +0100
@@ -512,6 +512,7 @@
   /* Block keyboard interrupts because this function manipulates global
      data structures. */
   _rl_block_sigint ();  
+  RL_SETSTATE (RL_STATE_REDISPLAYING);
 
   if (!rl_display_prompt)
     rl_display_prompt = "";
@@ -1188,9 +1189,11 @@
       if (t < out)
 	line[t - 1] = '>';
 
-      if (!rl_display_fixed || forced_display || lmargin != last_lmargin)
+      if (rl_display_fixed == 0 || forced_display || lmargin != last_lmargin)
 	{
 	  forced_display = 0;
+	  o_cpos = _rl_last_c_pos;
+	  cpos_adjusted = 0;
 	  update_line (&visible_line[last_lmargin],
 		       &invisible_line[lmargin],
 		       0,
@@ -1198,6 +1201,13 @@
 		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
 		       0);
 
+	  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
+	      cpos_adjusted == 0 &&
+	      _rl_last_c_pos != o_cpos &&
+	      _rl_last_c_pos > wrap_offset &&
+	      o_cpos < prompt_last_invisible)
+		_rl_last_c_pos -= prompt_invis_chars_first_line;	/* XXX - was wrap_offset */
+
 	  /* If the visible new line is shorter than the old, but the number
 	     of invisible characters is greater, and we are at the end of
 	     the new line, we need to clear to eol. */
@@ -1236,6 +1246,7 @@
       visible_wrap_offset = wrap_offset;
   }
 
+  RL_UNSETSTATE (RL_STATE_REDISPLAYING);
   _rl_release_sigint ();
 }
 
@@ -1772,7 +1783,7 @@
 	     space_to_eol will insert too many spaces.  XXX - maybe we should
 	     adjust col_lendiff based on the difference between _rl_last_c_pos
 	     and _rl_screenwidth */
-	  if (col_lendiff && (_rl_last_c_pos < _rl_screenwidth))
+	  if (col_lendiff && ((MB_CUR_MAX == 1 || rl_byte_oriented) || (_rl_last_c_pos < _rl_screenwidth)))
 #endif
 	    {	  
 	      if (_rl_term_autowrap && current_line < inv_botlin)
@@ -1892,6 +1903,10 @@
 
   woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);
   cpos = _rl_last_c_pos;
+
+  if (cpos == 0 && cpos == new)
+    return;
+
 #if defined (HANDLE_MULTIBYTE)
   /* If we have multibyte characters, NEW is indexed by the buffer point in
      a multibyte string, but _rl_last_c_pos is the display position.  In
@@ -1905,9 +1920,9 @@
 	 prompt string, since they're both buffer indices and DPOS is a
 	 desired display position. */
       if ((new > prompt_last_invisible) ||		/* XXX - don't use woff here */
-	  (prompt_physical_chars > _rl_screenwidth &&
+	  (prompt_physical_chars >= _rl_screenwidth &&
 	   _rl_last_v_pos == prompt_last_screen_line &&
-	   wrap_offset >= woff &&
+	   wrap_offset >= woff && dpos >= woff &&
 	   new > (prompt_last_invisible-(_rl_screenwidth*_rl_last_v_pos)-wrap_offset)))
 	   /* XXX last comparison might need to be >= */
 	{
diff -Nru bash-4.0-orig/lib/readline/readline.h bash-4.0/lib/readline/readline.h
--- bash-4.0-orig/lib/readline/readline.h	2009-01-04 20:32:33.000000000 +0100
+++ bash-4.0/lib/readline/readline.h	2009-12-08 18:04:03.000000000 +0100
@@ -814,8 +814,9 @@
 #define RL_STATE_VIMOTION	0x100000	/* reading vi motion arg */
 #define RL_STATE_MULTIKEY	0x200000	/* reading multiple-key command */
 #define RL_STATE_VICMDONCE	0x400000	/* entered vi command mode at least once */
+#define RL_STATE_REDISPLAYING	0x800000	/* updating terminal display */
 
-#define RL_STATE_DONE		0x800000	/* done; accepted line */
+#define RL_STATE_DONE		0x1000000	/* done; accepted line */
 
 #define RL_SETSTATE(x)		(rl_readline_state |= (x))
 #define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
diff -Nru bash-4.0-orig/lib/readline/terminal.c bash-4.0/lib/readline/terminal.c
--- bash-4.0-orig/lib/readline/terminal.c	2009-01-04 20:32:34.000000000 +0100
+++ bash-4.0/lib/readline/terminal.c	2009-12-08 18:04:03.000000000 +0100
@@ -355,7 +355,7 @@
       _rl_get_screen_size (fileno (rl_instream), 1);
       if (CUSTOM_REDISPLAY_FUNC ())
 	rl_forced_update_display ();
-      else
+      else if (RL_ISSTATE(RL_STATE_REDISPLAYING) == 0)
 	_rl_redisplay_after_sigwinch ();
     }
 }
diff -Nru bash-4.0-orig/lib/readline/tilde.c bash-4.0/lib/readline/tilde.c
--- bash-4.0-orig/lib/readline/tilde.c	2009-01-04 20:32:37.000000000 +0100
+++ bash-4.0/lib/readline/tilde.c	2009-12-08 18:04:03.000000000 +0100
@@ -19,6 +19,8 @@
    along with Readline.  If not, see <http://www.gnu.org/licenses/>.
 */
 
+#define READLINE_LIBRARY
+
 #if defined (HAVE_CONFIG_H)
 #  include <config.h>
 #endif
@@ -34,7 +36,7 @@
 #  include <string.h>
 #else /* !HAVE_STRING_H */
 #  include <strings.h>
-#endif /* !HAVE_STRING_H */  
+#endif /* !HAVE_STRING_H */
 
 #if defined (HAVE_STDLIB_H)
 #  include <stdlib.h>
diff -Nru bash-4.0-orig/lib/sh/netopen.c bash-4.0/lib/sh/netopen.c
--- bash-4.0-orig/lib/sh/netopen.c	2008-08-12 17:57:50.000000000 +0200
+++ bash-4.0/lib/sh/netopen.c	2009-12-08 18:04:03.000000000 +0100
@@ -165,14 +165,14 @@
 
   if (_getaddr(host, &ina) == 0)
     {
-      internal_error (_("%s: host unknown"), host);
+      internal_error ("%s: host unknown", host);
       errno = EINVAL;
       return -1;
     }
 
   if (_getserv(serv, typ, &p) == 0)
     {
-      internal_error(_("%s: invalid service"), serv);
+      internal_error("%s: invalid service", serv);
       errno = EINVAL;
       return -1;
     }
@@ -303,7 +303,7 @@
   t = strchr (s, '/');
   if (t == 0)
     {
-      internal_error (_("%s: bad network path specification"), path);
+      internal_error ("%s: bad network path specification", path);
       return -1;
     }
   *t++ = '\0';
@@ -343,7 +343,7 @@
 netopen (path)
      char *path;
 {
-  internal_error (_("network operations not supported"));
+  internal_error ("network operations not supported");
   return -1;
 }
 
diff -Nru bash-4.0-orig/lib/sh/ufuncs.c bash-4.0/lib/sh/ufuncs.c
--- bash-4.0-orig/lib/sh/ufuncs.c	2009-01-08 15:00:47.000000000 +0100
+++ bash-4.0/lib/sh/ufuncs.c	2009-12-08 18:04:03.000000000 +0100
@@ -37,6 +37,10 @@
 #include <unistd.h>
 #endif
 
+#if defined (HAVE_SYS_SELECT_H)
+#include <sys/select.h>
+#endif
+
 /* A version of `alarm' using setitimer if it's available. */
 
 #if defined (HAVE_SETITIMER)
diff -Nru bash-4.0-orig/lib/sh/winsize.c bash-4.0/lib/sh/winsize.c
--- bash-4.0-orig/lib/sh/winsize.c	2008-08-12 19:53:51.000000000 +0200
+++ bash-4.0/lib/sh/winsize.c	2009-12-08 18:04:03.000000000 +0100
@@ -30,16 +30,29 @@
 
 #include <sys/ioctl.h>
 
-#if !defined (STRUCT_WINSIZE_IN_SYS_IOCTL)
-/* For struct winsize on SCO */
-/*   sys/ptem.h has winsize but needs mblk_t from sys/stream.h */
-#  if defined (HAVE_SYS_PTEM_H) && defined (TIOCGWINSZ) && defined (SIGWINCH)
-#    if defined (HAVE_SYS_STREAM_H)
-#      include <sys/stream.h>
-#    endif
+/* Try to find the definitions of `struct winsize' and TIOGCWINSZ */
+
+#if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
+#  include <sys/ioctl.h>
+#endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
+
+#if defined (STRUCT_WINSIZE_IN_TERMIOS) && !defined (STRUCT_WINSIZE_IN_SYS_IOCTL)
+#  include <termios.h>
+#endif /* STRUCT_WINSIZE_IN_TERMIOS && !STRUCT_WINSIZE_IN_SYS_IOCTL */
+
+/* Not in either of the standard places, look around. */
+#if !defined (STRUCT_WINSIZE_IN_TERMIOS) && !defined (STRUCT_WINSIZE_IN_SYS_IOCTL)
+#  if defined (HAVE_SYS_STREAM_H)
+#    include <sys/stream.h>
+#  endif /* HAVE_SYS_STREAM_H */
+#  if defined (HAVE_SYS_PTEM_H) /* SVR4.2, at least, has it here */
 #    include <sys/ptem.h>
-#  endif /* HAVE_SYS_PTEM_H && TIOCGWINSZ && SIGWINCH */
-#endif /* !STRUCT_WINSIZE_IN_SYS_IOCTL */
+#    define _IO_PTEM_H          /* work around SVR4.2 1.1.4 bug */
+#  endif /* HAVE_SYS_PTEM_H */
+#  if defined (HAVE_SYS_PTE_H)  /* ??? */
+#    include <sys/pte.h>
+#  endif /* HAVE_SYS_PTE_H */
+#endif /* !STRUCT_WINSIZE_IN_TERMIOS && !STRUCT_WINSIZE_IN_SYS_IOCTL */
 
 #include <stdio.h>
 
diff -Nru bash-4.0-orig/parse.y bash-4.0/parse.y
--- bash-4.0-orig/parse.y	2009-01-08 14:29:12.000000000 +0100
+++ bash-4.0/parse.y	2009-12-08 18:04:03.000000000 +0100
@@ -887,7 +887,7 @@
 
 cond_command:	COND_START COND_CMD COND_END
 			{ $$ = $2; }
-	; 
+	;
 
 elif_clause:	ELIF compound_list THEN compound_list
 			{ $$ = make_if_command ($2, $4, (COMMAND *)NULL); }
@@ -923,7 +923,7 @@
 	|	pattern_list SEMI_SEMI_AND
 			{ $1->flags |= CASEPAT_TESTNEXT; $$ = $1; }
 	|	case_clause_sequence pattern_list SEMI_SEMI_AND
-			{ $2->flags |= CASEPAT_TESTNEXT; $2->next = $1; $$ = $2; }	
+			{ $2->flags |= CASEPAT_TESTNEXT; $2->next = $1; $$ = $2; }
 	;
 
 pattern:	WORD
@@ -1110,7 +1110,7 @@
 			  if ($2 == '\n')
 			    token_to_read = '\n';
 			}
-			
+
 	;
 
 pipeline:	pipeline '|' newline_list pipeline
@@ -1122,7 +1122,7 @@
 			  REDIRECTEE rd;
 			  REDIRECT *r;
 
-			  tc = $1;
+			  tc = $1->type == cm_simple ? (COMMAND *)$1->value.Simple : $1;
 			  rd.dest = 1;
 			  r = make_redirection (2, r_duplicating_output, rd);
 			  if (tc->redirects)
@@ -1615,10 +1615,11 @@
 {
   int *ret;
 
-  ret = (int *)xmalloc (3 * sizeof (int));
+  ret = (int *)xmalloc (4 * sizeof (int));
   ret[0] = last_read_token;
   ret[1] = token_before_that;
   ret[2] = two_tokens_ago;
+  ret[3] = current_token;
   return ret;
 }
 
@@ -1631,6 +1632,7 @@
   last_read_token = ts[0];
   token_before_that = ts[1];
   two_tokens_ago = ts[2];
+  current_token = ts[3];
 }
 
 /*
@@ -1870,14 +1872,13 @@
      int remove_quoted_newline;
 {
   char *ret;
-  int n, c;
 
   prompt_string_pointer = &ps2_prompt;
   if (SHOULD_PROMPT())
     prompt_again ();
   ret = read_a_line (remove_quoted_newline);
 #if defined (HISTORY)
-  if (remember_on_history && (parser_state & PST_HEREDOC))
+  if (ret && remember_on_history && (parser_state & PST_HEREDOC))
     {
       /* To make adding the the here-document body right, we need to rely
 	 on history_delimiting_chars() returning \n for the first line of
@@ -2033,7 +2034,7 @@
       sigwinch_received = 0;
       get_new_window_size (0, (int *)0, (int *)0);
     }
-      
+
   if (eol_ungetc_lookahead)
     {
       c = eol_ungetc_lookahead;
@@ -2668,6 +2669,7 @@
   FREE (word_desc_to_read);
   word_desc_to_read = (WORD_DESC *)NULL;
 
+  current_token = '\n';		/* XXX */
   last_read_token = '\n';
   token_to_read = '\n';
 }
@@ -2915,6 +2917,7 @@
 #define P_DQUOTE	0x04
 #define P_COMMAND	0x08	/* parsing a command, so look for comments */
 #define P_BACKQUOTE	0x10	/* parsing a backquoted command substitution */
+#define P_ARRAYSUB	0x20	/* parsing a [...] array subscript for assignment */
 
 /* Lexical state while parsing a grouping construct or $(...). */
 #define LEX_WASDOL	0x001
@@ -2927,6 +2930,7 @@
 #define LEX_INHEREDOC	0x080
 #define LEX_HEREDELIM	0x100		/* reading here-doc delimiter */
 #define LEX_STRIPDOC	0x200		/* <<- strip tabs from here doc delim */
+#define LEX_INWORD	0x400
 
 #define COMSUB_META(ch)		((ch) == ';' || (ch) == '&' || (ch) == '|')
 
@@ -3129,6 +3133,8 @@
 	      APPEND_NESTRET ();
 	      FREE (nestret);
 	    }
+	  else if ((flags & P_ARRAYSUB) && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
+	    goto parse_dollar_word;
 	}
       /* Parse an old-style command substitution within double quotes as a
 	 single word. */
@@ -3145,6 +3151,7 @@
       else if MBTEST(open != '`' && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
 	/* check for $(), $[], or ${} inside quoted string. */
 	{
+parse_dollar_word:
 	  if (open == ch)	/* undo previous increment */
 	    count--;
 	  if (ch == '(')		/* ) */
@@ -3179,7 +3186,7 @@
      int open, close;
      int *lenp, flags;
 {
-  int count, ch, peekc, tflags, lex_rwlen, lex_firstind;
+  int count, ch, peekc, tflags, lex_rwlen, lex_wlen, lex_firstind;
   int nestlen, ttranslen, start_lineno;
   char *ret, *nestret, *ttrans, *heredelim;
   int retind, retsize, rflags, hdlen;
@@ -3200,7 +3207,7 @@
   retind = 0;
 
   start_lineno = line_number;
-  lex_rwlen = 0;
+  lex_rwlen = lex_wlen = 0;
 
   heredelim = 0;
   lex_firstind = -1;
@@ -3267,6 +3274,46 @@
 	  continue;
 	}
 
+      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
+	{
+/*itrace("parse_comsub:%d: lex_passnext -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	  tflags &= ~LEX_PASSNEXT;
+	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
+	    {
+	      if (retind > 0)
+		retind--;	/* swallow previously-added backslash */
+	      continue;
+	    }
+
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
+	  if MBTEST(ch == CTLESC || ch == CTLNUL)
+	    ret[retind++] = CTLESC;
+	  ret[retind++] = ch;
+	  continue;
+	}
+
+      /* If this is a shell break character, we are not in a word.  If not,
+	 we either start or continue a word. */
+      if MBTEST(shellbreak (ch))
+	{
+	  tflags &= ~LEX_INWORD;
+/*itrace("parse_comsub:%d: lex_inword -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	}
+      else
+	{
+	  if (tflags & LEX_INWORD)
+	    {
+	      lex_wlen++;
+/*itrace("parse_comsub:%d: lex_inword == 1 ch = `%c' lex_wlen = %d (%d)", line_number, ch, lex_wlen, __LINE__);*/
+	    }
+	  else
+	    {
+/*itrace("parse_comsub:%d: lex_inword -> 1 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	      tflags |= LEX_INWORD;
+	      lex_wlen = 0;
+	    }
+	}
+
       /* Skip whitespace */
       if MBTEST(shellblank (ch) && lex_rwlen == 0)
         {
@@ -3306,7 +3353,7 @@
 	}
 
       /* Meta-characters that can introduce a reserved word.  Not perfect yet. */
-      if MBTEST((tflags & LEX_RESWDOK) == 0 && (tflags & LEX_CKCASE) && (tflags & LEX_INCOMMENT) == 0 && shellmeta(ch))
+      if MBTEST((tflags & LEX_RESWDOK) == 0 && (tflags & LEX_CKCASE) && (tflags & LEX_INCOMMENT) == 0 && (shellmeta(ch) || ch == '\n'))
 	{
 	  /* Add this character. */
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
@@ -3361,12 +3408,24 @@
 {
 		tflags &= ~LEX_INCASE;
 /*itrace("parse_comsub:%d: found `esac', lex_incase -> 0", line_number);*/
-}	        
+}
 	      tflags &= ~LEX_RESWDOK;
 	    }
-	  else if (shellbreak (ch) == 0)
+	  else if MBTEST((tflags & LEX_CKCOMMENT) && ch == '#' && (lex_rwlen == 0 || ((tflags & LEX_INWORD) && lex_wlen == 0)))
+	    ;	/* don't modify LEX_RESWDOK if we're starting a comment */
+	  else if MBTEST((tflags & LEX_INCASE) && ch != '\n')
+	    /* If we can read a reserved word and we're in case, we're at the
+	       point where we can read a new pattern list or an esac.  We
+	       handle the esac case above.  If we read a newline, we want to
+	       leave LEX_RESWDOK alone.  If we read anything else, we want to
+	       turn off LEX_RESWDOK, since we're going to read a pattern list. */
 {
-	      tflags &= ~LEX_RESWDOK;
+	    tflags &= ~LEX_RESWDOK;
+/*itrace("parse_comsub:%d: lex_incase == 1 found `%c', lex_reswordok -> 0", line_number, ch);*/
+}
+	  else if MBTEST(shellbreak (ch) == 0)
+{
+	    tflags &= ~LEX_RESWDOK;
 /*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
 }
 	}
@@ -3394,36 +3453,23 @@
 		}
 	      else
 		shell_ungetc (peekc);
-	      tflags |= LEX_HEREDELIM;
-	      lex_firstind = -1;
+	      if (peekc != '<')
+		{
+		  tflags |= LEX_HEREDELIM;
+		  lex_firstind = -1;
+		}
 	      continue;
 	    }
 	  else
-	    ch = peekc;		/* fall through and continue XXX - this skips comments if peekc == '#' */
+	    ch = peekc;		/* fall through and continue XXX */
 	}
-      /* Not exactly right yet, should handle shell metacharacters, too.  If
-	 any changes are made to this test, make analogous changes to subst.c:
-	 extract_delimited_string(). */
-      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || shellblank (ret[retind - 1])))
+      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (((tflags & LEX_RESWDOK) && lex_rwlen == 0) || ((tflags & LEX_INWORD) && lex_wlen == 0)))
+{
+/*itrace("parse_comsub:%d: lex_incomment -> 1 (%d)", line_number, __LINE__);*/
 	tflags |= LEX_INCOMMENT;
+}
 
-      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
-	{
-	  tflags &= ~LEX_PASSNEXT;
-	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
-	    {
-	      if (retind > 0)
-		retind--;	/* swallow previously-added backslash */
-	      continue;
-	    }
-
-	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
-	  if MBTEST(ch == CTLESC || ch == CTLNUL)
-	    ret[retind++] = CTLESC;
-	  ret[retind++] = ch;
-	  continue;
-	}
-      else if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+      if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
 	{
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
 	  ret[retind++] = CTLESC;
@@ -3584,7 +3630,7 @@
     itrace("xparse_dolparen:%d: base[%d] != RPAREN (%d), base = `%s'", line_number, *indp, base[*indp], base);
 #endif
 
-  if (flags & SX_NOALLOC) 
+  if (flags & SX_NOALLOC)
     return (char *)NULL;
 
   if (nc == 0)
@@ -3735,7 +3781,7 @@
 static COND_COM *
 cond_expr ()
 {
-  return (cond_or ());  
+  return (cond_or ());
 }
 
 static COND_COM *
@@ -3929,7 +3975,7 @@
       COND_RETURN_ERROR ();
     }
   return (term);
-}      
+}
 
 /* This is kind of bogus -- we slip a mini recursive-descent parser in
    here to handle the conditional statement syntax. */
@@ -4248,7 +4294,7 @@
 		     ((token_index > 0 && assignment_acceptable (last_read_token) && token_is_ident (token, token_index)) ||
 		      (token_index == 0 && (parser_state&PST_COMPASSIGN))))
         {
-	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
+	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARRAYSUB);
 	  if (ttok == &matched_pair_error)
 	    return -1;		/* Bail immediately. */
 	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
@@ -4449,6 +4495,7 @@
     case '}':		/* XXX */
     case AND_AND:
     case BANG:
+    case BAR_AND:
     case DO:
     case DONE:
     case ELIF:
@@ -4476,7 +4523,7 @@
       return 0;
     }
 }
-    
+
 /* Return the index of TOKEN in the alist of reserved words, or -1 if
    TOKEN is not a shell reserved word. */
 int
@@ -4563,7 +4610,7 @@
 	 command lists.  It's a suboptimal solution. */
       else if (parser_state & PST_CASESTMT)	/* case statement pattern */
 	return " ";
-      else	
+      else
 	return "; ";				/* (...) subshell */
     }
   else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
@@ -4648,7 +4695,7 @@
   prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
   current_prompt_string = *prompt_string_pointer;
 }
-      
+
 static void
 print_prompt ()
 {
@@ -4700,7 +4747,7 @@
   int result_size, result_index;
   int c, n, i;
   char *temp, octal_string[4];
-  struct tm *tm;  
+  struct tm *tm;
   time_t the_time;
   char timebuf[128];
   char *timefmt;
@@ -4834,7 +4881,7 @@
 	      else
 		temp = savestring (timebuf);
 	      goto add_string;
-	      
+
 	    case 'n':
 	      temp = (char *)xmalloc (3);
 	      temp[0] = no_line_editing ? '\n' : '\r';
@@ -5377,7 +5424,7 @@
 	}
       wl = make_word_list (yylval.word, wl);
     }
-  
+
   last_read_token = '\n';
   pop_stream ();
 
@@ -5533,7 +5580,7 @@
   else
     ps->pipestatus = (ARRAY *)NULL;
 #endif
-    
+
   ps->last_shell_builtin = last_shell_builtin;
   ps->this_shell_builtin = this_shell_builtin;
 
diff -Nru bash-4.0-orig/parse.y.orig bash-4.0/parse.y.orig
--- bash-4.0-orig/parse.y.orig	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/parse.y.orig	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,5700 @@
+/* parse.y - Yacc grammar for bash. */
+
+/* Copyright (C) 1989-2009 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Bash is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+%{
+#include "config.h"
+
+#include "bashtypes.h"
+#include "bashansi.h"
+
+#include "filecntl.h"
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#if defined (HAVE_LOCALE_H)
+#  include <locale.h>
+#endif
+
+#include <stdio.h>
+#include "chartypes.h"
+#include <signal.h>
+
+#include "memalloc.h"
+
+#include "bashintl.h"
+
+#define NEED_STRFTIME_DECL	/* used in externs.h */
+
+#include "shell.h"
+#include "trap.h"
+#include "flags.h"
+#include "parser.h"
+#include "mailcheck.h"
+#include "test.h"
+#include "builtins.h"
+#include "builtins/common.h"
+#include "builtins/builtext.h"
+
+#include "shmbutil.h"
+
+#if defined (READLINE)
+#  include "bashline.h"
+#  include <readline/readline.h>
+#endif /* READLINE */
+
+#if defined (HISTORY)
+#  include "bashhist.h"
+#  include <readline/history.h>
+#endif /* HISTORY */
+
+#if defined (JOB_CONTROL)
+#  include "jobs.h"
+#endif /* JOB_CONTROL */
+
+#if defined (ALIAS)
+#  include "alias.h"
+#else
+typedef void *alias_t;
+#endif /* ALIAS */
+
+#if defined (PROMPT_STRING_DECODE)
+#  ifndef _MINIX
+#    include <sys/param.h>
+#  endif
+#  include <time.h>
+#  if defined (TM_IN_SYS_TIME)
+#    include <sys/types.h>
+#    include <sys/time.h>
+#  endif /* TM_IN_SYS_TIME */
+#  include "maxpath.h"
+#endif /* PROMPT_STRING_DECODE */
+
+#define RE_READ_TOKEN	-99
+#define NO_EXPANSION	-100
+
+#ifdef DEBUG
+#  define YYDEBUG 1
+#else
+#  define YYDEBUG 0
+#endif
+
+#if defined (HANDLE_MULTIBYTE)
+#  define last_shell_getc_is_singlebyte \
+	((shell_input_line_index > 1) \
+		? shell_input_line_property[shell_input_line_index - 1] \
+		: 1)
+#  define MBTEST(x)	((x) && last_shell_getc_is_singlebyte)
+#else
+#  define last_shell_getc_is_singlebyte	1
+#  define MBTEST(x)	((x))
+#endif
+
+#if defined (EXTENDED_GLOB)
+extern int extended_glob;
+#endif
+
+extern int eof_encountered;
+extern int no_line_editing, running_under_emacs;
+extern int current_command_number;
+extern int sourcelevel, parse_and_execute_level;
+extern int posixly_correct;
+extern int last_command_exit_value;
+extern char *shell_name, *current_host_name;
+extern char *dist_version;
+extern int patch_level;
+extern int dump_translatable_strings, dump_po_strings;
+extern sh_builtin_func_t *last_shell_builtin, *this_shell_builtin;
+#if defined (BUFFERED_INPUT)
+extern int bash_input_fd_changed;
+#endif
+
+extern int errno;
+/* **************************************************************** */
+/*								    */
+/*		    "Forward" declarations			    */
+/*								    */
+/* **************************************************************** */
+
+#ifdef DEBUG
+static void debug_parser __P((int));
+#endif
+
+static int yy_getc __P((void));
+static int yy_ungetc __P((int));
+
+#if defined (READLINE)
+static int yy_readline_get __P((void));
+static int yy_readline_unget __P((int));
+#endif
+
+static int yy_string_get __P((void));
+static int yy_string_unget __P((int));
+static void rewind_input_string __P((void));
+static int yy_stream_get __P((void));
+static int yy_stream_unget __P((int));
+
+static int shell_getc __P((int));
+static void shell_ungetc __P((int));
+static void discard_until __P((int));
+
+#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
+static void push_string __P((char *, int, alias_t *));
+static void pop_string __P((void));
+static void free_string_list __P((void));
+#endif
+
+static char *read_a_line __P((int));
+
+static int reserved_word_acceptable __P((int));
+static int yylex __P((void));
+static int alias_expand_token __P((char *));
+static int time_command_acceptable __P((void));
+static int special_case_tokens __P((char *));
+static int read_token __P((int));
+static char *parse_matched_pair __P((int, int, int, int *, int));
+static char *parse_comsub __P((int, int, int, int *, int));
+#if defined (ARRAY_VARS)
+static char *parse_compound_assignment __P((int *));
+#endif
+#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
+static int parse_dparen __P((int));
+static int parse_arith_cmd __P((char **, int));
+#endif
+#if defined (COND_COMMAND)
+static void cond_error __P((void));
+static COND_COM *cond_expr __P((void));
+static COND_COM *cond_or __P((void));
+static COND_COM *cond_and __P((void));
+static COND_COM *cond_term __P((void));
+static int cond_skip_newlines __P((void));
+static COMMAND *parse_cond_command __P((void));
+#endif
+#if defined (ARRAY_VARS)
+static int token_is_assignment __P((char *, int));
+static int token_is_ident __P((char *, int));
+#endif
+static int read_token_word __P((int));
+static void discard_parser_constructs __P((int));
+
+static char *error_token_from_token __P((int));
+static char *error_token_from_text __P((void));
+static void print_offending_line __P((void));
+static void report_syntax_error __P((char *));
+
+static void handle_eof_input_unit __P((void));
+static void prompt_again __P((void));
+#if 0
+static void reset_readline_prompt __P((void));
+#endif
+static void print_prompt __P((void));
+
+#if defined (HANDLE_MULTIBYTE)
+static void set_line_mbstate __P((void));
+static char *shell_input_line_property = NULL;
+#else
+#  define set_line_mbstate()
+#endif
+
+extern int yyerror __P((const char *));
+
+#ifdef DEBUG
+extern int yydebug;
+#endif
+
+/* Default prompt strings */
+char *primary_prompt = PPROMPT;
+char *secondary_prompt = SPROMPT;
+
+/* PROMPT_STRING_POINTER points to one of these, never to an actual string. */
+char *ps1_prompt, *ps2_prompt;
+
+/* Handle on the current prompt string.  Indirectly points through
+   ps1_ or ps2_prompt. */
+char **prompt_string_pointer = (char **)NULL;
+char *current_prompt_string;
+
+/* Non-zero means we expand aliases in commands. */
+int expand_aliases = 0;
+
+/* If non-zero, the decoded prompt string undergoes parameter and
+   variable substitution, command substitution, arithmetic substitution,
+   string expansion, process substitution, and quote removal in
+   decode_prompt_string. */
+int promptvars = 1;
+
+/* If non-zero, $'...' and $"..." are expanded when they appear within
+   a ${...} expansion, even when the expansion appears within double
+   quotes. */
+int extended_quote = 1;
+
+/* The decoded prompt string.  Used if READLINE is not defined or if
+   editing is turned off.  Analogous to current_readline_prompt. */
+static char *current_decoded_prompt;
+
+/* The number of lines read from input while creating the current command. */
+int current_command_line_count;
+
+/* The token that currently denotes the end of parse. */
+int shell_eof_token;
+
+/* The token currently being read. */
+int current_token;
+
+/* Variables to manage the task of reading here documents, because we need to
+   defer the reading until after a complete command has been collected. */
+static REDIRECT *redir_stack[10];
+int need_here_doc;
+
+/* Where shell input comes from.  History expansion is performed on each
+   line when the shell is interactive. */
+static char *shell_input_line = (char *)NULL;
+static int shell_input_line_index;
+static int shell_input_line_size;	/* Amount allocated for shell_input_line. */
+static int shell_input_line_len;	/* strlen (shell_input_line) */
+
+/* Either zero or EOF. */
+static int shell_input_line_terminator;
+
+/* The line number in a script on which a function definition starts. */
+static int function_dstart;
+
+/* The line number in a script on which a function body starts. */
+static int function_bstart;
+
+/* The line number in a script at which an arithmetic for command starts. */
+static int arith_for_lineno;
+
+/* The current parser state. */
+static int parser_state;
+
+/* The last read token, or NULL.  read_token () uses this for context
+   checking. */
+static int last_read_token;
+
+/* The token read prior to last_read_token. */
+static int token_before_that;
+
+/* The token read prior to token_before_that. */
+static int two_tokens_ago;
+
+/* The line number in a script where the word in a `case WORD', `select WORD'
+   or `for WORD' begins.  This is a nested command maximum, since the array
+   index is decremented after a case, select, or for command is parsed. */
+#define MAX_CASE_NEST	128
+static int word_lineno[MAX_CASE_NEST];
+static int word_top = -1;
+
+/* If non-zero, it is the token that we want read_token to return
+   regardless of what text is (or isn't) present to be read.  This
+   is reset by read_token.  If token_to_read == WORD or
+   ASSIGNMENT_WORD, yylval.word should be set to word_desc_to_read. */
+static int token_to_read;
+static WORD_DESC *word_desc_to_read;
+
+static REDIRECTEE redir;
+%}
+
+%union {
+  WORD_DESC *word;		/* the word that we read. */
+  int number;			/* the number that we read. */
+  WORD_LIST *word_list;
+  COMMAND *command;
+  REDIRECT *redirect;
+  ELEMENT element;
+  PATTERN_LIST *pattern;
+}
+
+/* Reserved words.  Members of the first group are only recognized
+   in the case that they are preceded by a list_terminator.  Members
+   of the second group are for [[...]] commands.  Members of the
+   third group are recognized only under special circumstances. */
+%token IF THEN ELSE ELIF FI CASE ESAC FOR SELECT WHILE UNTIL DO DONE FUNCTION COPROC
+%token COND_START COND_END COND_ERROR
+%token IN BANG TIME TIMEOPT
+
+/* More general tokens. yylex () knows how to make these. */
+%token <word> WORD ASSIGNMENT_WORD
+%token <number> NUMBER
+%token <word_list> ARITH_CMD ARITH_FOR_EXPRS
+%token <command> COND_CMD
+%token AND_AND OR_OR GREATER_GREATER LESS_LESS LESS_AND LESS_LESS_LESS
+%token GREATER_AND SEMI_SEMI SEMI_AND SEMI_SEMI_AND
+%token LESS_LESS_MINUS AND_GREATER AND_GREATER_GREATER LESS_GREATER
+%token GREATER_BAR BAR_AND
+
+/* The types that the various syntactical units return. */
+
+%type <command> inputunit command pipeline pipeline_command
+%type <command> list list0 list1 compound_list simple_list simple_list1
+%type <command> simple_command shell_command
+%type <command> for_command select_command case_command group_command
+%type <command> arith_command
+%type <command> cond_command
+%type <command> arith_for_command
+%type <command> coproc
+%type <command> function_def function_body if_command elif_clause subshell
+%type <redirect> redirection redirection_list
+%type <element> simple_command_element
+%type <word_list> word_list pattern
+%type <pattern> pattern_list case_clause_sequence case_clause
+%type <number> timespec
+%type <number> list_terminator
+
+%start inputunit
+
+%left '&' ';' '\n' yacc_EOF
+%left AND_AND OR_OR
+%right '|' BAR_AND
+%%
+
+inputunit:	simple_list simple_list_terminator
+			{
+			  /* Case of regular command.  Discard the error
+			     safety net,and return the command just parsed. */
+			  global_command = $1;
+			  eof_encountered = 0;
+			  /* discard_parser_constructs (0); */
+			  if (parser_state & PST_CMDSUBST)
+			    parser_state |= PST_EOFTOKEN;
+			  YYACCEPT;
+			}
+	|	'\n'
+			{
+			  /* Case of regular command, but not a very
+			     interesting one.  Return a NULL command. */
+			  global_command = (COMMAND *)NULL;
+			  if (parser_state & PST_CMDSUBST)
+			    parser_state |= PST_EOFTOKEN;
+			  YYACCEPT;
+			}
+	|	error '\n'
+			{
+			  /* Error during parsing.  Return NULL command. */
+			  global_command = (COMMAND *)NULL;
+			  eof_encountered = 0;
+			  /* discard_parser_constructs (1); */
+			  if (interactive && parse_and_execute_level == 0)
+			    {
+			      YYACCEPT;
+			    }
+			  else
+			    {
+			      YYABORT;
+			    }
+			}
+	|	yacc_EOF
+			{
+			  /* Case of EOF seen by itself.  Do ignoreeof or
+			     not. */
+			  global_command = (COMMAND *)NULL;
+			  handle_eof_input_unit ();
+			  YYACCEPT;
+			}
+	;
+
+word_list:	WORD
+			{ $$ = make_word_list ($1, (WORD_LIST *)NULL); }
+	|	word_list WORD
+			{ $$ = make_word_list ($2, $1); }
+	;
+
+redirection:	'>' WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (1, r_output_direction, redir);
+			}
+	|	'<' WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (0, r_input_direction, redir);
+			}
+	|	NUMBER '>' WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_output_direction, redir);
+			}
+	|	NUMBER '<' WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_input_direction, redir);
+			}
+	|	GREATER_GREATER WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (1, r_appending_to, redir);
+			}
+	|	NUMBER GREATER_GREATER WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_appending_to, redir);
+			}
+	|	LESS_LESS WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (0, r_reading_until, redir);
+			  redir_stack[need_here_doc++] = $$;
+			}
+	|	NUMBER LESS_LESS WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_reading_until, redir);
+			  redir_stack[need_here_doc++] = $$;
+			}
+	|	LESS_LESS_LESS WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (0, r_reading_string, redir);
+			}
+	|	NUMBER LESS_LESS_LESS WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_reading_string, redir);
+			}
+	|	LESS_AND NUMBER
+			{
+			  redir.dest = $2;
+			  $$ = make_redirection (0, r_duplicating_input, redir);
+			}
+	|	NUMBER LESS_AND NUMBER
+			{
+			  redir.dest = $3;
+			  $$ = make_redirection ($1, r_duplicating_input, redir);
+			}
+	|	GREATER_AND NUMBER
+			{
+			  redir.dest = $2;
+			  $$ = make_redirection (1, r_duplicating_output, redir);
+			}
+	|	NUMBER GREATER_AND NUMBER
+			{
+			  redir.dest = $3;
+			  $$ = make_redirection ($1, r_duplicating_output, redir);
+			}
+	|	LESS_AND WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (0, r_duplicating_input_word, redir);
+			}
+	|	NUMBER LESS_AND WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_duplicating_input_word, redir);
+			}
+	|	GREATER_AND WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (1, r_duplicating_output_word, redir);
+			}
+	|	NUMBER GREATER_AND WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_duplicating_output_word, redir);
+			}
+	|	LESS_LESS_MINUS WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection
+			    (0, r_deblank_reading_until, redir);
+			  redir_stack[need_here_doc++] = $$;
+			}
+	|	NUMBER LESS_LESS_MINUS WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection
+			    ($1, r_deblank_reading_until, redir);
+			  redir_stack[need_here_doc++] = $$;
+			}
+	|	GREATER_AND '-'
+			{
+			  redir.dest = 0;
+			  $$ = make_redirection (1, r_close_this, redir);
+			}
+	|	NUMBER GREATER_AND '-'
+			{
+			  redir.dest = 0;
+			  $$ = make_redirection ($1, r_close_this, redir);
+			}
+	|	LESS_AND '-'
+			{
+			  redir.dest = 0;
+			  $$ = make_redirection (0, r_close_this, redir);
+			}
+	|	NUMBER LESS_AND '-'
+			{
+			  redir.dest = 0;
+			  $$ = make_redirection ($1, r_close_this, redir);
+			}
+	|	AND_GREATER WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (1, r_err_and_out, redir);
+			}
+	|	AND_GREATER_GREATER WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (1, r_append_err_and_out, redir);
+			}
+	|	NUMBER LESS_GREATER WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_input_output, redir);
+			}
+	|	LESS_GREATER WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (0, r_input_output, redir);
+			}
+	|	GREATER_BAR WORD
+			{
+			  redir.filename = $2;
+			  $$ = make_redirection (1, r_output_force, redir);
+			}
+	|	NUMBER GREATER_BAR WORD
+			{
+			  redir.filename = $3;
+			  $$ = make_redirection ($1, r_output_force, redir);
+			}
+	;
+
+simple_command_element: WORD
+			{ $$.word = $1; $$.redirect = 0; }
+	|	ASSIGNMENT_WORD
+			{ $$.word = $1; $$.redirect = 0; }
+	|	redirection
+			{ $$.redirect = $1; $$.word = 0; }
+	;
+
+redirection_list: redirection
+			{
+			  $$ = $1;
+			}
+	|	redirection_list redirection
+			{
+			  register REDIRECT *t;
+
+			  for (t = $1; t->next; t = t->next)
+			    ;
+			  t->next = $2;
+			  $$ = $1;
+			}
+	;
+
+simple_command:	simple_command_element
+			{ $$ = make_simple_command ($1, (COMMAND *)NULL); }
+	|	simple_command simple_command_element
+			{ $$ = make_simple_command ($2, $1); }
+	;
+
+command:	simple_command
+			{ $$ = clean_simple_command ($1); }
+	|	shell_command
+			{ $$ = $1; }
+	|	shell_command redirection_list
+			{
+			  COMMAND *tc;
+
+			  tc = $1;
+			  if (tc->redirects)
+			    {
+			      register REDIRECT *t;
+			      for (t = tc->redirects; t->next; t = t->next)
+				;
+			      t->next = $2;
+			    }
+			  else
+			    tc->redirects = $2;
+			  $$ = $1;
+			}
+	|	function_def
+			{ $$ = $1; }
+	|	coproc
+			{ $$ = $1; }
+	;
+
+shell_command:	for_command
+			{ $$ = $1; }
+	|	case_command
+			{ $$ = $1; }
+ 	|	WHILE compound_list DO compound_list DONE
+			{ $$ = make_while_command ($2, $4); }
+	|	UNTIL compound_list DO compound_list DONE
+			{ $$ = make_until_command ($2, $4); }
+	|	select_command
+			{ $$ = $1; }
+	|	if_command
+			{ $$ = $1; }
+	|	subshell
+			{ $$ = $1; }
+	|	group_command
+			{ $$ = $1; }
+	|	arith_command
+			{ $$ = $1; }
+	|	cond_command
+			{ $$ = $1; }
+	|	arith_for_command
+			{ $$ = $1; }
+	;
+
+for_command:	FOR WORD newline_list DO compound_list DONE
+			{
+			  $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $5, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	FOR WORD newline_list '{' compound_list '}'
+			{
+			  $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $5, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	FOR WORD ';' newline_list DO compound_list DONE
+			{
+			  $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $6, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	FOR WORD ';' newline_list '{' compound_list '}'
+			{
+			  $$ = make_for_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $6, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	FOR WORD newline_list IN word_list list_terminator newline_list DO compound_list DONE
+			{
+			  $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	FOR WORD newline_list IN word_list list_terminator newline_list '{' compound_list '}'
+			{
+			  $$ = make_for_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	FOR WORD newline_list IN list_terminator newline_list DO compound_list DONE
+			{
+			  $$ = make_for_command ($2, (WORD_LIST *)NULL, $8, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	FOR WORD newline_list IN list_terminator newline_list '{' compound_list '}'
+			{
+			  $$ = make_for_command ($2, (WORD_LIST *)NULL, $8, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	;
+
+arith_for_command:	FOR ARITH_FOR_EXPRS list_terminator newline_list DO compound_list DONE
+				{
+				  $$ = make_arith_for_command ($2, $6, arith_for_lineno);
+				  if (word_top > 0) word_top--;
+				}
+	|		FOR ARITH_FOR_EXPRS list_terminator newline_list '{' compound_list '}'
+				{
+				  $$ = make_arith_for_command ($2, $6, arith_for_lineno);
+				  if (word_top > 0) word_top--;
+				}
+	|		FOR ARITH_FOR_EXPRS DO compound_list DONE
+				{
+				  $$ = make_arith_for_command ($2, $4, arith_for_lineno);
+				  if (word_top > 0) word_top--;
+				}
+	|		FOR ARITH_FOR_EXPRS '{' compound_list '}'
+				{
+				  $$ = make_arith_for_command ($2, $4, arith_for_lineno);
+				  if (word_top > 0) word_top--;
+				}
+	;
+
+select_command:	SELECT WORD newline_list DO list DONE
+			{
+			  $$ = make_select_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $5, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	SELECT WORD newline_list '{' list '}'
+			{
+			  $$ = make_select_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $5, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	SELECT WORD ';' newline_list DO list DONE
+			{
+			  $$ = make_select_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $6, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	SELECT WORD ';' newline_list '{' list '}'
+			{
+			  $$ = make_select_command ($2, add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), $6, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	SELECT WORD newline_list IN word_list list_terminator newline_list DO list DONE
+			{
+			  $$ = make_select_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	SELECT WORD newline_list IN word_list list_terminator newline_list '{' list '}'
+			{
+			  $$ = make_select_command ($2, REVERSE_LIST ($5, WORD_LIST *), $9, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	;
+
+case_command:	CASE WORD newline_list IN newline_list ESAC
+			{
+			  $$ = make_case_command ($2, (PATTERN_LIST *)NULL, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	CASE WORD newline_list IN case_clause_sequence newline_list ESAC
+			{
+			  $$ = make_case_command ($2, $5, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	|	CASE WORD newline_list IN case_clause ESAC
+			{
+			  $$ = make_case_command ($2, $5, word_lineno[word_top]);
+			  if (word_top > 0) word_top--;
+			}
+	;
+
+function_def:	WORD '(' ')' newline_list function_body
+			{ $$ = make_function_def ($1, $5, function_dstart, function_bstart); }
+
+	|	FUNCTION WORD '(' ')' newline_list function_body
+			{ $$ = make_function_def ($2, $6, function_dstart, function_bstart); }
+
+	|	FUNCTION WORD newline_list function_body
+			{ $$ = make_function_def ($2, $4, function_dstart, function_bstart); }
+	;
+
+function_body:	shell_command
+			{ $$ = $1; }
+	|	shell_command redirection_list
+			{
+			  COMMAND *tc;
+
+			  tc = $1;
+			  /* According to Posix.2 3.9.5, redirections
+			     specified after the body of a function should
+			     be attached to the function and performed when
+			     the function is executed, not as part of the
+			     function definition command. */
+			  /* XXX - I don't think it matters, but we might
+			     want to change this in the future to avoid
+			     problems differentiating between a function
+			     definition with a redirection and a function
+			     definition containing a single command with a
+			     redirection.  The two are semantically equivalent,
+			     though -- the only difference is in how the
+			     command printing code displays the redirections. */
+			  if (tc->redirects)
+			    {
+			      register REDIRECT *t;
+			      for (t = tc->redirects; t->next; t = t->next)
+				;
+			      t->next = $2;
+			    }
+			  else
+			    tc->redirects = $2;
+			  $$ = $1;
+			}
+	;
+
+subshell:	'(' compound_list ')'
+			{
+			  $$ = make_subshell_command ($2);
+			  $$->flags |= CMD_WANT_SUBSHELL;
+			}
+	;
+
+coproc:		COPROC shell_command
+			{
+			  $$ = make_coproc_command ("COPROC", $2);
+			  $$->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
+			}
+	|	COPROC shell_command redirection_list
+			{
+			  COMMAND *tc;
+
+			  tc = $2;
+			  if (tc->redirects)
+			    {
+			      register REDIRECT *t;
+			      for (t = tc->redirects; t->next; t = t->next)
+				;
+			      t->next = $3;
+			    }
+			  else
+			    tc->redirects = $3;
+			  $$ = make_coproc_command ("COPROC", $2);
+			  $$->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
+			}
+	|	COPROC WORD shell_command
+			{
+			  $$ = make_coproc_command ($2->word, $3);
+			  $$->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
+			}
+	|	COPROC WORD shell_command redirection_list
+			{
+			  COMMAND *tc;
+
+			  tc = $3;
+			  if (tc->redirects)
+			    {
+			      register REDIRECT *t;
+			      for (t = tc->redirects; t->next; t = t->next)
+				;
+			      t->next = $4;
+			    }
+			  else
+			    tc->redirects = $4;
+			  $$ = make_coproc_command ($2->word, $3);
+			  $$->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
+			}
+	|	COPROC simple_command
+			{
+			  $$ = make_coproc_command ("COPROC", clean_simple_command ($2));
+			  $$->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
+			}
+	;
+
+if_command:	IF compound_list THEN compound_list FI
+			{ $$ = make_if_command ($2, $4, (COMMAND *)NULL); }
+	|	IF compound_list THEN compound_list ELSE compound_list FI
+			{ $$ = make_if_command ($2, $4, $6); }
+	|	IF compound_list THEN compound_list elif_clause FI
+			{ $$ = make_if_command ($2, $4, $5); }
+	;
+
+
+group_command:	'{' compound_list '}'
+			{ $$ = make_group_command ($2); }
+	;
+
+arith_command:	ARITH_CMD
+			{ $$ = make_arith_command ($1); }
+	;
+
+cond_command:	COND_START COND_CMD COND_END
+			{ $$ = $2; }
+	;
+
+elif_clause:	ELIF compound_list THEN compound_list
+			{ $$ = make_if_command ($2, $4, (COMMAND *)NULL); }
+	|	ELIF compound_list THEN compound_list ELSE compound_list
+			{ $$ = make_if_command ($2, $4, $6); }
+	|	ELIF compound_list THEN compound_list elif_clause
+			{ $$ = make_if_command ($2, $4, $5); }
+	;
+
+case_clause:	pattern_list
+	|	case_clause_sequence pattern_list
+			{ $2->next = $1; $$ = $2; }
+	;
+
+pattern_list:	newline_list pattern ')' compound_list
+			{ $$ = make_pattern_list ($2, $4); }
+	|	newline_list pattern ')' newline_list
+			{ $$ = make_pattern_list ($2, (COMMAND *)NULL); }
+	|	newline_list '(' pattern ')' compound_list
+			{ $$ = make_pattern_list ($3, $5); }
+	|	newline_list '(' pattern ')' newline_list
+			{ $$ = make_pattern_list ($3, (COMMAND *)NULL); }
+	;
+
+case_clause_sequence:  pattern_list SEMI_SEMI
+			{ $$ = $1; }
+	|	case_clause_sequence pattern_list SEMI_SEMI
+			{ $2->next = $1; $$ = $2; }
+	|	pattern_list SEMI_AND
+			{ $1->flags |= CASEPAT_FALLTHROUGH; $$ = $1; }
+	|	case_clause_sequence pattern_list SEMI_AND
+			{ $2->flags |= CASEPAT_FALLTHROUGH; $2->next = $1; $$ = $2; }
+	|	pattern_list SEMI_SEMI_AND
+			{ $1->flags |= CASEPAT_TESTNEXT; $$ = $1; }
+	|	case_clause_sequence pattern_list SEMI_SEMI_AND
+			{ $2->flags |= CASEPAT_TESTNEXT; $2->next = $1; $$ = $2; }
+	;
+
+pattern:	WORD
+			{ $$ = make_word_list ($1, (WORD_LIST *)NULL); }
+	|	pattern '|' WORD
+			{ $$ = make_word_list ($3, $1); }
+	;
+
+/* A list allows leading or trailing newlines and
+   newlines as operators (equivalent to semicolons).
+   It must end with a newline or semicolon.
+   Lists are used within commands such as if, for, while.  */
+
+list:		newline_list list0
+			{
+			  $$ = $2;
+			  if (need_here_doc)
+			    gather_here_documents ();
+			 }
+	;
+
+compound_list:	list
+	|	newline_list list1
+			{
+			  $$ = $2;
+			}
+	;
+
+list0:  	list1 '\n' newline_list
+	|	list1 '&' newline_list
+			{
+			  if ($1->type == cm_connection)
+			    $$ = connect_async_list ($1, (COMMAND *)NULL, '&');
+			  else
+			    $$ = command_connect ($1, (COMMAND *)NULL, '&');
+			}
+	|	list1 ';' newline_list
+
+	;
+
+list1:		list1 AND_AND newline_list list1
+			{ $$ = command_connect ($1, $4, AND_AND); }
+	|	list1 OR_OR newline_list list1
+			{ $$ = command_connect ($1, $4, OR_OR); }
+	|	list1 '&' newline_list list1
+			{
+			  if ($1->type == cm_connection)
+			    $$ = connect_async_list ($1, $4, '&');
+			  else
+			    $$ = command_connect ($1, $4, '&');
+			}
+	|	list1 ';' newline_list list1
+			{ $$ = command_connect ($1, $4, ';'); }
+	|	list1 '\n' newline_list list1
+			{ $$ = command_connect ($1, $4, ';'); }
+	|	pipeline_command
+			{ $$ = $1; }
+	;
+
+simple_list_terminator:	'\n'
+	|	yacc_EOF
+	;
+
+list_terminator:'\n'
+		{ $$ = '\n'; }
+	|	';'
+		{ $$ = ';'; }
+	|	yacc_EOF
+		{ $$ = yacc_EOF; }
+	;
+
+newline_list:
+	|	newline_list '\n'
+	;
+
+/* A simple_list is a list that contains no significant newlines
+   and no leading or trailing newlines.  Newlines are allowed
+   only following operators, where they are not significant.
+
+   This is what an inputunit consists of.  */
+
+simple_list:	simple_list1
+			{
+			  $$ = $1;
+			  if (need_here_doc)
+			    gather_here_documents ();
+			  if ((parser_state & PST_CMDSUBST) && current_token == shell_eof_token)
+			    {
+			      global_command = $1;
+			      eof_encountered = 0;
+			      rewind_input_string ();
+			      YYACCEPT;
+			    }
+			}
+	|	simple_list1 '&'
+			{
+			  if ($1->type == cm_connection)
+			    $$ = connect_async_list ($1, (COMMAND *)NULL, '&');
+			  else
+			    $$ = command_connect ($1, (COMMAND *)NULL, '&');
+			  if (need_here_doc)
+			    gather_here_documents ();
+			  if ((parser_state & PST_CMDSUBST) && current_token == shell_eof_token)
+			    {
+			      global_command = $1;
+			      eof_encountered = 0;
+			      rewind_input_string ();
+			      YYACCEPT;
+			    }
+			}
+	|	simple_list1 ';'
+			{
+			  $$ = $1;
+			  if (need_here_doc)
+			    gather_here_documents ();
+			  if ((parser_state & PST_CMDSUBST) && current_token == shell_eof_token)
+			    {
+			      global_command = $1;
+			      eof_encountered = 0;
+			      rewind_input_string ();
+			      YYACCEPT;
+			    }
+			}
+	;
+
+simple_list1:	simple_list1 AND_AND newline_list simple_list1
+			{ $$ = command_connect ($1, $4, AND_AND); }
+	|	simple_list1 OR_OR newline_list simple_list1
+			{ $$ = command_connect ($1, $4, OR_OR); }
+	|	simple_list1 '&' simple_list1
+			{
+			  if ($1->type == cm_connection)
+			    $$ = connect_async_list ($1, $3, '&');
+			  else
+			    $$ = command_connect ($1, $3, '&');
+			}
+	|	simple_list1 ';' simple_list1
+			{ $$ = command_connect ($1, $3, ';'); }
+
+	|	pipeline_command
+			{ $$ = $1; }
+	;
+
+pipeline_command: pipeline
+			{ $$ = $1; }
+	|	BANG pipeline
+			{
+			  if ($2)
+			    $2->flags |= CMD_INVERT_RETURN;
+			  $$ = $2;
+			}
+	|	timespec pipeline
+			{
+			  if ($2)
+			    $2->flags |= $1;
+			  $$ = $2;
+			}
+	|	timespec BANG pipeline
+			{
+			  if ($3)
+			    $3->flags |= $1|CMD_INVERT_RETURN;
+			  $$ = $3;
+			}
+	|	BANG timespec pipeline
+			{
+			  if ($3)
+			    $3->flags |= $2|CMD_INVERT_RETURN;
+			  $$ = $3;
+			}
+	|	timespec list_terminator
+			{
+			  ELEMENT x;
+
+			  /* Boy, this is unclean.  `time' by itself can
+			     time a null command.  We cheat and push a
+			     newline back if the list_terminator was a newline
+			     to avoid the double-newline problem (one to
+			     terminate this, one to terminate the command) */
+			  x.word = 0;
+			  x.redirect = 0;
+			  $$ = make_simple_command (x, (COMMAND *)NULL);
+			  $$->flags |= $1;
+			  /* XXX - let's cheat and push a newline back */
+			  if ($2 == '\n')
+			    token_to_read = '\n';
+			}
+
+	;
+
+pipeline:	pipeline '|' newline_list pipeline
+			{ $$ = command_connect ($1, $4, '|'); }
+	|	pipeline BAR_AND newline_list pipeline
+			{
+			  /* Make cmd1 |& cmd2 equivalent to cmd1 2>&1 | cmd2 */
+			  COMMAND *tc;
+			  REDIRECTEE rd;
+			  REDIRECT *r;
+
+			  tc = $1->type == cm_simple ? (COMMAND *)$1->value.Simple : $1;
+			  rd.dest = 1;
+			  r = make_redirection (2, r_duplicating_output, rd);
+			  if (tc->redirects)
+			    {
+			      register REDIRECT *t;
+			      for (t = tc->redirects; t->next; t = t->next)
+				;
+			      t->next = r;
+			    }
+			  else
+			    tc->redirects = r;
+
+			  $$ = command_connect ($1, $4, '|');
+			}
+	|	command
+			{ $$ = $1; }
+	;
+
+timespec:	TIME
+			{ $$ = CMD_TIME_PIPELINE; }
+	|	TIME TIMEOPT
+			{ $$ = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }
+	;
+%%
+
+/* Initial size to allocate for tokens, and the
+   amount to grow them by. */
+#define TOKEN_DEFAULT_INITIAL_SIZE 496
+#define TOKEN_DEFAULT_GROW_SIZE 512
+
+/* Should we call prompt_again? */
+#define SHOULD_PROMPT() \
+  (interactive && (bash_input.type == st_stdin || bash_input.type == st_stream))
+
+#if defined (ALIAS)
+#  define expanding_alias() (pushed_string_list && pushed_string_list->expander)
+#else
+#  define expanding_alias() 0
+#endif
+
+/* Global var is non-zero when end of file has been reached. */
+int EOF_Reached = 0;
+
+#ifdef DEBUG
+static void
+debug_parser (i)
+     int i;
+{
+#if YYDEBUG != 0
+  yydebug = i;
+#endif
+}
+#endif
+
+/* yy_getc () returns the next available character from input or EOF.
+   yy_ungetc (c) makes `c' the next character to read.
+   init_yy_io (get, unget, type, location) makes the function GET the
+   installed function for getting the next character, makes UNGET the
+   installed function for un-getting a character, sets the type of stream
+   (either string or file) from TYPE, and makes LOCATION point to where
+   the input is coming from. */
+
+/* Unconditionally returns end-of-file. */
+int
+return_EOF ()
+{
+  return (EOF);
+}
+
+/* Variable containing the current get and unget functions.
+   See ./input.h for a clearer description. */
+BASH_INPUT bash_input;
+
+/* Set all of the fields in BASH_INPUT to NULL.  Free bash_input.name if it
+   is non-null, avoiding a memory leak. */
+void
+initialize_bash_input ()
+{
+  bash_input.type = st_none;
+  FREE (bash_input.name);
+  bash_input.name = (char *)NULL;
+  bash_input.location.file = (FILE *)NULL;
+  bash_input.location.string = (char *)NULL;
+  bash_input.getter = (sh_cget_func_t *)NULL;
+  bash_input.ungetter = (sh_cunget_func_t *)NULL;
+}
+
+/* Set the contents of the current bash input stream from
+   GET, UNGET, TYPE, NAME, and LOCATION. */
+void
+init_yy_io (get, unget, type, name, location)
+     sh_cget_func_t *get;
+     sh_cunget_func_t *unget;
+     enum stream_type type;
+     const char *name;
+     INPUT_STREAM location;
+{
+  bash_input.type = type;
+  FREE (bash_input.name);
+  bash_input.name = name ? savestring (name) : (char *)NULL;
+
+  /* XXX */
+#if defined (CRAY)
+  memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
+#else
+  bash_input.location = location;
+#endif
+  bash_input.getter = get;
+  bash_input.ungetter = unget;
+}
+
+char *
+yy_input_name ()
+{
+  return (bash_input.name ? bash_input.name : "stdin");
+}
+
+/* Call this to get the next character of input. */
+static int
+yy_getc ()
+{
+  return (*(bash_input.getter)) ();
+}
+
+/* Call this to unget C.  That is, to make C the next character
+   to be read. */
+static int
+yy_ungetc (c)
+     int c;
+{
+  return (*(bash_input.ungetter)) (c);
+}
+
+#if defined (BUFFERED_INPUT)
+#ifdef INCLUDE_UNUSED
+int
+input_file_descriptor ()
+{
+  switch (bash_input.type)
+    {
+    case st_stream:
+      return (fileno (bash_input.location.file));
+    case st_bstream:
+      return (bash_input.location.buffered_fd);
+    case st_stdin:
+    default:
+      return (fileno (stdin));
+    }
+}
+#endif
+#endif /* BUFFERED_INPUT */
+
+/* **************************************************************** */
+/*								    */
+/*		  Let input be read from readline ().		    */
+/*								    */
+/* **************************************************************** */
+
+#if defined (READLINE)
+char *current_readline_prompt = (char *)NULL;
+char *current_readline_line = (char *)NULL;
+int current_readline_line_index = 0;
+
+static int
+yy_readline_get ()
+{
+  SigHandler *old_sigint;
+  int line_len;
+  unsigned char c;
+
+  if (!current_readline_line)
+    {
+      if (!bash_readline_initialized)
+	initialize_readline ();
+
+#if defined (JOB_CONTROL)
+      if (job_control)
+	give_terminal_to (shell_pgrp, 0);
+#endif /* JOB_CONTROL */
+
+      old_sigint = (SigHandler *)NULL;
+      if (signal_is_ignored (SIGINT) == 0)
+	{
+	  old_sigint = (SigHandler *)set_signal_handler (SIGINT, sigint_sighandler);
+	  interrupt_immediately++;
+	}
+      terminate_immediately = 1;
+
+      current_readline_line = readline (current_readline_prompt ?
+      					  current_readline_prompt : "");
+
+      terminate_immediately = 0;
+      if (signal_is_ignored (SIGINT) == 0 && old_sigint)
+	{
+	  interrupt_immediately--;
+	  set_signal_handler (SIGINT, old_sigint);
+	}
+
+#if 0
+      /* Reset the prompt to the decoded value of prompt_string_pointer. */
+      reset_readline_prompt ();
+#endif
+
+      if (current_readline_line == 0)
+	return (EOF);
+
+      current_readline_line_index = 0;
+      line_len = strlen (current_readline_line);
+
+      current_readline_line = (char *)xrealloc (current_readline_line, 2 + line_len);
+      current_readline_line[line_len++] = '\n';
+      current_readline_line[line_len] = '\0';
+    }
+
+  if (current_readline_line[current_readline_line_index] == 0)
+    {
+      free (current_readline_line);
+      current_readline_line = (char *)NULL;
+      return (yy_readline_get ());
+    }
+  else
+    {
+      c = current_readline_line[current_readline_line_index++];
+      return (c);
+    }
+}
+
+static int
+yy_readline_unget (c)
+     int c;
+{
+  if (current_readline_line_index && current_readline_line)
+    current_readline_line[--current_readline_line_index] = c;
+  return (c);
+}
+
+void
+with_input_from_stdin ()
+{
+  INPUT_STREAM location;
+
+  if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)
+    {
+      location.string = current_readline_line;
+      init_yy_io (yy_readline_get, yy_readline_unget,
+		  st_stdin, "readline stdin", location);
+    }
+}
+
+#else  /* !READLINE */
+
+void
+with_input_from_stdin ()
+{
+  with_input_from_stream (stdin, "stdin");
+}
+#endif	/* !READLINE */
+
+/* **************************************************************** */
+/*								    */
+/*   Let input come from STRING.  STRING is zero terminated.	    */
+/*								    */
+/* **************************************************************** */
+
+static int
+yy_string_get ()
+{
+  register char *string;
+  register unsigned char c;
+
+  string = bash_input.location.string;
+
+  /* If the string doesn't exist, or is empty, EOF found. */
+  if (string && *string)
+    {
+      c = *string++;
+      bash_input.location.string = string;
+      return (c);
+    }
+  else
+    return (EOF);
+}
+
+static int
+yy_string_unget (c)
+     int c;
+{
+  *(--bash_input.location.string) = c;
+  return (c);
+}
+
+void
+with_input_from_string (string, name)
+     char *string;
+     const char *name;
+{
+  INPUT_STREAM location;
+
+  location.string = string;
+  init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
+}
+
+/* Count the number of characters we've consumed from bash_input.location.string
+   and read into shell_input_line, but have not returned from shell_getc.
+   That is the true input location.  Rewind bash_input.location.string by
+   that number of characters, so it points to the last character actually
+   consumed by the parser. */
+static void
+rewind_input_string ()
+{
+  int xchars;
+
+  /* number of unconsumed characters in the input -- XXX need to take newlines
+     into account, e.g., $(...\n) */
+  xchars = shell_input_line_len - shell_input_line_index;
+  if (bash_input.location.string[-1] == '\n')
+    xchars++;
+
+  /* XXX - how to reflect bash_input.location.string back to string passed to
+     parse_and_execute or xparse_dolparen?  xparse_dolparen needs to know how
+     far into the string we parsed.  parse_and_execute knows where bash_input.
+     location.string is, and how far from orig_string that is -- that's the
+     number of characters the command consumed. */
+
+  /* bash_input.location.string - xchars should be where we parsed to */
+  /* need to do more validation on xchars value for sanity -- test cases. */
+  bash_input.location.string -= xchars;
+}
+
+/* **************************************************************** */
+/*								    */
+/*		     Let input come from STREAM.		    */
+/*								    */
+/* **************************************************************** */
+
+/* These two functions used to test the value of the HAVE_RESTARTABLE_SYSCALLS
+   define, and just use getc/ungetc if it was defined, but since bash
+   installs its signal handlers without the SA_RESTART flag, some signals
+   (like SIGCHLD, SIGWINCH, etc.) received during a read(2) will not cause
+   the read to be restarted.  We need to restart it ourselves. */
+
+static int
+yy_stream_get ()
+{
+  int result;
+
+  result = EOF;
+  if (bash_input.location.file)
+    {
+      if (interactive)
+	{
+	  interrupt_immediately++;
+	  terminate_immediately++;
+	}
+      result = getc_with_restart (bash_input.location.file);
+      if (interactive)
+	{
+	  interrupt_immediately--;
+	  terminate_immediately--;
+	}
+    }
+  return (result);
+}
+
+static int
+yy_stream_unget (c)
+     int c;
+{
+  return (ungetc_with_restart (c, bash_input.location.file));
+}
+
+void
+with_input_from_stream (stream, name)
+     FILE *stream;
+     const char *name;
+{
+  INPUT_STREAM location;
+
+  location.file = stream;
+  init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
+}
+
+typedef struct stream_saver {
+  struct stream_saver *next;
+  BASH_INPUT bash_input;
+  int line;
+#if defined (BUFFERED_INPUT)
+  BUFFERED_STREAM *bstream;
+#endif /* BUFFERED_INPUT */
+} STREAM_SAVER;
+
+/* The globally known line number. */
+int line_number = 0;
+
+#if defined (COND_COMMAND)
+static int cond_lineno;
+static int cond_token;
+#endif
+
+STREAM_SAVER *stream_list = (STREAM_SAVER *)NULL;
+
+void
+push_stream (reset_lineno)
+     int reset_lineno;
+{
+  STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));
+
+  xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));
+
+#if defined (BUFFERED_INPUT)
+  saver->bstream = (BUFFERED_STREAM *)NULL;
+  /* If we have a buffered stream, clear out buffers[fd]. */
+  if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
+    saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
+    					  (BUFFERED_STREAM *)NULL);
+#endif /* BUFFERED_INPUT */
+
+  saver->line = line_number;
+  bash_input.name = (char *)NULL;
+  saver->next = stream_list;
+  stream_list = saver;
+  EOF_Reached = 0;
+  if (reset_lineno)
+    line_number = 0;
+}
+
+void
+pop_stream ()
+{
+  if (!stream_list)
+    EOF_Reached = 1;
+  else
+    {
+      STREAM_SAVER *saver = stream_list;
+
+      EOF_Reached = 0;
+      stream_list = stream_list->next;
+
+      init_yy_io (saver->bash_input.getter,
+		  saver->bash_input.ungetter,
+		  saver->bash_input.type,
+		  saver->bash_input.name,
+		  saver->bash_input.location);
+
+#if defined (BUFFERED_INPUT)
+      /* If we have a buffered stream, restore buffers[fd]. */
+      /* If the input file descriptor was changed while this was on the
+	 save stack, update the buffered fd to the new file descriptor and
+	 re-establish the buffer <-> bash_input fd correspondence. */
+      if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
+	{
+	  if (bash_input_fd_changed)
+	    {
+	      bash_input_fd_changed = 0;
+	      if (default_buffered_input >= 0)
+		{
+		  bash_input.location.buffered_fd = default_buffered_input;
+		  saver->bstream->b_fd = default_buffered_input;
+		  SET_CLOSE_ON_EXEC (default_buffered_input);
+		}
+	    }
+	  /* XXX could free buffered stream returned as result here. */
+	  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);
+	}
+#endif /* BUFFERED_INPUT */
+
+      line_number = saver->line;
+
+      FREE (saver->bash_input.name);
+      free (saver);
+    }
+}
+
+/* Return 1 if a stream of type TYPE is saved on the stack. */
+int
+stream_on_stack (type)
+     enum stream_type type;
+{
+  register STREAM_SAVER *s;
+
+  for (s = stream_list; s; s = s->next)
+    if (s->bash_input.type == type)
+      return 1;
+  return 0;
+}
+
+/* Save the current token state and return it in a malloced array. */
+int *
+save_token_state ()
+{
+  int *ret;
+
+  ret = (int *)xmalloc (4 * sizeof (int));
+  ret[0] = last_read_token;
+  ret[1] = token_before_that;
+  ret[2] = two_tokens_ago;
+  ret[3] = current_token;
+  return ret;
+}
+
+void
+restore_token_state (ts)
+     int *ts;
+{
+  if (ts == 0)
+    return;
+  last_read_token = ts[0];
+  token_before_that = ts[1];
+  two_tokens_ago = ts[2];
+  current_token = ts[3];
+}
+
+/*
+ * This is used to inhibit alias expansion and reserved word recognition
+ * inside case statement pattern lists.  A `case statement pattern list' is:
+ *
+ *	everything between the `in' in a `case word in' and the next ')'
+ *	or `esac'
+ *	everything between a `;;' and the next `)' or `esac'
+ */
+
+#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
+
+#define END_OF_ALIAS 0
+
+/*
+ * Pseudo-global variables used in implementing token-wise alias expansion.
+ */
+
+/*
+ * Pushing and popping strings.  This works together with shell_getc to
+ * implement alias expansion on a per-token basis.
+ */
+
+typedef struct string_saver {
+  struct string_saver *next;
+  int expand_alias;  /* Value to set expand_alias to when string is popped. */
+  char *saved_line;
+#if defined (ALIAS)
+  alias_t *expander;   /* alias that caused this line to be pushed. */
+#endif
+  int saved_line_size, saved_line_index, saved_line_terminator;
+} STRING_SAVER;
+
+STRING_SAVER *pushed_string_list = (STRING_SAVER *)NULL;
+
+/*
+ * Push the current shell_input_line onto a stack of such lines and make S
+ * the current input.  Used when expanding aliases.  EXPAND is used to set
+ * the value of expand_next_token when the string is popped, so that the
+ * word after the alias in the original line is handled correctly when the
+ * alias expands to multiple words.  TOKEN is the token that was expanded
+ * into S; it is saved and used to prevent infinite recursive expansion.
+ */
+static void
+push_string (s, expand, ap)
+     char *s;
+     int expand;
+     alias_t *ap;
+{
+  STRING_SAVER *temp = (STRING_SAVER *)xmalloc (sizeof (STRING_SAVER));
+
+  temp->expand_alias = expand;
+  temp->saved_line = shell_input_line;
+  temp->saved_line_size = shell_input_line_size;
+  temp->saved_line_index = shell_input_line_index;
+  temp->saved_line_terminator = shell_input_line_terminator;
+#if defined (ALIAS)
+  temp->expander = ap;
+#endif
+  temp->next = pushed_string_list;
+  pushed_string_list = temp;
+
+#if defined (ALIAS)
+  if (ap)
+    ap->flags |= AL_BEINGEXPANDED;
+#endif
+
+  shell_input_line = s;
+  shell_input_line_size = strlen (s);
+  shell_input_line_index = 0;
+  shell_input_line_terminator = '\0';
+#if 0
+  parser_state &= ~PST_ALEXPNEXT;	/* XXX */
+#endif
+
+  set_line_mbstate ();
+}
+
+/*
+ * Make the top of the pushed_string stack be the current shell input.
+ * Only called when there is something on the stack.  Called from shell_getc
+ * when it thinks it has consumed the string generated by an alias expansion
+ * and needs to return to the original input line.
+ */
+static void
+pop_string ()
+{
+  STRING_SAVER *t;
+
+  FREE (shell_input_line);
+  shell_input_line = pushed_string_list->saved_line;
+  shell_input_line_index = pushed_string_list->saved_line_index;
+  shell_input_line_size = pushed_string_list->saved_line_size;
+  shell_input_line_terminator = pushed_string_list->saved_line_terminator;
+
+  if (pushed_string_list->expand_alias)
+    parser_state |= PST_ALEXPNEXT;
+  else
+    parser_state &= ~PST_ALEXPNEXT;
+
+  t = pushed_string_list;
+  pushed_string_list = pushed_string_list->next;
+
+#if defined (ALIAS)
+  if (t->expander)
+    t->expander->flags &= ~AL_BEINGEXPANDED;
+#endif
+
+  free ((char *)t);
+
+  set_line_mbstate ();
+}
+
+static void
+free_string_list ()
+{
+  register STRING_SAVER *t, *t1;
+
+  for (t = pushed_string_list; t; )
+    {
+      t1 = t->next;
+      FREE (t->saved_line);
+#if defined (ALIAS)
+      if (t->expander)
+	t->expander->flags &= ~AL_BEINGEXPANDED;
+#endif
+      free ((char *)t);
+      t = t1;
+    }
+  pushed_string_list = (STRING_SAVER *)NULL;
+}
+
+#endif /* ALIAS || DPAREN_ARITHMETIC */
+
+void
+free_pushed_string_input ()
+{
+#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
+  free_string_list ();
+#endif
+}
+
+/* Return a line of text, taken from wherever yylex () reads input.
+   If there is no more input, then we return NULL.  If REMOVE_QUOTED_NEWLINE
+   is non-zero, we remove unquoted \<newline> pairs.  This is used by
+   read_secondary_line to read here documents. */
+static char *
+read_a_line (remove_quoted_newline)
+     int remove_quoted_newline;
+{
+  static char *line_buffer = (char *)NULL;
+  static int buffer_size = 0;
+  int indx = 0, c, peekc, pass_next;
+
+#if defined (READLINE)
+  if (no_line_editing && SHOULD_PROMPT ())
+#else
+  if (SHOULD_PROMPT ())
+#endif
+    print_prompt ();
+
+  pass_next = 0;
+  while (1)
+    {
+      /* Allow immediate exit if interrupted during input. */
+      QUIT;
+
+      c = yy_getc ();
+
+      /* Ignore null bytes in input. */
+      if (c == 0)
+	{
+#if 0
+	  internal_warning ("read_a_line: ignored null byte in input");
+#endif
+	  continue;
+	}
+
+      /* If there is no more input, then we return NULL. */
+      if (c == EOF)
+	{
+	  if (interactive && bash_input.type == st_stream)
+	    clearerr (stdin);
+	  if (indx == 0)
+	    return ((char *)NULL);
+	  c = '\n';
+	}
+
+      /* `+2' in case the final character in the buffer is a newline. */
+      RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);
+
+      /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
+	 here document with an unquoted delimiter.  In this case,
+	 the line will be expanded as if it were in double quotes.
+	 We allow a backslash to escape the next character, but we
+	 need to treat the backslash specially only if a backslash
+	 quoting a backslash-newline pair appears in the line. */
+      if (pass_next)
+	{
+	  line_buffer[indx++] = c;
+	  pass_next = 0;
+	}
+      else if (c == '\\' && remove_quoted_newline)
+	{
+	  peekc = yy_getc ();
+	  if (peekc == '\n')
+	    {
+	      line_number++;
+	      continue;	/* Make the unquoted \<newline> pair disappear. */
+	    }
+	  else
+	    {
+	      yy_ungetc (peekc);
+	      pass_next = 1;
+	      line_buffer[indx++] = c;		/* Preserve the backslash. */
+	    }
+	}
+      else
+	line_buffer[indx++] = c;
+
+      if (c == '\n')
+	{
+	  line_buffer[indx] = '\0';
+	  return (line_buffer);
+	}
+    }
+}
+
+/* Return a line as in read_a_line (), but insure that the prompt is
+   the secondary prompt.  This is used to read the lines of a here
+   document.  REMOVE_QUOTED_NEWLINE is non-zero if we should remove
+   newlines quoted with backslashes while reading the line.  It is
+   non-zero unless the delimiter of the here document was quoted. */
+char *
+read_secondary_line (remove_quoted_newline)
+     int remove_quoted_newline;
+{
+  char *ret;
+
+  prompt_string_pointer = &ps2_prompt;
+  if (SHOULD_PROMPT())
+    prompt_again ();
+  ret = read_a_line (remove_quoted_newline);
+#if defined (HISTORY)
+  if (ret && remember_on_history && (parser_state & PST_HEREDOC))
+    {
+      /* To make adding the the here-document body right, we need to rely
+	 on history_delimiting_chars() returning \n for the first line of
+	 the here-document body and the null string for the second and
+	 subsequent lines, so we avoid double newlines.
+	 current_command_line_count == 2 for the first line of the body. */
+
+      current_command_line_count++;
+      maybe_add_history (ret);
+    }
+#endif /* HISTORY */
+  return ret;
+}
+
+/* **************************************************************** */
+/*								    */
+/*				YYLEX ()			    */
+/*								    */
+/* **************************************************************** */
+
+/* Reserved words.  These are only recognized as the first word of a
+   command. */
+STRING_INT_ALIST word_token_alist[] = {
+  { "if", IF },
+  { "then", THEN },
+  { "else", ELSE },
+  { "elif", ELIF },
+  { "fi", FI },
+  { "case", CASE },
+  { "esac", ESAC },
+  { "for", FOR },
+#if defined (SELECT_COMMAND)
+  { "select", SELECT },
+#endif
+  { "while", WHILE },
+  { "until", UNTIL },
+  { "do", DO },
+  { "done", DONE },
+  { "in", IN },
+  { "function", FUNCTION },
+#if defined (COMMAND_TIMING)
+  { "time", TIME },
+#endif
+  { "{", '{' },
+  { "}", '}' },
+  { "!", BANG },
+#if defined (COND_COMMAND)
+  { "[[", COND_START },
+  { "]]", COND_END },
+#endif
+#if defined (COPROCESS_SUPPORT)
+  { "coproc", COPROC },
+#endif
+  { (char *)NULL, 0}
+};
+
+/* other tokens that can be returned by read_token() */
+STRING_INT_ALIST other_token_alist[] = {
+  /* Multiple-character tokens with special values */
+  { "-p", TIMEOPT },
+  { "&&", AND_AND },
+  { "||", OR_OR },
+  { ">>", GREATER_GREATER },
+  { "<<", LESS_LESS },
+  { "<&", LESS_AND },
+  { ">&", GREATER_AND },
+  { ";;", SEMI_SEMI },
+  { ";&", SEMI_AND },
+  { ";;&", SEMI_SEMI_AND },
+  { "<<-", LESS_LESS_MINUS },
+  { "<<<", LESS_LESS_LESS },
+  { "&>", AND_GREATER },
+  { "&>>", AND_GREATER_GREATER },
+  { "<>", LESS_GREATER },
+  { ">|", GREATER_BAR },
+  { "|&", BAR_AND },
+  { "EOF", yacc_EOF },
+  /* Tokens whose value is the character itself */
+  { ">", '>' },
+  { "<", '<' },
+  { "-", '-' },
+  { "{", '{' },
+  { "}", '}' },
+  { ";", ';' },
+  { "(", '(' },
+  { ")", ')' },
+  { "|", '|' },
+  { "&", '&' },
+  { "newline", '\n' },
+  { (char *)NULL, 0}
+};
+
+/* others not listed here:
+	WORD			look at yylval.word
+	ASSIGNMENT_WORD		look at yylval.word
+	NUMBER			look at yylval.number
+	ARITH_CMD		look at yylval.word_list
+	ARITH_FOR_EXPRS		look at yylval.word_list
+	COND_CMD		look at yylval.command
+*/
+
+/* These are used by read_token_word, but appear up here so that shell_getc
+   can use them to decide when to add otherwise blank lines to the history. */
+
+/* The primary delimiter stack. */
+struct dstack dstack = {  (char *)NULL, 0, 0 };
+
+/* A temporary delimiter stack to be used when decoding prompt strings.
+   This is needed because command substitutions in prompt strings (e.g., PS2)
+   can screw up the parser's quoting state. */
+static struct dstack temp_dstack = { (char *)NULL, 0, 0 };
+
+/* Macro for accessing the top delimiter on the stack.  Returns the
+   delimiter or zero if none. */
+#define current_delimiter(ds) \
+  (ds.delimiter_depth ? ds.delimiters[ds.delimiter_depth - 1] : 0)
+
+#define push_delimiter(ds, character) \
+  do \
+    { \
+      if (ds.delimiter_depth + 2 > ds.delimiter_space) \
+	ds.delimiters = (char *)xrealloc \
+	  (ds.delimiters, (ds.delimiter_space += 10) * sizeof (char)); \
+      ds.delimiters[ds.delimiter_depth] = character; \
+      ds.delimiter_depth++; \
+    } \
+  while (0)
+
+#define pop_delimiter(ds)	ds.delimiter_depth--
+
+/* Return the next shell input character.  This always reads characters
+   from shell_input_line; when that line is exhausted, it is time to
+   read the next line.  This is called by read_token when the shell is
+   processing normal command input. */
+
+/* This implements one-character lookahead/lookbehind across physical input
+   lines, to avoid something being lost because it's pushed back with
+   shell_ungetc when we're at the start of a line. */
+static int eol_ungetc_lookahead = 0;
+
+static int
+shell_getc (remove_quoted_newline)
+     int remove_quoted_newline;
+{
+  register int i;
+  int c;
+  unsigned char uc;
+
+  QUIT;
+
+  if (sigwinch_received)
+    {
+      sigwinch_received = 0;
+      get_new_window_size (0, (int *)0, (int *)0);
+    }
+
+  if (eol_ungetc_lookahead)
+    {
+      c = eol_ungetc_lookahead;
+      eol_ungetc_lookahead = 0;
+      return (c);
+    }
+
+#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
+  /* If shell_input_line[shell_input_line_index] == 0, but there is
+     something on the pushed list of strings, then we don't want to go
+     off and get another line.  We let the code down below handle it. */
+
+  if (!shell_input_line || ((!shell_input_line[shell_input_line_index]) &&
+			    (pushed_string_list == (STRING_SAVER *)NULL)))
+#else /* !ALIAS && !DPAREN_ARITHMETIC */
+  if (!shell_input_line || !shell_input_line[shell_input_line_index])
+#endif /* !ALIAS && !DPAREN_ARITHMETIC */
+    {
+      line_number++;
+
+    restart_read:
+
+      /* Allow immediate exit if interrupted during input. */
+      QUIT;
+
+      i = 0;
+      shell_input_line_terminator = 0;
+
+      /* If the shell is interatctive, but not currently printing a prompt
+         (interactive_shell && interactive == 0), we don't want to print
+         notifies or cleanup the jobs -- we want to defer it until we do
+         print the next prompt. */
+      if (interactive_shell == 0 || SHOULD_PROMPT())
+	{
+#if defined (JOB_CONTROL)
+      /* This can cause a problem when reading a command as the result
+	 of a trap, when the trap is called from flush_child.  This call
+	 had better not cause jobs to disappear from the job table in
+	 that case, or we will have big trouble. */
+	  notify_and_cleanup ();
+#else /* !JOB_CONTROL */
+	  cleanup_dead_jobs ();
+#endif /* !JOB_CONTROL */
+	}
+
+#if defined (READLINE)
+      if (no_line_editing && SHOULD_PROMPT())
+#else
+      if (SHOULD_PROMPT())
+#endif
+	print_prompt ();
+
+      if (bash_input.type == st_stream)
+	clearerr (stdin);
+
+      while (1)
+	{
+	  c = yy_getc ();
+
+	  /* Allow immediate exit if interrupted during input. */
+	  QUIT;
+
+	  if (c == '\0')
+	    {
+#if 0
+	      internal_warning ("shell_getc: ignored null byte in input");
+#endif
+	      continue;
+	    }
+
+	  RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);
+
+	  if (c == EOF)
+	    {
+	      if (bash_input.type == st_stream)
+		clearerr (stdin);
+
+	      if (i == 0)
+		shell_input_line_terminator = EOF;
+
+	      shell_input_line[i] = '\0';
+	      break;
+	    }
+
+	  shell_input_line[i++] = c;
+
+	  if (c == '\n')
+	    {
+	      shell_input_line[--i] = '\0';
+	      current_command_line_count++;
+	      break;
+	    }
+	}
+
+      shell_input_line_index = 0;
+      shell_input_line_len = i;		/* == strlen (shell_input_line) */
+
+      set_line_mbstate ();
+
+#if defined (HISTORY)
+      if (remember_on_history && shell_input_line && shell_input_line[0])
+	{
+	  char *expansions;
+#  if defined (BANG_HISTORY)
+	  int old_hist;
+
+	  /* If the current delimiter is a single quote, we should not be
+	     performing history expansion, even if we're on a different
+	     line from the original single quote. */
+	  old_hist = history_expansion_inhibited;
+	  if (current_delimiter (dstack) == '\'')
+	    history_expansion_inhibited = 1;
+#  endif
+	  expansions = pre_process_line (shell_input_line, 1, 1);
+#  if defined (BANG_HISTORY)
+	  history_expansion_inhibited = old_hist;
+#  endif
+	  if (expansions != shell_input_line)
+	    {
+	      free (shell_input_line);
+	      shell_input_line = expansions;
+	      shell_input_line_len = shell_input_line ?
+					strlen (shell_input_line) : 0;
+	      if (!shell_input_line_len)
+		current_command_line_count--;
+
+	      /* We have to force the xrealloc below because we don't know
+		 the true allocated size of shell_input_line anymore. */
+	      shell_input_line_size = shell_input_line_len;
+
+	      set_line_mbstate ();
+	    }
+	}
+      /* Try to do something intelligent with blank lines encountered while
+	 entering multi-line commands.  XXX - this is grotesque */
+      else if (remember_on_history && shell_input_line &&
+	       shell_input_line[0] == '\0' &&
+	       current_command_line_count > 1)
+	{
+	  if (current_delimiter (dstack))
+	    /* We know shell_input_line[0] == 0 and we're reading some sort of
+	       quoted string.  This means we've got a line consisting of only
+	       a newline in a quoted string.  We want to make sure this line
+	       gets added to the history. */
+	    maybe_add_history (shell_input_line);
+	  else
+	    {
+	      char *hdcs;
+	      hdcs = history_delimiting_chars ();
+	      if (hdcs && hdcs[0] == ';')
+		maybe_add_history (shell_input_line);
+	    }
+	}
+
+#endif /* HISTORY */
+
+      if (shell_input_line)
+	{
+	  /* Lines that signify the end of the shell's input should not be
+	     echoed. */
+	  if (echo_input_at_read && (shell_input_line[0] ||
+				     shell_input_line_terminator != EOF))
+	    fprintf (stderr, "%s\n", shell_input_line);
+	}
+      else
+	{
+	  shell_input_line_size = 0;
+	  prompt_string_pointer = &current_prompt_string;
+	  if (SHOULD_PROMPT ())
+	    prompt_again ();
+	  goto restart_read;
+	}
+
+      /* Add the newline to the end of this string, iff the string does
+	 not already end in an EOF character.  */
+      if (shell_input_line_terminator != EOF)
+	{
+	  if (shell_input_line_len + 3 > shell_input_line_size)
+	    shell_input_line = (char *)xrealloc (shell_input_line,
+					1 + (shell_input_line_size += 2));
+
+	  shell_input_line[shell_input_line_len] = '\n';
+	  shell_input_line[shell_input_line_len + 1] = '\0';
+
+	  set_line_mbstate ();
+	}
+    }
+
+  uc = shell_input_line[shell_input_line_index];
+
+  if (uc)
+    shell_input_line_index++;
+
+#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
+  /* If UC is NULL, we have reached the end of the current input string.  If
+     pushed_string_list is non-empty, it's time to pop to the previous string
+     because we have fully consumed the result of the last alias expansion.
+     Do it transparently; just return the next character of the string popped
+     to. */
+  if (!uc && (pushed_string_list != (STRING_SAVER *)NULL))
+    {
+      pop_string ();
+      uc = shell_input_line[shell_input_line_index];
+      if (uc)
+	shell_input_line_index++;
+    }
+#endif /* ALIAS || DPAREN_ARITHMETIC */
+
+  if MBTEST(uc == '\\' && remove_quoted_newline && shell_input_line[shell_input_line_index] == '\n')
+    {
+	if (SHOULD_PROMPT ())
+	  prompt_again ();
+	line_number++;
+	goto restart_read;
+    }
+
+  if (!uc && shell_input_line_terminator == EOF)
+    return ((shell_input_line_index != 0) ? '\n' : EOF);
+
+  return (uc);
+}
+
+/* Put C back into the input for the shell.  This might need changes for
+   HANDLE_MULTIBYTE around EOLs.  Since we (currently) never push back a
+   character different than we read, shell_input_line_property doesn't need
+   to change when manipulating shell_input_line.  The define for
+   last_shell_getc_is_singlebyte should take care of it, though. */
+static void
+shell_ungetc (c)
+     int c;
+{
+  if (shell_input_line && shell_input_line_index)
+    shell_input_line[--shell_input_line_index] = c;
+  else
+    eol_ungetc_lookahead = c;
+}
+
+#ifdef INCLUDE_UNUSED
+/* Back the input pointer up by one, effectively `ungetting' a character. */
+static void
+shell_ungetchar ()
+{
+  if (shell_input_line && shell_input_line_index)
+    shell_input_line_index--;
+}
+#endif
+
+/* Discard input until CHARACTER is seen, then push that character back
+   onto the input stream. */
+static void
+discard_until (character)
+     int character;
+{
+  int c;
+
+  while ((c = shell_getc (0)) != EOF && c != character)
+    ;
+
+  if (c != EOF)
+    shell_ungetc (c);
+}
+
+void
+execute_variable_command (command, vname)
+     char *command, *vname;
+{
+  char *last_lastarg;
+  sh_parser_state_t ps;
+
+  save_parser_state (&ps);
+  last_lastarg = get_string_value ("_");
+  if (last_lastarg)
+    last_lastarg = savestring (last_lastarg);
+
+  parse_and_execute (savestring (command), vname, SEVAL_NONINT|SEVAL_NOHIST);
+
+  restore_parser_state (&ps);
+  bind_variable ("_", last_lastarg, 0);
+  FREE (last_lastarg);
+
+  if (token_to_read == '\n')	/* reset_parser was called */
+    token_to_read = 0;
+}
+
+/* Place to remember the token.  We try to keep the buffer
+   at a reasonable size, but it can grow. */
+static char *token = (char *)NULL;
+
+/* Current size of the token buffer. */
+static int token_buffer_size;
+
+/* Command to read_token () explaining what we want it to do. */
+#define READ 0
+#define RESET 1
+#define prompt_is_ps1 \
+      (!prompt_string_pointer || prompt_string_pointer == &ps1_prompt)
+
+/* Function for yyparse to call.  yylex keeps track of
+   the last two tokens read, and calls read_token.  */
+static int
+yylex ()
+{
+  if (interactive && (current_token == 0 || current_token == '\n'))
+    {
+      /* Before we print a prompt, we might have to check mailboxes.
+	 We do this only if it is time to do so. Notice that only here
+	 is the mail alarm reset; nothing takes place in check_mail ()
+	 except the checking of mail.  Please don't change this. */
+      if (prompt_is_ps1 && time_to_check_mail ())
+	{
+	  check_mail ();
+	  reset_mail_timer ();
+	}
+
+      /* Avoid printing a prompt if we're not going to read anything, e.g.
+	 after resetting the parser with read_token (RESET). */
+      if (token_to_read == 0 && SHOULD_PROMPT ())
+	prompt_again ();
+    }
+
+  two_tokens_ago = token_before_that;
+  token_before_that = last_read_token;
+  last_read_token = current_token;
+  current_token = read_token (READ);
+
+  if ((parser_state & PST_EOFTOKEN) && current_token == shell_eof_token)
+    {
+      current_token = yacc_EOF;
+      if (bash_input.type == st_string)
+	rewind_input_string ();
+    }
+  parser_state &= ~PST_EOFTOKEN;
+
+  return (current_token);
+}
+
+/* When non-zero, we have read the required tokens
+   which allow ESAC to be the next one read. */
+static int esacs_needed_count;
+
+void
+gather_here_documents ()
+{
+  int r;
+
+  r = 0;
+  while (need_here_doc)
+    {
+      parser_state |= PST_HEREDOC;
+      make_here_document (redir_stack[r++], line_number);
+      parser_state &= ~PST_HEREDOC;
+      need_here_doc--;
+    }
+}
+
+/* When non-zero, an open-brace used to create a group is awaiting a close
+   brace partner. */
+static int open_brace_count;
+
+#define command_token_position(token) \
+  (((token) == ASSIGNMENT_WORD) || \
+   ((token) != SEMI_SEMI && (token) != SEMI_AND && (token) != SEMI_SEMI_AND && reserved_word_acceptable(token)))
+
+#define assignment_acceptable(token) \
+  (command_token_position(token) && ((parser_state & PST_CASEPAT) == 0))
+
+/* Check to see if TOKEN is a reserved word and return the token
+   value if it is. */
+#define CHECK_FOR_RESERVED_WORD(tok) \
+  do { \
+    if (!dollar_present && !quoted && \
+	reserved_word_acceptable (last_read_token)) \
+      { \
+	int i; \
+	for (i = 0; word_token_alist[i].word != (char *)NULL; i++) \
+	  if (STREQ (tok, word_token_alist[i].word)) \
+	    { \
+	      if ((parser_state & PST_CASEPAT) && (word_token_alist[i].token != ESAC)) \
+		break; \
+	      if (word_token_alist[i].token == TIME && time_command_acceptable () == 0) \
+		break; \
+	      if (word_token_alist[i].token == ESAC) \
+		parser_state &= ~(PST_CASEPAT|PST_CASESTMT); \
+	      else if (word_token_alist[i].token == CASE) \
+		parser_state |= PST_CASESTMT; \
+	      else if (word_token_alist[i].token == COND_END) \
+		parser_state &= ~(PST_CONDCMD|PST_CONDEXPR); \
+	      else if (word_token_alist[i].token == COND_START) \
+		parser_state |= PST_CONDCMD; \
+	      else if (word_token_alist[i].token == '{') \
+		open_brace_count++; \
+	      else if (word_token_alist[i].token == '}' && open_brace_count) \
+		open_brace_count--; \
+	      return (word_token_alist[i].token); \
+	    } \
+      } \
+  } while (0)
+
+#if defined (ALIAS)
+
+    /* OK, we have a token.  Let's try to alias expand it, if (and only if)
+       it's eligible.
+
+       It is eligible for expansion if EXPAND_ALIASES is set, and
+       the token is unquoted and the last token read was a command
+       separator (or expand_next_token is set), and we are currently
+       processing an alias (pushed_string_list is non-empty) and this
+       token is not the same as the current or any previously
+       processed alias.
+
+       Special cases that disqualify:
+	 In a pattern list in a case statement (parser_state & PST_CASEPAT). */
+
+static char *
+mk_alexpansion (s)
+     char *s;
+{
+  int l;
+  char *r;
+
+  l = strlen (s);
+  r = xmalloc (l + 2);
+  strcpy (r, s);
+  if (r[l -1] != ' ')
+    r[l++] = ' ';
+  r[l] = '\0';
+  return r;
+}
+
+static int
+alias_expand_token (tokstr)
+     char *tokstr;
+{
+  char *expanded;
+  alias_t *ap;
+
+  if (((parser_state & PST_ALEXPNEXT) || command_token_position (last_read_token)) &&
+	(parser_state & PST_CASEPAT) == 0)
+    {
+      ap = find_alias (tokstr);
+
+      /* Currently expanding this token. */
+      if (ap && (ap->flags & AL_BEINGEXPANDED))
+	return (NO_EXPANSION);
+
+      /* mk_alexpansion puts an extra space on the end of the alias expansion,
+         so the lookahead by the parser works right.  If this gets changed,
+         make sure the code in shell_getc that deals with reaching the end of
+         an expanded alias is changed with it. */
+      expanded = ap ? mk_alexpansion (ap->value) : (char *)NULL;
+
+      if (expanded)
+	{
+	  push_string (expanded, ap->flags & AL_EXPANDNEXT, ap);
+	  return (RE_READ_TOKEN);
+	}
+      else
+	/* This is an eligible token that does not have an expansion. */
+	return (NO_EXPANSION);
+    }
+  return (NO_EXPANSION);
+}
+#endif /* ALIAS */
+
+static int
+time_command_acceptable ()
+{
+#if defined (COMMAND_TIMING)
+  switch (last_read_token)
+    {
+    case 0:
+    case ';':
+    case '\n':
+    case AND_AND:
+    case OR_OR:
+    case '&':
+    case DO:
+    case THEN:
+    case ELSE:
+    case '{':		/* } */
+    case '(':		/* ) */
+      return 1;
+    default:
+      return 0;
+    }
+#else
+  return 0;
+#endif /* COMMAND_TIMING */
+}
+
+/* Handle special cases of token recognition:
+	IN is recognized if the last token was WORD and the token
+	before that was FOR or CASE or SELECT.
+
+	DO is recognized if the last token was WORD and the token
+	before that was FOR or SELECT.
+
+	ESAC is recognized if the last token caused `esacs_needed_count'
+	to be set
+
+	`{' is recognized if the last token as WORD and the token
+	before that was FUNCTION, or if we just parsed an arithmetic
+	`for' command.
+
+	`}' is recognized if there is an unclosed `{' present.
+
+	`-p' is returned as TIMEOPT if the last read token was TIME.
+
+	']]' is returned as COND_END if the parser is currently parsing
+	a conditional expression ((parser_state & PST_CONDEXPR) != 0)
+
+	`time' is returned as TIME if and only if it is immediately
+	preceded by one of `;', `\n', `||', `&&', or `&'.
+*/
+
+static int
+special_case_tokens (tokstr)
+     char *tokstr;
+{
+  if ((last_read_token == WORD) &&
+#if defined (SELECT_COMMAND)
+      ((token_before_that == FOR) || (token_before_that == CASE) || (token_before_that == SELECT)) &&
+#else
+      ((token_before_that == FOR) || (token_before_that == CASE)) &&
+#endif
+      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
+    {
+      if (token_before_that == CASE)
+	{
+	  parser_state |= PST_CASEPAT;
+	  esacs_needed_count++;
+	}
+      return (IN);
+    }
+
+  if (last_read_token == WORD &&
+#if defined (SELECT_COMMAND)
+      (token_before_that == FOR || token_before_that == SELECT) &&
+#else
+      (token_before_that == FOR) &&
+#endif
+      (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
+    return (DO);
+
+  /* Ditto for ESAC in the CASE case.
+     Specifically, this handles "case word in esac", which is a legal
+     construct, certainly because someone will pass an empty arg to the
+     case construct, and we don't want it to barf.  Of course, we should
+     insist that the case construct has at least one pattern in it, but
+     the designers disagree. */
+  if (esacs_needed_count)
+    {
+      esacs_needed_count--;
+      if (STREQ (tokstr, "esac"))
+	{
+	  parser_state &= ~PST_CASEPAT;
+	  return (ESAC);
+	}
+    }
+
+  /* The start of a shell function definition. */
+  if (parser_state & PST_ALLOWOPNBRC)
+    {
+      parser_state &= ~PST_ALLOWOPNBRC;
+      if (tokstr[0] == '{' && tokstr[1] == '\0')		/* } */
+	{
+	  open_brace_count++;
+	  function_bstart = line_number;
+	  return ('{');					/* } */
+	}
+    }
+
+  /* We allow a `do' after a for ((...)) without an intervening
+     list_terminator */
+  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == 'd' && tokstr[1] == 'o' && !tokstr[2])
+    return (DO);
+  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == '{' && tokstr[1] == '\0')	/* } */
+    {
+      open_brace_count++;
+      return ('{');			/* } */
+    }
+
+  if (open_brace_count && reserved_word_acceptable (last_read_token) && tokstr[0] == '}' && !tokstr[1])
+    {
+      open_brace_count--;		/* { */
+      return ('}');
+    }
+
+#if defined (COMMAND_TIMING)
+  /* Handle -p after `time'. */
+  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == 'p' && !tokstr[2])
+    return (TIMEOPT);
+#endif
+
+#if 0
+#if defined (COMMAND_TIMING)
+  if (STREQ (token, "time") && ((parser_state & PST_CASEPAT) == 0) && time_command_acceptable ())
+    return (TIME);
+#endif /* COMMAND_TIMING */
+#endif
+
+#if defined (COND_COMMAND) /* [[ */
+  if ((parser_state & PST_CONDEXPR) && tokstr[0] == ']' && tokstr[1] == ']' && tokstr[2] == '\0')
+    return (COND_END);
+#endif
+
+  return (-1);
+}
+
+/* Called from shell.c when Control-C is typed at top level.  Or
+   by the error rule at top level. */
+void
+reset_parser ()
+{
+  dstack.delimiter_depth = 0;	/* No delimiters found so far. */
+  open_brace_count = 0;
+
+  parser_state = 0;
+
+#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
+  if (pushed_string_list)
+    free_string_list ();
+#endif /* ALIAS || DPAREN_ARITHMETIC */
+
+  if (shell_input_line)
+    {
+      free (shell_input_line);
+      shell_input_line = (char *)NULL;
+      shell_input_line_size = shell_input_line_index = 0;
+    }
+
+  FREE (word_desc_to_read);
+  word_desc_to_read = (WORD_DESC *)NULL;
+
+  current_token = '\n';		/* XXX */
+  last_read_token = '\n';
+  token_to_read = '\n';
+}
+
+/* Read the next token.  Command can be READ (normal operation) or
+   RESET (to normalize state). */
+static int
+read_token (command)
+     int command;
+{
+  int character;		/* Current character. */
+  int peek_char;		/* Temporary look-ahead character. */
+  int result;			/* The thing to return. */
+
+  if (command == RESET)
+    {
+      reset_parser ();
+      return ('\n');
+    }
+
+  if (token_to_read)
+    {
+      result = token_to_read;
+      if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
+	{
+	  yylval.word = word_desc_to_read;
+	  word_desc_to_read = (WORD_DESC *)NULL;
+	}
+      token_to_read = 0;
+      return (result);
+    }
+
+#if defined (COND_COMMAND)
+  if ((parser_state & (PST_CONDCMD|PST_CONDEXPR)) == PST_CONDCMD)
+    {
+      cond_lineno = line_number;
+      parser_state |= PST_CONDEXPR;
+      yylval.command = parse_cond_command ();
+      if (cond_token != COND_END)
+	{
+	  cond_error ();
+	  return (-1);
+	}
+      token_to_read = COND_END;
+      parser_state &= ~(PST_CONDEXPR|PST_CONDCMD);
+      return (COND_CMD);
+    }
+#endif
+
+#if defined (ALIAS)
+  /* This is a place to jump back to once we have successfully expanded a
+     token with an alias and pushed the string with push_string () */
+ re_read_token:
+#endif /* ALIAS */
+
+  /* Read a single word from input.  Start by skipping blanks. */
+  while ((character = shell_getc (1)) != EOF && shellblank (character))
+    ;
+
+  if (character == EOF)
+    {
+      EOF_Reached = 1;
+      return (yacc_EOF);
+    }
+
+  if MBTEST(character == '#' && (!interactive || interactive_comments))
+    {
+      /* A comment.  Discard until EOL or EOF, and then return a newline. */
+      discard_until ('\n');
+      shell_getc (0);
+      character = '\n';	/* this will take the next if statement and return. */
+    }
+
+  if (character == '\n')
+    {
+      /* If we're about to return an unquoted newline, we can go and collect
+	 the text of any pending here document. */
+      if (need_here_doc)
+	gather_here_documents ();
+
+#if defined (ALIAS)
+      parser_state &= ~PST_ALEXPNEXT;
+#endif /* ALIAS */
+
+      parser_state &= ~PST_ASSIGNOK;
+
+      return (character);
+    }
+
+  if (parser_state & PST_REGEXP)
+    goto tokword;
+
+  /* Shell meta-characters. */
+  if MBTEST(shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
+    {
+#if defined (ALIAS)
+      /* Turn off alias tokenization iff this character sequence would
+	 not leave us ready to read a command. */
+      if (character == '<' || character == '>')
+	parser_state &= ~PST_ALEXPNEXT;
+#endif /* ALIAS */
+
+      parser_state &= ~PST_ASSIGNOK;
+
+      peek_char = shell_getc (1);
+      if (character == peek_char)
+	{
+	  switch (character)
+	    {
+	    case '<':
+	      /* If '<' then we could be at "<<" or at "<<-".  We have to
+		 look ahead one more character. */
+	      peek_char = shell_getc (1);
+	      if MBTEST(peek_char == '-')
+		return (LESS_LESS_MINUS);
+	      else if MBTEST(peek_char == '<')
+		return (LESS_LESS_LESS);
+	      else
+		{
+		  shell_ungetc (peek_char);
+		  return (LESS_LESS);
+		}
+
+	    case '>':
+	      return (GREATER_GREATER);
+
+	    case ';':
+	      parser_state |= PST_CASEPAT;
+#if defined (ALIAS)
+	      parser_state &= ~PST_ALEXPNEXT;
+#endif /* ALIAS */
+
+	      peek_char = shell_getc (1);
+	      if MBTEST(peek_char == '&')
+		return (SEMI_SEMI_AND);
+	      else
+		{
+		  shell_ungetc (peek_char);
+		  return (SEMI_SEMI);
+		}
+
+	    case '&':
+	      return (AND_AND);
+
+	    case '|':
+	      return (OR_OR);
+
+#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
+	    case '(':		/* ) */
+	      result = parse_dparen (character);
+	      if (result == -2)
+	        break;
+	      else
+	        return result;
+#endif
+	    }
+	}
+      else if MBTEST(character == '<' && peek_char == '&')
+	return (LESS_AND);
+      else if MBTEST(character == '>' && peek_char == '&')
+	return (GREATER_AND);
+      else if MBTEST(character == '<' && peek_char == '>')
+	return (LESS_GREATER);
+      else if MBTEST(character == '>' && peek_char == '|')
+	return (GREATER_BAR);
+      else if MBTEST(character == '&' && peek_char == '>')
+	{
+	  peek_char = shell_getc (1);
+	  if MBTEST(peek_char == '>')
+	    return (AND_GREATER_GREATER);
+	  else
+	    {
+	      shell_ungetc (peek_char);
+	      return (AND_GREATER);
+	    }
+	}
+      else if MBTEST(character == '|' && peek_char == '&')
+	return (BAR_AND);
+      else if MBTEST(character == ';' && peek_char == '&')
+	{
+	  parser_state |= PST_CASEPAT;
+#if defined (ALIAS)
+	  parser_state &= ~PST_ALEXPNEXT;
+#endif /* ALIAS */
+	  return (SEMI_AND);
+	}
+
+      shell_ungetc (peek_char);
+
+      /* If we look like we are reading the start of a function
+	 definition, then let the reader know about it so that
+	 we will do the right thing with `{'. */
+      if MBTEST(character == ')' && last_read_token == '(' && token_before_that == WORD)
+	{
+	  parser_state |= PST_ALLOWOPNBRC;
+#if defined (ALIAS)
+	  parser_state &= ~PST_ALEXPNEXT;
+#endif /* ALIAS */
+	  function_dstart = line_number;
+	}
+
+      /* case pattern lists may be preceded by an optional left paren.  If
+	 we're not trying to parse a case pattern list, the left paren
+	 indicates a subshell. */
+      if MBTEST(character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
+	parser_state |= PST_SUBSHELL;
+      /*(*/
+      else if MBTEST((parser_state & PST_CASEPAT) && character == ')')
+	parser_state &= ~PST_CASEPAT;
+      /*(*/
+      else if MBTEST((parser_state & PST_SUBSHELL) && character == ')')
+	parser_state &= ~PST_SUBSHELL;
+
+#if defined (PROCESS_SUBSTITUTION)
+      /* Check for the constructs which introduce process substitution.
+	 Shells running in `posix mode' don't do process substitution. */
+      if MBTEST(posixly_correct || ((character != '>' && character != '<') || peek_char != '(')) /*)*/
+#endif /* PROCESS_SUBSTITUTION */
+	return (character);
+    }
+
+  /* Hack <&- (close stdin) case.  Also <&N- (dup and close). */
+  if MBTEST(character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
+    return (character);
+
+tokword:
+  /* Okay, if we got this far, we have to read a word.  Read one,
+     and then check it against the known ones. */
+  result = read_token_word (character);
+#if defined (ALIAS)
+  if (result == RE_READ_TOKEN)
+    goto re_read_token;
+#endif
+  return result;
+}
+
+/*
+ * Match a $(...) or other grouping construct.  This has to handle embedded
+ * quoted strings ('', ``, "") and nested constructs.  It also must handle
+ * reprompting the user, if necessary, after reading a newline, and returning
+ * correct error values if it reads EOF.
+ */
+#define P_FIRSTCLOSE	0x01
+#define P_ALLOWESC	0x02
+#define P_DQUOTE	0x04
+#define P_COMMAND	0x08	/* parsing a command, so look for comments */
+#define P_BACKQUOTE	0x10	/* parsing a backquoted command substitution */
+#define P_ARRAYSUB	0x20	/* parsing a [...] array subscript for assignment */
+
+/* Lexical state while parsing a grouping construct or $(...). */
+#define LEX_WASDOL	0x001
+#define LEX_CKCOMMENT	0x002
+#define LEX_INCOMMENT	0x004
+#define LEX_PASSNEXT	0x008
+#define LEX_RESWDOK	0x010
+#define LEX_CKCASE	0x020
+#define LEX_INCASE	0x040
+#define LEX_INHEREDOC	0x080
+#define LEX_HEREDELIM	0x100		/* reading here-doc delimiter */
+#define LEX_STRIPDOC	0x200		/* <<- strip tabs from here doc delim */
+#define LEX_INWORD	0x400
+
+#define COMSUB_META(ch)		((ch) == ';' || (ch) == '&' || (ch) == '|')
+
+#define CHECK_NESTRET_ERROR() \
+  do { \
+    if (nestret == &matched_pair_error) \
+      { \
+	free (ret); \
+	return &matched_pair_error; \
+      } \
+  } while (0)
+
+#define APPEND_NESTRET() \
+  do { \
+    if (nestlen) \
+      { \
+	RESIZE_MALLOCED_BUFFER (ret, retind, nestlen, retsize, 64); \
+	strcpy (ret + retind, nestret); \
+	retind += nestlen; \
+      } \
+  } while (0)
+
+static char matched_pair_error;
+
+static char *
+parse_matched_pair (qc, open, close, lenp, flags)
+     int qc;	/* `"' if this construct is within double quotes */
+     int open, close;
+     int *lenp, flags;
+{
+  int count, ch, tflags;
+  int nestlen, ttranslen, start_lineno;
+  char *ret, *nestret, *ttrans;
+  int retind, retsize, rflags;
+
+/* itrace("parse_matched_pair: open = %c close = %c flags = %d", open, close, flags); */
+  count = 1;
+  tflags = 0;
+
+  if ((flags & P_COMMAND) && qc != '`' && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
+    tflags |= LEX_CKCOMMENT;
+
+  /* RFLAGS is the set of flags we want to pass to recursive calls. */
+  rflags = (qc == '"') ? P_DQUOTE : (flags & P_DQUOTE);
+
+  ret = (char *)xmalloc (retsize = 64);
+  retind = 0;
+
+  start_lineno = line_number;
+  while (count)
+    {
+      ch = shell_getc (qc != '\'' && (tflags & LEX_PASSNEXT) == 0);
+
+      if (ch == EOF)
+	{
+	  free (ret);
+	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
+	  EOF_Reached = 1;	/* XXX */
+	  return (&matched_pair_error);
+	}
+
+      /* Possible reprompting. */
+      if (ch == '\n' && SHOULD_PROMPT ())
+	prompt_again ();
+
+      /* Don't bother counting parens or doing anything else if in a comment
+	 or part of a case statement */
+      if (tflags & LEX_INCOMMENT)
+	{
+	  /* Add this character. */
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	  ret[retind++] = ch;
+
+	  if (ch == '\n')
+	    tflags &= ~LEX_INCOMMENT;
+
+	  continue;
+	}
+
+      /* Not exactly right yet, should handle shell metacharacters, too.  If
+	 any changes are made to this test, make analogous changes to subst.c:
+	 extract_delimited_string(). */
+      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || shellblank (ret[retind - 1])))
+	tflags |= LEX_INCOMMENT;
+
+      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
+	{
+	  tflags &= ~LEX_PASSNEXT;
+	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
+	    {
+	      if (retind > 0)
+		retind--;	/* swallow previously-added backslash */
+	      continue;
+	    }
+
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
+	  if MBTEST(ch == CTLESC || ch == CTLNUL)
+	    ret[retind++] = CTLESC;
+	  ret[retind++] = ch;
+	  continue;
+	}
+      /* If we're reparsing the input (e.g., from parse_string_to_word_list),
+	 we've already prepended CTLESC to single-quoted results of $'...'.
+	 We may want to do this for other CTLESC-quoted characters in
+	 reparse, too. */
+      else if MBTEST((parser_state & PST_REPARSE) && open == '\'' && (ch == CTLESC || ch == CTLNUL))
+	{
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	  ret[retind++] = ch;
+	  continue;
+	}
+      else if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+	{
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
+	  ret[retind++] = CTLESC;
+	  ret[retind++] = ch;
+	  continue;
+	}
+      else if MBTEST(ch == close)		/* ending delimiter */
+	count--;
+      /* handle nested ${...} specially. */
+      else if MBTEST(open != close && (tflags & LEX_WASDOL) && open == '{' && ch == open) /* } */
+	count++;
+      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && ch == open)	/* nested begin */
+	count++;
+
+      /* Add this character. */
+      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+      ret[retind++] = ch;
+
+      /* If we just read the ending character, don't bother continuing. */
+      if (count == 0)
+	break;
+
+      if (open == '\'')			/* '' inside grouping construct */
+	{
+	  if MBTEST((flags & P_ALLOWESC) && ch == '\\')
+	    tflags |= LEX_PASSNEXT;
+	  continue;
+	}
+
+      if MBTEST(ch == '\\')			/* backslashes */
+	tflags |= LEX_PASSNEXT;
+
+#if 0
+      /* The big hammer.  Single quotes aren't special in double quotes.  The
+         problem is that Posix says the single quotes are semi-special:
+         within a double-quoted ${...} construct "an even number of
+         unescaped double-quotes or single-quotes, if any, shall occur." */
+      if MBTEST(open == '{' && (flags & P_DQUOTE) && ch == '\'')	/* } */
+	continue;
+#endif
+
+      /* Could also check open == '`' if we want to parse grouping constructs
+	 inside old-style command substitution. */
+      if (open != close)		/* a grouping construct */
+	{
+	  if MBTEST(shellquote (ch))
+	    {
+	      /* '', ``, or "" inside $(...) or other grouping construct. */
+	      push_delimiter (dstack, ch);
+	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
+		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
+	      else
+		nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
+	      pop_delimiter (dstack);
+	      CHECK_NESTRET_ERROR ();
+
+	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
+		{
+		  /* Translate $'...' here. */
+		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
+		  xfree (nestret);
+
+		  if ((rflags & P_DQUOTE) == 0)
+		    {
+		      nestret = sh_single_quote (ttrans);
+		      free (ttrans);
+		      nestlen = strlen (nestret);
+		    }
+		  else
+		    {
+		      nestret = ttrans;
+		      nestlen = ttranslen;
+		    }
+		  retind -= 2;		/* back up before the $' */
+		}
+	      else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
+		{
+		  /* Locale expand $"..." here. */
+		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
+		  xfree (nestret);
+
+		  nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
+		  free (ttrans);
+		  nestlen = ttranslen + 2;
+		  retind -= 2;		/* back up before the $" */
+		}
+
+	      APPEND_NESTRET ();
+	      FREE (nestret);
+	    }
+	  else if ((flags & P_ARRAYSUB) && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
+	    goto parse_dollar_word;
+	}
+      /* Parse an old-style command substitution within double quotes as a
+	 single word. */
+      /* XXX - sh and ksh93 don't do this - XXX */
+      else if MBTEST(open == '"' && ch == '`')
+	{
+	  nestret = parse_matched_pair (0, '`', '`', &nestlen, rflags);
+
+	  CHECK_NESTRET_ERROR ();
+	  APPEND_NESTRET ();
+
+	  FREE (nestret);
+	}
+      else if MBTEST(open != '`' && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
+	/* check for $(), $[], or ${} inside quoted string. */
+	{
+parse_dollar_word:
+	  if (open == ch)	/* undo previous increment */
+	    count--;
+	  if (ch == '(')		/* ) */
+	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
+	  else if (ch == '{')		/* } */
+	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|rflags);
+	  else if (ch == '[')		/* ] */
+	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);
+
+	  CHECK_NESTRET_ERROR ();
+	  APPEND_NESTRET ();
+
+	  FREE (nestret);
+	}
+      if MBTEST(ch == '$')
+	tflags |= LEX_WASDOL;
+      else
+	tflags &= ~LEX_WASDOL;
+    }
+
+  ret[retind] = '\0';
+  if (lenp)
+    *lenp = retind;
+  return ret;
+}
+
+/* Parse a $(...) command substitution.  This is messier than I'd like, and
+   reproduces a lot more of the token-reading code than I'd like. */
+static char *
+parse_comsub (qc, open, close, lenp, flags)
+     int qc;	/* `"' if this construct is within double quotes */
+     int open, close;
+     int *lenp, flags;
+{
+  int count, ch, peekc, tflags, lex_rwlen, lex_wlen, lex_firstind;
+  int nestlen, ttranslen, start_lineno;
+  char *ret, *nestret, *ttrans, *heredelim;
+  int retind, retsize, rflags, hdlen;
+
+/*itrace("parse_comsub: qc = `%c' open = %c close = %c", qc, open, close);*/
+  count = 1;
+  tflags = LEX_RESWDOK;
+
+  if ((flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
+    tflags |= LEX_CKCASE;
+  if ((tflags & LEX_CKCASE) && (interactive == 0 || interactive_comments))
+    tflags |= LEX_CKCOMMENT;
+
+  /* RFLAGS is the set of flags we want to pass to recursive calls. */
+  rflags = (flags & P_DQUOTE);
+
+  ret = (char *)xmalloc (retsize = 64);
+  retind = 0;
+
+  start_lineno = line_number;
+  lex_rwlen = lex_wlen = 0;
+
+  heredelim = 0;
+  lex_firstind = -1;
+
+  while (count)
+    {
+comsub_readchar:
+      ch = shell_getc (qc != '\'' && (tflags & LEX_PASSNEXT) == 0);
+
+      if (ch == EOF)
+	{
+eof_error:
+	  free (ret);
+	  FREE (heredelim);
+	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
+	  EOF_Reached = 1;	/* XXX */
+	  return (&matched_pair_error);
+	}
+
+      /* If we hit the end of a line and are reading the contents of a here
+	 document, and it's not the same line that the document starts on,
+	 check for this line being the here doc delimiter.  Otherwise, if
+	 we're in a here document, mark the next character as the beginning
+	 of a line. */
+      if (ch == '\n')
+	{
+	  if ((tflags & LEX_HEREDELIM) && heredelim)
+	    {
+	      tflags &= ~LEX_HEREDELIM;
+	      tflags |= LEX_INHEREDOC;
+	      lex_firstind = retind + 1;
+	    }
+	  else if (tflags & LEX_INHEREDOC)
+	    {
+	      int tind;
+	      tind = lex_firstind;
+	      while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
+		tind++;
+	      if (STREQN (ret + tind, heredelim, hdlen))
+		{
+		  tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC);
+/*itrace("parse_comsub:%d: found here doc end `%s'", line_number, ret + tind);*/
+		  lex_firstind = -1;
+		}
+	      else
+		lex_firstind = retind + 1;
+	    }
+	}
+
+      /* Possible reprompting. */
+      if (ch == '\n' && SHOULD_PROMPT ())
+	prompt_again ();
+
+      /* Don't bother counting parens or doing anything else if in a comment */
+      if (tflags & (LEX_INCOMMENT|LEX_INHEREDOC))
+	{
+	  /* Add this character. */
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	  ret[retind++] = ch;
+
+	  if ((tflags & LEX_INCOMMENT) && ch == '\n')
+	    tflags &= ~LEX_INCOMMENT;
+
+	  continue;
+	}
+
+      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
+	{
+/*itrace("parse_comsub:%d: lex_passnext -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	  tflags &= ~LEX_PASSNEXT;
+	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
+	    {
+	      if (retind > 0)
+		retind--;	/* swallow previously-added backslash */
+	      continue;
+	    }
+
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
+	  if MBTEST(ch == CTLESC || ch == CTLNUL)
+	    ret[retind++] = CTLESC;
+	  ret[retind++] = ch;
+	  continue;
+	}
+
+      /* If this is a shell break character, we are not in a word.  If not,
+	 we either start or continue a word. */
+      if MBTEST(shellbreak (ch))
+	{
+	  tflags &= ~LEX_INWORD;
+/*itrace("parse_comsub:%d: lex_inword -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	}
+      else
+	{
+	  if (tflags & LEX_INWORD)
+	    {
+	      lex_wlen++;
+/*itrace("parse_comsub:%d: lex_inword == 1 ch = `%c' lex_wlen = %d (%d)", line_number, ch, lex_wlen, __LINE__);*/
+	    }
+	  else
+	    {
+/*itrace("parse_comsub:%d: lex_inword -> 1 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	      tflags |= LEX_INWORD;
+	      lex_wlen = 0;
+	    }
+	}
+
+      /* Skip whitespace */
+      if MBTEST(shellblank (ch) && lex_rwlen == 0)
+        {
+	  /* Add this character. */
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	  ret[retind++] = ch;
+	  continue;
+        }
+
+      /* Either we are looking for the start of the here-doc delimiter
+	 (lex_firstind == -1) or we are reading one (lex_firstind >= 0).
+	 If this character is a shell break character and we are reading
+	 the delimiter, save it and note that we are now reading a here
+	 document.  If we've found the start of the delimiter, note it by
+	 setting lex_firstind.  Backslashes can quote shell metacharacters
+	 in here-doc delimiters. */
+      if (tflags & LEX_HEREDELIM)
+	{
+	  if (lex_firstind == -1 && shellbreak (ch) == 0)
+	    lex_firstind = retind;
+	  else if (lex_firstind >= 0 && (tflags & LEX_PASSNEXT) == 0 && shellbreak (ch))
+	    {
+	      nestret = substring (ret, lex_firstind, retind);
+	      heredelim = string_quote_removal (nestret, 0);
+	      free (nestret);
+	      hdlen = STRLEN(heredelim);
+/*itrace("parse_comsub:%d: found here doc delimiter `%s' (%d)", line_number, heredelim, hdlen);*/
+	      if (ch == '\n')
+		{
+		  tflags |= LEX_INHEREDOC;
+		  tflags &= ~LEX_HEREDELIM;
+		  lex_firstind = retind + 1;
+		}
+	      else
+		lex_firstind = -1;
+	    }
+	}
+
+      /* Meta-characters that can introduce a reserved word.  Not perfect yet. */
+      if MBTEST((tflags & LEX_RESWDOK) == 0 && (tflags & LEX_CKCASE) && (tflags & LEX_INCOMMENT) == 0 && shellmeta(ch))
+	{
+	  /* Add this character. */
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	  ret[retind++] = ch;
+	  peekc = shell_getc (1);
+	  if (ch == peekc && (ch == '&' || ch == '|' || ch == ';'))	/* two-character tokens */
+	    {
+	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	      ret[retind++] = peekc;
+/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch); */
+	      tflags |= LEX_RESWDOK;
+	      lex_rwlen = 0;
+	      continue;
+	    }
+	  else if (ch == '\n' || COMSUB_META(ch))
+	    {
+	      shell_ungetc (peekc);
+	      tflags |= LEX_RESWDOK;
+/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
+	      lex_rwlen = 0;
+	      continue;
+	    }
+	  else if (ch == EOF)
+	    goto eof_error;
+	  else
+	    {
+	      /* `unget' the character we just added and fall through */
+	      retind--;
+	      shell_ungetc (peekc);
+	    }
+	}
+
+      /* If we can read a reserved word, try to read one. */
+      if (tflags & LEX_RESWDOK)
+	{
+	  if MBTEST(islower (ch))
+	    {
+	      /* Add this character. */
+	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	      ret[retind++] = ch;
+	      lex_rwlen++;
+	      continue;
+	    }
+	  else if MBTEST(lex_rwlen == 4 && shellbreak (ch))
+	    {
+	      if (STREQN (ret + retind - 4, "case", 4))
+{
+		tflags |= LEX_INCASE;
+/*itrace("parse_comsub:%d: found `case', lex_incase -> 1", line_number);*/
+}
+	      else if (STREQN (ret + retind - 4, "esac", 4))
+{
+		tflags &= ~LEX_INCASE;
+/*itrace("parse_comsub:%d: found `esac', lex_incase -> 0", line_number);*/
+}
+	      tflags &= ~LEX_RESWDOK;
+	    }
+	  else if MBTEST((tflags & LEX_CKCOMMENT) && ch == '#' && (lex_rwlen == 0 || ((tflags & LEX_INWORD) && lex_wlen == 0)))
+	    ;	/* don't modify LEX_RESWDOK if we're starting a comment */
+	  else if MBTEST((tflags & LEX_INCASE) && ch != '\n')
+	    /* If we can read a reserved word and we're in case, we're at the
+	       point where we can read a new pattern list or an esac.  We
+	       handle the esac case above.  If we read a newline, we want to
+	       leave LEX_RESWDOK alone.  If we read anything else, we want to
+	       turn off LEX_RESWDOK, since we're going to read a pattern list. */
+{
+	    tflags &= ~LEX_RESWDOK;
+/*itrace("parse_comsub:%d: lex_incase == 1 found `%c', lex_reswordok -> 0", line_number, ch);*/
+}
+	  else if MBTEST(shellbreak (ch) == 0)
+{
+	    tflags &= ~LEX_RESWDOK;
+/*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
+}
+	}
+
+      if MBTEST((tflags & LEX_INCOMMENT) == 0 && (tflags & LEX_CKCASE) && ch == '<')
+	{
+	  /* Add this character. */
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	  ret[retind++] = ch;
+	  peekc = shell_getc (1);
+	  if (peekc == EOF)
+	    goto eof_error;
+	  if (peekc == ch)
+	    {
+	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+	      ret[retind++] = peekc;
+	      peekc = shell_getc (1);
+	      if (peekc == EOF)
+		goto eof_error;
+	      if (peekc == '-')
+		{
+		  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+		  ret[retind++] = peekc;
+		  tflags |= LEX_STRIPDOC;
+		}
+	      else
+		shell_ungetc (peekc);
+	      if (peekc != '<')
+		{
+		  tflags |= LEX_HEREDELIM;
+		  lex_firstind = -1;
+		}
+	      continue;
+	    }
+	  else
+	    ch = peekc;		/* fall through and continue XXX */
+	}
+      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (((tflags & LEX_RESWDOK) && lex_rwlen == 0) || ((tflags & LEX_INWORD) && lex_wlen == 0)))
+{
+/*itrace("parse_comsub:%d: lex_incomment -> 1 (%d)", line_number, __LINE__);*/
+	tflags |= LEX_INCOMMENT;
+}
+
+      if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+	{
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
+	  ret[retind++] = CTLESC;
+	  ret[retind++] = ch;
+	  continue;
+	}
+#if 0
+      else if MBTEST((tflags & LEX_INCASE) && ch == close && close == ')')
+        tflags &= ~LEX_INCASE;		/* XXX */
+#endif
+      else if MBTEST(ch == close && (tflags & LEX_INCASE) == 0)		/* ending delimiter */
+{
+	count--;
+/*itrace("parse_comsub:%d: found close: count = %d", line_number, count);*/
+}
+      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && (tflags & LEX_INCASE) == 0 && ch == open)	/* nested begin */
+	count++;
+
+      /* Add this character. */
+      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
+      ret[retind++] = ch;
+
+      /* If we just read the ending character, don't bother continuing. */
+      if (count == 0)
+	break;
+
+      if MBTEST(ch == '\\')			/* backslashes */
+	tflags |= LEX_PASSNEXT;
+
+      if MBTEST(shellquote (ch))
+        {
+          /* '', ``, or "" inside $(...). */
+          push_delimiter (dstack, ch);
+          if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
+	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
+	  else
+	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
+	  pop_delimiter (dstack);
+	  CHECK_NESTRET_ERROR ();
+
+	  if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
+	    {
+	      /* Translate $'...' here. */
+	      ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
+	      xfree (nestret);
+
+	      if ((rflags & P_DQUOTE) == 0)
+		{
+		  nestret = sh_single_quote (ttrans);
+		  free (ttrans);
+		  nestlen = strlen (nestret);
+		}
+	      else
+		{
+		  nestret = ttrans;
+		  nestlen = ttranslen;
+		}
+	      retind -= 2;		/* back up before the $' */
+	    }
+	  else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
+	    {
+	      /* Locale expand $"..." here. */
+	      ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
+	      xfree (nestret);
+
+	      nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
+	      free (ttrans);
+	      nestlen = ttranslen + 2;
+	      retind -= 2;		/* back up before the $" */
+	    }
+
+	  APPEND_NESTRET ();
+	  FREE (nestret);
+	}
+      else if MBTEST((tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
+	/* check for $(), $[], or ${} inside command substitution. */
+	{
+	  if ((tflags & LEX_INCASE) == 0 && open == ch)	/* undo previous increment */
+	    count--;
+	  if (ch == '(')		/* ) */
+	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
+	  else if (ch == '{')		/* } */
+	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|rflags);
+	  else if (ch == '[')		/* ] */
+	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);
+
+	  CHECK_NESTRET_ERROR ();
+	  APPEND_NESTRET ();
+
+	  FREE (nestret);
+	}
+      if MBTEST(ch == '$')
+	tflags |= LEX_WASDOL;
+      else
+	tflags &= ~LEX_WASDOL;
+    }
+
+  FREE (heredelim);
+  ret[retind] = '\0';
+  if (lenp)
+    *lenp = retind;
+/*itrace("parse_comsub:%d: returning `%s'", line_number, ret);*/
+  return ret;
+}
+
+/* XXX - this needs to handle functionality like subst.c:no_longjmp_on_fatal_error;
+   maybe extract_command_subst should handle it. */
+char *
+xparse_dolparen (base, string, indp, flags)
+     char *base;
+     char *string;
+     int *indp;
+     int flags;
+{
+  sh_parser_state_t ps;
+  int orig_ind, nc, sflags;
+  char *ret, *s, *ep, *ostring;
+
+  /*yydebug = 1;*/
+  orig_ind = *indp;
+  ostring = string;
+
+  sflags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOFREE;
+  if (flags & SX_NOLONGJMP)
+    sflags |= SEVAL_NOLONGJMP;
+  save_parser_state (&ps);
+
+  /*(*/
+  parser_state |= PST_CMDSUBST|PST_EOFTOKEN;	/* allow instant ')' */ /*(*/
+  shell_eof_token = ')';
+  parse_string (string, "command substitution", sflags, &ep);
+
+  restore_parser_state (&ps);
+  reset_parser ();
+  if (interactive)
+    token_to_read = 0;
+
+  /* Need to find how many characters parse_and_execute consumed, update
+     *indp, if flags != 0, copy the portion of the string parsed into RET
+     and return it.  If flags & 1 (EX_NOALLOC) we can return NULL. */
+
+  /*(*/
+  if (ep[-1] != ')')
+    {
+#if DEBUG
+      if (ep[-1] != '\n')
+	itrace("xparse_dolparen:%d: ep[-1] != RPAREN (%d), ep = `%s'", line_number, ep[-1], ep);
+#endif
+      while (ep > ostring && ep[-1] == '\n') ep--;
+    }
+
+  nc = ep - ostring;
+  *indp = ep - base - 1;
+
+  /*(*/
+#if DEBUG
+  if (base[*indp] != ')')
+    itrace("xparse_dolparen:%d: base[%d] != RPAREN (%d), base = `%s'", line_number, *indp, base[*indp], base);
+#endif
+
+  if (flags & SX_NOALLOC)
+    return (char *)NULL;
+
+  if (nc == 0)
+    {
+      ret = xmalloc (1);
+      ret[0] = '\0';
+    }
+  else
+    ret = substring (ostring, 0, nc - 1);
+
+  return ret;
+}
+
+#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
+/* Parse a double-paren construct.  It can be either an arithmetic
+   command, an arithmetic `for' command, or a nested subshell.  Returns
+   the parsed token, -1 on error, or -2 if we didn't do anything and
+   should just go on. */
+static int
+parse_dparen (c)
+     int c;
+{
+  int cmdtyp, sline;
+  char *wval;
+  WORD_DESC *wd;
+
+#if defined (ARITH_FOR_COMMAND)
+  if (last_read_token == FOR)
+    {
+      arith_for_lineno = line_number;
+      cmdtyp = parse_arith_cmd (&wval, 0);
+      if (cmdtyp == 1)
+	{
+	  wd = alloc_word_desc ();
+	  wd->word = wval;
+	  yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);
+	  return (ARITH_FOR_EXPRS);
+	}
+      else
+	return -1;		/* ERROR */
+    }
+#endif
+
+#if defined (DPAREN_ARITHMETIC)
+  if (reserved_word_acceptable (last_read_token))
+    {
+      sline = line_number;
+
+      cmdtyp = parse_arith_cmd (&wval, 0);
+      if (cmdtyp == 1)	/* arithmetic command */
+	{
+	  wd = alloc_word_desc ();
+	  wd->word = wval;
+	  wd->flags = W_QUOTED|W_NOSPLIT|W_NOGLOB|W_DQUOTE;
+	  yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);
+	  return (ARITH_CMD);
+	}
+      else if (cmdtyp == 0)	/* nested subshell */
+	{
+	  push_string (wval, 0, (alias_t *)NULL);
+	  if ((parser_state & PST_CASEPAT) == 0)
+	    parser_state |= PST_SUBSHELL;
+	  return (c);
+	}
+      else			/* ERROR */
+	return -1;
+    }
+#endif
+
+  return -2;			/* XXX */
+}
+
+/* We've seen a `(('.  Look for the matching `))'.  If we get it, return 1.
+   If not, assume it's a nested subshell for backwards compatibility and
+   return 0.  In any case, put the characters we've consumed into a locally-
+   allocated buffer and make *ep point to that buffer.  Return -1 on an
+   error, for example EOF. */
+static int
+parse_arith_cmd (ep, adddq)
+     char **ep;
+     int adddq;
+{
+  int exp_lineno, rval, c;
+  char *ttok, *tokstr;
+  int ttoklen;
+
+  exp_lineno = line_number;
+  ttok = parse_matched_pair (0, '(', ')', &ttoklen, 0);
+  rval = 1;
+  if (ttok == &matched_pair_error)
+    return -1;
+  /* Check that the next character is the closing right paren.  If
+     not, this is a syntax error. ( */
+  c = shell_getc (0);
+  if MBTEST(c != ')')
+    rval = 0;
+
+  tokstr = (char *)xmalloc (ttoklen + 4);
+
+  /* if ADDDQ != 0 then (( ... )) -> "..." */
+  if (rval == 1 && adddq)	/* arith cmd, add double quotes */
+    {
+      tokstr[0] = '"';
+      strncpy (tokstr + 1, ttok, ttoklen - 1);
+      tokstr[ttoklen] = '"';
+      tokstr[ttoklen+1] = '\0';
+    }
+  else if (rval == 1)		/* arith cmd, don't add double quotes */
+    {
+      strncpy (tokstr, ttok, ttoklen - 1);
+      tokstr[ttoklen-1] = '\0';
+    }
+  else				/* nested subshell */
+    {
+      tokstr[0] = '(';
+      strncpy (tokstr + 1, ttok, ttoklen - 1);
+      tokstr[ttoklen] = ')';
+      tokstr[ttoklen+1] = c;
+      tokstr[ttoklen+2] = '\0';
+    }
+
+  *ep = tokstr;
+  FREE (ttok);
+  return rval;
+}
+#endif /* DPAREN_ARITHMETIC || ARITH_FOR_COMMAND */
+
+#if defined (COND_COMMAND)
+static void
+cond_error ()
+{
+  char *etext;
+
+  if (EOF_Reached && cond_token != COND_ERROR)		/* [[ */
+    parser_error (cond_lineno, _("unexpected EOF while looking for `]]'"));
+  else if (cond_token != COND_ERROR)
+    {
+      if (etext = error_token_from_token (cond_token))
+	{
+	  parser_error (cond_lineno, _("syntax error in conditional expression: unexpected token `%s'"), etext);
+	  free (etext);
+	}
+      else
+	parser_error (cond_lineno, _("syntax error in conditional expression"));
+    }
+}
+
+static COND_COM *
+cond_expr ()
+{
+  return (cond_or ());
+}
+
+static COND_COM *
+cond_or ()
+{
+  COND_COM *l, *r;
+
+  l = cond_and ();
+  if (cond_token == OR_OR)
+    {
+      r = cond_or ();
+      l = make_cond_node (COND_OR, (WORD_DESC *)NULL, l, r);
+    }
+  return l;
+}
+
+static COND_COM *
+cond_and ()
+{
+  COND_COM *l, *r;
+
+  l = cond_term ();
+  if (cond_token == AND_AND)
+    {
+      r = cond_and ();
+      l = make_cond_node (COND_AND, (WORD_DESC *)NULL, l, r);
+    }
+  return l;
+}
+
+static int
+cond_skip_newlines ()
+{
+  while ((cond_token = read_token (READ)) == '\n')
+    {
+      if (SHOULD_PROMPT ())
+	prompt_again ();
+    }
+  return (cond_token);
+}
+
+#define COND_RETURN_ERROR() \
+  do { cond_token = COND_ERROR; return ((COND_COM *)NULL); } while (0)
+
+static COND_COM *
+cond_term ()
+{
+  WORD_DESC *op;
+  COND_COM *term, *tleft, *tright;
+  int tok, lineno;
+  char *etext;
+
+  /* Read a token.  It can be a left paren, a `!', a unary operator, or a
+     word that should be the first argument of a binary operator.  Start by
+     skipping newlines, since this is a compound command. */
+  tok = cond_skip_newlines ();
+  lineno = line_number;
+  if (tok == COND_END)
+    {
+      COND_RETURN_ERROR ();
+    }
+  else if (tok == '(')
+    {
+      term = cond_expr ();
+      if (cond_token != ')')
+	{
+	  if (term)
+	    dispose_cond_node (term);		/* ( */
+	  if (etext = error_token_from_token (cond_token))
+	    {
+	      parser_error (lineno, _("unexpected token `%s', expected `)'"), etext);
+	      free (etext);
+	    }
+	  else
+	    parser_error (lineno, _("expected `)'"));
+	  COND_RETURN_ERROR ();
+	}
+      term = make_cond_node (COND_EXPR, (WORD_DESC *)NULL, term, (COND_COM *)NULL);
+      (void)cond_skip_newlines ();
+    }
+  else if (tok == BANG || (tok == WORD && (yylval.word->word[0] == '!' && yylval.word->word[1] == '\0')))
+    {
+      if (tok == WORD)
+	dispose_word (yylval.word);	/* not needed */
+      term = cond_term ();
+      if (term)
+	term->flags |= CMD_INVERT_RETURN;
+    }
+  else if (tok == WORD && yylval.word->word[0] == '-' && yylval.word->word[2] == 0 && test_unop (yylval.word->word))
+    {
+      op = yylval.word;
+      tok = read_token (READ);
+      if (tok == WORD)
+	{
+	  tleft = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
+	  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);
+	}
+      else
+	{
+	  dispose_word (op);
+	  if (etext = error_token_from_token (tok))
+	    {
+	      parser_error (line_number, _("unexpected argument `%s' to conditional unary operator"), etext);
+	      free (etext);
+	    }
+	  else
+	    parser_error (line_number, _("unexpected argument to conditional unary operator"));
+	  COND_RETURN_ERROR ();
+	}
+
+      (void)cond_skip_newlines ();
+    }
+  else if (tok == WORD)		/* left argument to binary operator */
+    {
+      /* lhs */
+      tleft = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
+
+      /* binop */
+      tok = read_token (READ);
+      if (tok == WORD && test_binop (yylval.word->word))
+	op = yylval.word;
+#if defined (COND_REGEXP)
+      else if (tok == WORD && STREQ (yylval.word->word, "=~"))
+	{
+	  op = yylval.word;
+	  parser_state |= PST_REGEXP;
+	}
+#endif
+      else if (tok == '<' || tok == '>')
+	op = make_word_from_token (tok);  /* ( */
+      /* There should be a check before blindly accepting the `)' that we have
+	 seen the opening `('. */
+      else if (tok == COND_END || tok == AND_AND || tok == OR_OR || tok == ')')
+	{
+	  /* Special case.  [[ x ]] is equivalent to [[ -n x ]], just like
+	     the test command.  Similarly for [[ x && expr ]] or
+	     [[ x || expr ]] or [[ (x) ]]. */
+	  op = make_word ("-n");
+	  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);
+	  cond_token = tok;
+	  return (term);
+	}
+      else
+	{
+	  if (etext = error_token_from_token (tok))
+	    {
+	      parser_error (line_number, _("unexpected token `%s', conditional binary operator expected"), etext);
+	      free (etext);
+	    }
+	  else
+	    parser_error (line_number, _("conditional binary operator expected"));
+	  dispose_cond_node (tleft);
+	  COND_RETURN_ERROR ();
+	}
+
+      /* rhs */
+      tok = read_token (READ);
+      parser_state &= ~PST_REGEXP;
+      if (tok == WORD)
+	{
+	  tright = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);
+	  term = make_cond_node (COND_BINARY, op, tleft, tright);
+	}
+      else
+	{
+	  if (etext = error_token_from_token (tok))
+	    {
+	      parser_error (line_number, _("unexpected argument `%s' to conditional binary operator"), etext);
+	      free (etext);
+	    }
+	  else
+	    parser_error (line_number, _("unexpected argument to conditional binary operator"));
+	  dispose_cond_node (tleft);
+	  dispose_word (op);
+	  COND_RETURN_ERROR ();
+	}
+
+      (void)cond_skip_newlines ();
+    }
+  else
+    {
+      if (tok < 256)
+	parser_error (line_number, _("unexpected token `%c' in conditional command"), tok);
+      else if (etext = error_token_from_token (tok))
+	{
+	  parser_error (line_number, _("unexpected token `%s' in conditional command"), etext);
+	  free (etext);
+	}
+      else
+	parser_error (line_number, _("unexpected token %d in conditional command"), tok);
+      COND_RETURN_ERROR ();
+    }
+  return (term);
+}
+
+/* This is kind of bogus -- we slip a mini recursive-descent parser in
+   here to handle the conditional statement syntax. */
+static COMMAND *
+parse_cond_command ()
+{
+  COND_COM *cexp;
+
+  cexp = cond_expr ();
+  return (make_cond_command (cexp));
+}
+#endif
+
+#if defined (ARRAY_VARS)
+/* When this is called, it's guaranteed that we don't care about anything
+   in t beyond i.  We do save and restore the chars, though. */
+static int
+token_is_assignment (t, i)
+     char *t;
+     int i;
+{
+  unsigned char c, c1;
+  int r;
+
+  c = t[i]; c1 = t[i+1];
+  t[i] = '='; t[i+1] = '\0';
+  r = assignment (t, (parser_state & PST_COMPASSIGN) != 0);
+  t[i] = c; t[i+1] = c1;
+  return r;
+}
+
+/* XXX - possible changes here for `+=' */
+static int
+token_is_ident (t, i)
+     char *t;
+     int i;
+{
+  unsigned char c;
+  int r;
+
+  c = t[i];
+  t[i] = '\0';
+  r = legal_identifier (t);
+  t[i] = c;
+  return r;
+}
+#endif
+
+static int
+read_token_word (character)
+     int character;
+{
+  /* The value for YYLVAL when a WORD is read. */
+  WORD_DESC *the_word;
+
+  /* Index into the token that we are building. */
+  int token_index;
+
+  /* ALL_DIGITS becomes zero when we see a non-digit. */
+  int all_digit_token;
+
+  /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
+  int dollar_present;
+
+  /* COMPOUND_ASSIGNMENT becomes non-zero if we are parsing a compound
+     assignment. */
+  int compound_assignment;
+
+  /* QUOTED becomes non-zero if we see one of ("), ('), (`), or (\). */
+  int quoted;
+
+  /* Non-zero means to ignore the value of the next character, and just
+     to add it no matter what. */
+ int pass_next_character;
+
+  /* The current delimiting character. */
+  int cd;
+  int result, peek_char;
+  char *ttok, *ttrans;
+  int ttoklen, ttranslen;
+  intmax_t lvalue;
+
+  if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
+    token = (char *)xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);
+
+  token_index = 0;
+  all_digit_token = DIGIT (character);
+  dollar_present = quoted = pass_next_character = compound_assignment = 0;
+
+  for (;;)
+    {
+      if (character == EOF)
+	goto got_token;
+
+      if (pass_next_character)
+	{
+	  pass_next_character = 0;
+	  goto got_escaped_character;
+	}
+
+      cd = current_delimiter (dstack);
+
+      /* Handle backslashes.  Quote lots of things when not inside of
+	 double-quotes, quote some things inside of double-quotes. */
+      if MBTEST(character == '\\')
+	{
+	  peek_char = shell_getc (0);
+
+	  /* Backslash-newline is ignored in all cases except
+	     when quoted with single quotes. */
+	  if (peek_char == '\n')
+	    {
+	      character = '\n';
+	      goto next_character;
+	    }
+	  else
+	    {
+	      shell_ungetc (peek_char);
+
+	      /* If the next character is to be quoted, note it now. */
+	      if (cd == 0 || cd == '`' ||
+		  (cd == '"' && peek_char >= 0 && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
+		pass_next_character++;
+
+	      quoted = 1;
+	      goto got_character;
+	    }
+	}
+
+      /* Parse a matched pair of quote characters. */
+      if MBTEST(shellquote (character))
+	{
+	  push_delimiter (dstack, character);
+	  ttok = parse_matched_pair (character, character, character, &ttoklen, (character == '`') ? P_COMMAND : 0);
+	  pop_delimiter (dstack);
+	  if (ttok == &matched_pair_error)
+	    return -1;		/* Bail immediately. */
+	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
+				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
+	  token[token_index++] = character;
+	  strcpy (token + token_index, ttok);
+	  token_index += ttoklen;
+	  all_digit_token = 0;
+	  quoted = 1;
+	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
+	  FREE (ttok);
+	  goto next_character;
+	}
+
+#ifdef COND_REGEXP
+      /* When parsing a regexp as a single word inside a conditional command,
+	 we need to special-case characters special to both the shell and
+	 regular expressions.  Right now, that is only '(' and '|'. */ /*)*/
+      if MBTEST((parser_state & PST_REGEXP) && (character == '(' || character == '|'))		/*)*/
+	{
+	  if (character == '|')
+	    goto got_character;
+
+	  push_delimiter (dstack, character);
+	  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
+	  pop_delimiter (dstack);
+	  if (ttok == &matched_pair_error)
+	    return -1;		/* Bail immediately. */
+	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
+				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
+	  token[token_index++] = character;
+	  strcpy (token + token_index, ttok);
+	  token_index += ttoklen;
+	  FREE (ttok);
+	  dollar_present = all_digit_token = 0;
+	  goto next_character;
+	}
+#endif /* COND_REGEXP */
+
+#ifdef EXTENDED_GLOB
+      /* Parse a ksh-style extended pattern matching specification. */
+      if MBTEST(extended_glob && PATTERN_CHAR (character))
+	{
+	  peek_char = shell_getc (1);
+	  if MBTEST(peek_char == '(')		/* ) */
+	    {
+	      push_delimiter (dstack, peek_char);
+	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
+	      pop_delimiter (dstack);
+	      if (ttok == &matched_pair_error)
+		return -1;		/* Bail immediately. */
+	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
+				      token_buffer_size,
+				      TOKEN_DEFAULT_GROW_SIZE);
+	      token[token_index++] = character;
+	      token[token_index++] = peek_char;
+	      strcpy (token + token_index, ttok);
+	      token_index += ttoklen;
+	      FREE (ttok);
+	      dollar_present = all_digit_token = 0;
+	      goto next_character;
+	    }
+	  else
+	    shell_ungetc (peek_char);
+	}
+#endif /* EXTENDED_GLOB */
+
+      /* If the delimiter character is not single quote, parse some of
+	 the shell expansions that must be read as a single word. */
+      if (shellexp (character))
+	{
+	  peek_char = shell_getc (1);
+	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
+	  if MBTEST(peek_char == '(' || \
+		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
+	    {
+	      if (peek_char == '{')		/* } */
+		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE);
+	      else if (peek_char == '(')		/* ) */
+		{
+		  /* XXX - push and pop the `(' as a delimiter for use by
+		     the command-oriented-history code.  This way newlines
+		     appearing in the $(...) string get added to the
+		     history literally rather than causing a possibly-
+		     incorrect `;' to be added. ) */
+		  push_delimiter (dstack, peek_char);
+		  ttok = parse_comsub (cd, '(', ')', &ttoklen, P_COMMAND);
+		  pop_delimiter (dstack);
+		}
+	      else
+		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
+	      if (ttok == &matched_pair_error)
+		return -1;		/* Bail immediately. */
+	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
+				      token_buffer_size,
+				      TOKEN_DEFAULT_GROW_SIZE);
+	      token[token_index++] = character;
+	      token[token_index++] = peek_char;
+	      strcpy (token + token_index, ttok);
+	      token_index += ttoklen;
+	      FREE (ttok);
+	      dollar_present = 1;
+	      all_digit_token = 0;
+	      goto next_character;
+	    }
+	  /* This handles $'...' and $"..." new-style quoted strings. */
+	  else if MBTEST(character == '$' && (peek_char == '\'' || peek_char == '"'))
+	    {
+	      int first_line;
+
+	      first_line = line_number;
+	      push_delimiter (dstack, peek_char);
+	      ttok = parse_matched_pair (peek_char, peek_char, peek_char,
+					 &ttoklen,
+					 (peek_char == '\'') ? P_ALLOWESC : 0);
+	      pop_delimiter (dstack);
+	      if (ttok == &matched_pair_error)
+		return -1;
+	      if (peek_char == '\'')
+		{
+		  ttrans = ansiexpand (ttok, 0, ttoklen - 1, &ttranslen);
+		  free (ttok);
+
+		  /* Insert the single quotes and correctly quote any
+		     embedded single quotes (allowed because P_ALLOWESC was
+		     passed to parse_matched_pair). */
+		  ttok = sh_single_quote (ttrans);
+		  free (ttrans);
+		  ttranslen = strlen (ttok);
+		  ttrans = ttok;
+		}
+	      else
+		{
+		  /* Try to locale-expand the converted string. */
+		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
+		  free (ttok);
+
+		  /* Add the double quotes back */
+		  ttok = sh_mkdoublequoted (ttrans, ttranslen, 0);
+		  free (ttrans);
+		  ttranslen += 2;
+		  ttrans = ttok;
+		}
+
+	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 2,
+				      token_buffer_size,
+				      TOKEN_DEFAULT_GROW_SIZE);
+	      strcpy (token + token_index, ttrans);
+	      token_index += ttranslen;
+	      FREE (ttrans);
+	      quoted = 1;
+	      all_digit_token = 0;
+	      goto next_character;
+	    }
+	  /* This could eventually be extended to recognize all of the
+	     shell's single-character parameter expansions, and set flags.*/
+	  else if MBTEST(character == '$' && peek_char == '$')
+	    {
+	      ttok = (char *)xmalloc (3);
+	      ttok[0] = ttok[1] = '$';
+	      ttok[2] = '\0';
+	      RESIZE_MALLOCED_BUFFER (token, token_index, 3,
+				      token_buffer_size,
+				      TOKEN_DEFAULT_GROW_SIZE);
+	      strcpy (token + token_index, ttok);
+	      token_index += 2;
+	      dollar_present = 1;
+	      all_digit_token = 0;
+	      FREE (ttok);
+	      goto next_character;
+	    }
+	  else
+	    shell_ungetc (peek_char);
+	}
+
+#if defined (ARRAY_VARS)
+      /* Identify possible array subscript assignment; match [...].  If
+	 parser_state&PST_COMPASSIGN, we need to parse [sub]=words treating
+	 `sub' as if it were enclosed in double quotes. */
+      else if MBTEST(character == '[' &&		/* ] */
+		     ((token_index > 0 && assignment_acceptable (last_read_token) && token_is_ident (token, token_index)) ||
+		      (token_index == 0 && (parser_state&PST_COMPASSIGN))))
+        {
+	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARRAYSUB);
+	  if (ttok == &matched_pair_error)
+	    return -1;		/* Bail immediately. */
+	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
+				  token_buffer_size,
+				  TOKEN_DEFAULT_GROW_SIZE);
+	  token[token_index++] = character;
+	  strcpy (token + token_index, ttok);
+	  token_index += ttoklen;
+	  FREE (ttok);
+	  all_digit_token = 0;
+	  goto next_character;
+        }
+      /* Identify possible compound array variable assignment. */
+      else if MBTEST(character == '=' && token_index > 0 && (assignment_acceptable (last_read_token) || (parser_state & PST_ASSIGNOK)) && token_is_assignment (token, token_index))
+	{
+	  peek_char = shell_getc (1);
+	  if MBTEST(peek_char == '(')		/* ) */
+	    {
+	      ttok = parse_compound_assignment (&ttoklen);
+
+	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 4,
+				      token_buffer_size,
+				      TOKEN_DEFAULT_GROW_SIZE);
+
+	      token[token_index++] = '=';
+	      token[token_index++] = '(';
+	      if (ttok)
+		{
+		  strcpy (token + token_index, ttok);
+		  token_index += ttoklen;
+		}
+	      token[token_index++] = ')';
+	      FREE (ttok);
+	      all_digit_token = 0;
+	      compound_assignment = 1;
+#if 1
+	      goto next_character;
+#else
+	      goto got_token;		/* ksh93 seems to do this */
+#endif
+	    }
+	  else
+	    shell_ungetc (peek_char);
+	}
+#endif
+
+      /* When not parsing a multi-character word construct, shell meta-
+	 characters break words. */
+      if MBTEST(shellbreak (character))
+	{
+	  shell_ungetc (character);
+	  goto got_token;
+	}
+
+    got_character:
+
+      if (character == CTLESC || character == CTLNUL)
+	token[token_index++] = CTLESC;
+
+    got_escaped_character:
+
+      all_digit_token &= DIGIT (character);
+      dollar_present |= character == '$';
+
+      token[token_index++] = character;
+
+      RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
+			      TOKEN_DEFAULT_GROW_SIZE);
+
+    next_character:
+      if (character == '\n' && SHOULD_PROMPT ())
+	prompt_again ();
+
+      /* We want to remove quoted newlines (that is, a \<newline> pair)
+	 unless we are within single quotes or pass_next_character is
+	 set (the shell equivalent of literal-next). */
+      cd = current_delimiter (dstack);
+      character = shell_getc (cd != '\'' && pass_next_character == 0);
+    }	/* end for (;;) */
+
+got_token:
+
+  token[token_index] = '\0';
+
+  /* Check to see what thing we should return.  If the last_read_token
+     is a `<', or a `&', or the character which ended this token is
+     a '>' or '<', then, and ONLY then, is this input token a NUMBER.
+     Otherwise, it is just a word, and should be returned as such. */
+  if MBTEST(all_digit_token && (character == '<' || character == '>' || \
+		    last_read_token == LESS_AND || \
+		    last_read_token == GREATER_AND))
+      {
+	if (legal_number (token, &lvalue) && (int)lvalue == lvalue)
+	  yylval.number = lvalue;
+	else
+	  yylval.number = -1;
+	return (NUMBER);
+      }
+
+  /* Check for special case tokens. */
+  result = (last_shell_getc_is_singlebyte) ? special_case_tokens (token) : -1;
+  if (result >= 0)
+    return result;
+
+#if defined (ALIAS)
+  /* Posix.2 does not allow reserved words to be aliased, so check for all
+     of them, including special cases, before expanding the current token
+     as an alias. */
+  if MBTEST(posixly_correct)
+    CHECK_FOR_RESERVED_WORD (token);
+
+  /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
+     inhibits alias expansion. */
+  if (expand_aliases && quoted == 0)
+    {
+      result = alias_expand_token (token);
+      if (result == RE_READ_TOKEN)
+	return (RE_READ_TOKEN);
+      else if (result == NO_EXPANSION)
+	parser_state &= ~PST_ALEXPNEXT;
+    }
+
+  /* If not in Posix.2 mode, check for reserved words after alias
+     expansion. */
+  if MBTEST(posixly_correct == 0)
+#endif
+    CHECK_FOR_RESERVED_WORD (token);
+
+  the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
+  the_word->word = (char *)xmalloc (1 + token_index);
+  the_word->flags = 0;
+  strcpy (the_word->word, token);
+  if (dollar_present)
+    the_word->flags |= W_HASDOLLAR;
+  if (quoted)
+    the_word->flags |= W_QUOTED;		/*(*/
+  if (compound_assignment && token[token_index-1] == ')')
+    the_word->flags |= W_COMPASSIGN;
+  /* A word is an assignment if it appears at the beginning of a
+     simple command, or after another assignment word.  This is
+     context-dependent, so it cannot be handled in the grammar. */
+  if (assignment (token, (parser_state & PST_COMPASSIGN) != 0))
+    {
+      the_word->flags |= W_ASSIGNMENT;
+      /* Don't perform word splitting on assignment statements. */
+      if (assignment_acceptable (last_read_token) || (parser_state & PST_COMPASSIGN) != 0)
+	the_word->flags |= W_NOSPLIT;
+    }
+
+  if (command_token_position (last_read_token))
+    {
+      struct builtin *b;
+      b = builtin_address_internal (token, 0);
+      if (b && (b->flags & ASSIGNMENT_BUILTIN))
+	parser_state |= PST_ASSIGNOK;
+      else if (STREQ (token, "eval") || STREQ (token, "let"))
+	parser_state |= PST_ASSIGNOK;
+    }
+
+  yylval.word = the_word;
+
+  result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
+		? ASSIGNMENT_WORD : WORD;
+
+  switch (last_read_token)
+    {
+    case FUNCTION:
+      parser_state |= PST_ALLOWOPNBRC;
+      function_dstart = line_number;
+      break;
+    case CASE:
+    case SELECT:
+    case FOR:
+      if (word_top < MAX_CASE_NEST)
+	word_top++;
+      word_lineno[word_top] = line_number;
+      break;
+    }
+
+  return (result);
+}
+
+/* Return 1 if TOKSYM is a token that after being read would allow
+   a reserved word to be seen, else 0. */
+static int
+reserved_word_acceptable (toksym)
+     int toksym;
+{
+  switch (toksym)
+    {
+    case '\n':
+    case ';':
+    case '(':
+    case ')':
+    case '|':
+    case '&':
+    case '{':
+    case '}':		/* XXX */
+    case AND_AND:
+    case BANG:
+    case BAR_AND:
+    case DO:
+    case DONE:
+    case ELIF:
+    case ELSE:
+    case ESAC:
+    case FI:
+    case IF:
+    case OR_OR:
+    case SEMI_SEMI:
+    case SEMI_AND:
+    case SEMI_SEMI_AND:
+    case THEN:
+    case TIME:
+    case TIMEOPT:
+    case COPROC:
+    case UNTIL:
+    case WHILE:
+    case 0:
+      return 1;
+    default:
+#if defined (COPROCESS_SUPPORT)
+      if (last_read_token == WORD && token_before_that == COPROC)
+	return 1;
+#endif
+      return 0;
+    }
+}
+
+/* Return the index of TOKEN in the alist of reserved words, or -1 if
+   TOKEN is not a shell reserved word. */
+int
+find_reserved_word (tokstr)
+     char *tokstr;
+{
+  int i;
+  for (i = 0; word_token_alist[i].word; i++)
+    if (STREQ (tokstr, word_token_alist[i].word))
+      return i;
+  return -1;
+}
+
+#if 0
+#if defined (READLINE)
+/* Called after each time readline is called.  This insures that whatever
+   the new prompt string is gets propagated to readline's local prompt
+   variable. */
+static void
+reset_readline_prompt ()
+{
+  char *temp_prompt;
+
+  if (prompt_string_pointer)
+    {
+      temp_prompt = (*prompt_string_pointer)
+			? decode_prompt_string (*prompt_string_pointer)
+			: (char *)NULL;
+
+      if (temp_prompt == 0)
+	{
+	  temp_prompt = (char *)xmalloc (1);
+	  temp_prompt[0] = '\0';
+	}
+
+      FREE (current_readline_prompt);
+      current_readline_prompt = temp_prompt;
+    }
+}
+#endif /* READLINE */
+#endif /* 0 */
+
+#if defined (HISTORY)
+/* A list of tokens which can be followed by newlines, but not by
+   semi-colons.  When concatenating multiple lines of history, the
+   newline separator for such tokens is replaced with a space. */
+static const int no_semi_successors[] = {
+  '\n', '{', '(', ')', ';', '&', '|',
+  CASE, DO, ELSE, IF, SEMI_SEMI, SEMI_AND, SEMI_SEMI_AND, THEN, UNTIL,
+  WHILE, AND_AND, OR_OR, IN,
+  0
+};
+
+/* If we are not within a delimited expression, try to be smart
+   about which separators can be semi-colons and which must be
+   newlines.  Returns the string that should be added into the
+   history entry. */
+char *
+history_delimiting_chars ()
+{
+  register int i;
+
+  if (dstack.delimiter_depth != 0)
+    return ("\n");
+
+  /* We look for current_command_line_count == 2 because we are looking to
+     add the first line of the body of the here document (the second line
+     of the command). */
+  if (parser_state & PST_HEREDOC)
+    return (current_command_line_count == 2 ? "\n" : "");
+
+  /* First, handle some special cases. */
+  /*(*/
+  /* If we just read `()', assume it's a function definition, and don't
+     add a semicolon.  If the token before the `)' was not `(', and we're
+     not in the midst of parsing a case statement, assume it's a
+     parenthesized command and add the semicolon. */
+  /*)(*/
+  if (token_before_that == ')')
+    {
+      if (two_tokens_ago == '(')	/*)*/	/* function def */
+	return " ";
+      /* This does not work for subshells inside case statement
+	 command lists.  It's a suboptimal solution. */
+      else if (parser_state & PST_CASESTMT)	/* case statement pattern */
+	return " ";
+      else
+	return "; ";				/* (...) subshell */
+    }
+  else if (token_before_that == WORD && two_tokens_ago == FUNCTION)
+    return " ";		/* function def using `function name' without `()' */
+
+  else if (token_before_that == WORD && two_tokens_ago == FOR)
+    {
+      /* Tricky.  `for i\nin ...' should not have a semicolon, but
+	 `for i\ndo ...' should.  We do what we can. */
+      for (i = shell_input_line_index; whitespace (shell_input_line[i]); i++)
+	;
+      if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')
+	return " ";
+      return ";";
+    }
+  else if (two_tokens_ago == CASE && token_before_that == WORD && (parser_state & PST_CASESTMT))
+    return " ";
+
+  for (i = 0; no_semi_successors[i]; i++)
+    {
+      if (token_before_that == no_semi_successors[i])
+	return (" ");
+    }
+
+  return ("; ");
+}
+#endif /* HISTORY */
+
+/* Issue a prompt, or prepare to issue a prompt when the next character
+   is read. */
+static void
+prompt_again ()
+{
+  char *temp_prompt;
+
+  if (interactive == 0 || expanding_alias())	/* XXX */
+    return;
+
+  ps1_prompt = get_string_value ("PS1");
+  ps2_prompt = get_string_value ("PS2");
+
+  if (!prompt_string_pointer)
+    prompt_string_pointer = &ps1_prompt;
+
+  temp_prompt = *prompt_string_pointer
+			? decode_prompt_string (*prompt_string_pointer)
+			: (char *)NULL;
+
+  if (temp_prompt == 0)
+    {
+      temp_prompt = (char *)xmalloc (1);
+      temp_prompt[0] = '\0';
+    }
+
+  current_prompt_string = *prompt_string_pointer;
+  prompt_string_pointer = &ps2_prompt;
+
+#if defined (READLINE)
+  if (!no_line_editing)
+    {
+      FREE (current_readline_prompt);
+      current_readline_prompt = temp_prompt;
+    }
+  else
+#endif	/* READLINE */
+    {
+      FREE (current_decoded_prompt);
+      current_decoded_prompt = temp_prompt;
+    }
+}
+
+int
+get_current_prompt_level ()
+{
+  return ((current_prompt_string && current_prompt_string == ps2_prompt) ? 2 : 1);
+}
+
+void
+set_current_prompt_level (x)
+     int x;
+{
+  prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
+  current_prompt_string = *prompt_string_pointer;
+}
+
+static void
+print_prompt ()
+{
+  fprintf (stderr, "%s", current_decoded_prompt);
+  fflush (stderr);
+}
+
+/* Return a string which will be printed as a prompt.  The string
+   may contain special characters which are decoded as follows:
+
+	\a	bell (ascii 07)
+	\d	the date in Day Mon Date format
+	\e	escape (ascii 033)
+	\h	the hostname up to the first `.'
+	\H	the hostname
+	\j	the number of active jobs
+	\l	the basename of the shell's tty device name
+	\n	CRLF
+	\r	CR
+	\s	the name of the shell
+	\t	the time in 24-hour hh:mm:ss format
+	\T	the time in 12-hour hh:mm:ss format
+	\@	the time in 12-hour hh:mm am/pm format
+	\A	the time in 24-hour hh:mm format
+	\D{fmt}	the result of passing FMT to strftime(3)
+	\u	your username
+	\v	the version of bash (e.g., 2.00)
+	\V	the release of bash, version + patchlevel (e.g., 2.00.0)
+	\w	the current working directory
+	\W	the last element of $PWD
+	\!	the history number of this command
+	\#	the command number of this command
+	\$	a $ or a # if you are root
+	\nnn	character code nnn in octal
+	\\	a backslash
+	\[	begin a sequence of non-printing chars
+	\]	end a sequence of non-printing chars
+*/
+#define PROMPT_GROWTH 48
+char *
+decode_prompt_string (string)
+     char *string;
+{
+  WORD_LIST *list;
+  char *result, *t;
+  struct dstack save_dstack;
+  int last_exit_value;
+#if defined (PROMPT_STRING_DECODE)
+  int result_size, result_index;
+  int c, n, i;
+  char *temp, octal_string[4];
+  struct tm *tm;
+  time_t the_time;
+  char timebuf[128];
+  char *timefmt;
+
+  result = (char *)xmalloc (result_size = PROMPT_GROWTH);
+  result[result_index = 0] = 0;
+  temp = (char *)NULL;
+
+  while (c = *string++)
+    {
+      if (posixly_correct && c == '!')
+	{
+	  if (*string == '!')
+	    {
+	      temp = savestring ("!");
+	      goto add_string;
+	    }
+	  else
+	    {
+#if !defined (HISTORY)
+		temp = savestring ("1");
+#else /* HISTORY */
+		temp = itos (history_number ());
+#endif /* HISTORY */
+		string--;	/* add_string increments string again. */
+		goto add_string;
+	    }
+	}
+      if (c == '\\')
+	{
+	  c = *string;
+
+	  switch (c)
+	    {
+	    case '0':
+	    case '1':
+	    case '2':
+	    case '3':
+	    case '4':
+	    case '5':
+	    case '6':
+	    case '7':
+	      strncpy (octal_string, string, 3);
+	      octal_string[3] = '\0';
+
+	      n = read_octal (octal_string);
+	      temp = (char *)xmalloc (3);
+
+	      if (n == CTLESC || n == CTLNUL)
+		{
+		  temp[0] = CTLESC;
+		  temp[1] = n;
+		  temp[2] = '\0';
+		}
+	      else if (n == -1)
+		{
+		  temp[0] = '\\';
+		  temp[1] = '\0';
+		}
+	      else
+		{
+		  temp[0] = n;
+		  temp[1] = '\0';
+		}
+
+	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
+		string++;
+
+	      c = 0;		/* tested at add_string: */
+	      goto add_string;
+
+	    case 'd':
+	    case 't':
+	    case 'T':
+	    case '@':
+	    case 'A':
+	      /* Make the current time/date into a string. */
+	      (void) time (&the_time);
+	      tm = localtime (&the_time);
+
+	      if (c == 'd')
+		n = strftime (timebuf, sizeof (timebuf), "%a %b %d", tm);
+	      else if (c == 't')
+		n = strftime (timebuf, sizeof (timebuf), "%H:%M:%S", tm);
+	      else if (c == 'T')
+		n = strftime (timebuf, sizeof (timebuf), "%I:%M:%S", tm);
+	      else if (c == '@')
+		n = strftime (timebuf, sizeof (timebuf), "%I:%M %p", tm);
+	      else if (c == 'A')
+		n = strftime (timebuf, sizeof (timebuf), "%H:%M", tm);
+
+	      if (n == 0)
+		timebuf[0] = '\0';
+	      else
+		timebuf[sizeof(timebuf) - 1] = '\0';
+
+	      temp = savestring (timebuf);
+	      goto add_string;
+
+	    case 'D':		/* strftime format */
+	      if (string[1] != '{')		/* } */
+		goto not_escape;
+
+	      (void) time (&the_time);
+	      tm = localtime (&the_time);
+	      string += 2;			/* skip { */
+	      timefmt = xmalloc (strlen (string) + 3);
+	      for (t = timefmt; *string && *string != '}'; )
+		*t++ = *string++;
+	      *t = '\0';
+	      c = *string;	/* tested at add_string */
+	      if (timefmt[0] == '\0')
+		{
+		  timefmt[0] = '%';
+		  timefmt[1] = 'X';	/* locale-specific current time */
+		  timefmt[2] = '\0';
+		}
+	      n = strftime (timebuf, sizeof (timebuf), timefmt, tm);
+	      free (timefmt);
+
+	      if (n == 0)
+		timebuf[0] = '\0';
+	      else
+		timebuf[sizeof(timebuf) - 1] = '\0';
+
+	      if (promptvars || posixly_correct)
+		/* Make sure that expand_prompt_string is called with a
+		   second argument of Q_DOUBLE_QUOTES if we use this
+		   function here. */
+		temp = sh_backslash_quote_for_double_quotes (timebuf);
+	      else
+		temp = savestring (timebuf);
+	      goto add_string;
+
+	    case 'n':
+	      temp = (char *)xmalloc (3);
+	      temp[0] = no_line_editing ? '\n' : '\r';
+	      temp[1] = no_line_editing ? '\0' : '\n';
+	      temp[2] = '\0';
+	      goto add_string;
+
+	    case 's':
+	      temp = base_pathname (shell_name);
+	      temp = savestring (temp);
+	      goto add_string;
+
+	    case 'v':
+	    case 'V':
+	      temp = (char *)xmalloc (16);
+	      if (c == 'v')
+		strcpy (temp, dist_version);
+	      else
+		sprintf (temp, "%s.%d", dist_version, patch_level);
+	      goto add_string;
+
+	    case 'w':
+	    case 'W':
+	      {
+		/* Use the value of PWD because it is much more efficient. */
+		char t_string[PATH_MAX];
+		int tlen;
+
+		temp = get_string_value ("PWD");
+
+		if (temp == 0)
+		  {
+		    if (getcwd (t_string, sizeof(t_string)) == 0)
+		      {
+			t_string[0] = '.';
+			tlen = 1;
+		      }
+		    else
+		      tlen = strlen (t_string);
+		  }
+		else
+		  {
+		    tlen = sizeof (t_string) - 1;
+		    strncpy (t_string, temp, tlen);
+		  }
+		t_string[tlen] = '\0';
+
+#define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
+#define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
+		/* Abbreviate \W as ~ if $PWD == $HOME */
+		if (c == 'W' && (((t = get_string_value ("HOME")) == 0) || STREQ (t, t_string) == 0))
+		  {
+		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
+		      {
+			t = strrchr (t_string, '/');
+			if (t)
+			  strcpy (t_string, t + 1);
+		      }
+		  }
+#undef ROOT_PATH
+#undef DOUBLE_SLASH_ROOT
+		else
+		  /* polite_directory_format is guaranteed to return a string
+		     no longer than PATH_MAX - 1 characters. */
+		  strcpy (t_string, polite_directory_format (t_string));
+
+		temp = trim_pathname (t_string, PATH_MAX - 1);
+		/* If we're going to be expanding the prompt string later,
+		   quote the directory name. */
+		if (promptvars || posixly_correct)
+		  /* Make sure that expand_prompt_string is called with a
+		     second argument of Q_DOUBLE_QUOTES if we use this
+		     function here. */
+		  temp = sh_backslash_quote_for_double_quotes (t_string);
+		else
+		  temp = savestring (t_string);
+
+		goto add_string;
+	      }
+
+	    case 'u':
+	      if (current_user.user_name == 0)
+		get_current_user_info ();
+	      temp = savestring (current_user.user_name);
+	      goto add_string;
+
+	    case 'h':
+	    case 'H':
+	      temp = savestring (current_host_name);
+	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
+		*t = '\0';
+	      goto add_string;
+
+	    case '#':
+	      temp = itos (current_command_number);
+	      goto add_string;
+
+	    case '!':
+#if !defined (HISTORY)
+	      temp = savestring ("1");
+#else /* HISTORY */
+	      temp = itos (history_number ());
+#endif /* HISTORY */
+	      goto add_string;
+
+	    case '$':
+	      t = temp = (char *)xmalloc (3);
+	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
+		*t++ = '\\';
+	      *t++ = current_user.euid == 0 ? '#' : '$';
+	      *t = '\0';
+	      goto add_string;
+
+	    case 'j':
+	      temp = itos (count_all_jobs ());
+	      goto add_string;
+
+	    case 'l':
+#if defined (HAVE_TTYNAME)
+	      temp = (char *)ttyname (fileno (stdin));
+	      t = temp ? base_pathname (temp) : "tty";
+	      temp = savestring (t);
+#else
+	      temp = savestring ("tty");
+#endif /* !HAVE_TTYNAME */
+	      goto add_string;
+
+#if defined (READLINE)
+	    case '[':
+	    case ']':
+	      if (no_line_editing)
+		{
+		  string++;
+		  break;
+		}
+	      temp = (char *)xmalloc (3);
+	      n = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
+	      i = 0;
+	      if (n == CTLESC || n == CTLNUL)
+		temp[i++] = CTLESC;
+	      temp[i++] = n;
+	      temp[i] = '\0';
+	      goto add_string;
+#endif /* READLINE */
+
+	    case '\\':
+	    case 'a':
+	    case 'e':
+	    case 'r':
+	      temp = (char *)xmalloc (2);
+	      if (c == 'a')
+		temp[0] = '\07';
+	      else if (c == 'e')
+		temp[0] = '\033';
+	      else if (c == 'r')
+		temp[0] = '\r';
+	      else			/* (c == '\\') */
+	        temp[0] = c;
+	      temp[1] = '\0';
+	      goto add_string;
+
+	    default:
+not_escape:
+	      temp = (char *)xmalloc (3);
+	      temp[0] = '\\';
+	      temp[1] = c;
+	      temp[2] = '\0';
+
+	    add_string:
+	      if (c)
+		string++;
+	      result =
+		sub_append_string (temp, result, &result_index, &result_size);
+	      temp = (char *)NULL; /* Freed in sub_append_string (). */
+	      result[result_index] = '\0';
+	      break;
+	    }
+	}
+      else
+	{
+	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
+	  result[result_index++] = c;
+	  result[result_index] = '\0';
+	}
+    }
+#else /* !PROMPT_STRING_DECODE */
+  result = savestring (string);
+#endif /* !PROMPT_STRING_DECODE */
+
+  /* Save the delimiter stack and point `dstack' to temp space so any
+     command substitutions in the prompt string won't result in screwing
+     up the parser's quoting state. */
+  save_dstack = dstack;
+  dstack = temp_dstack;
+  dstack.delimiter_depth = 0;
+
+  /* Perform variable and parameter expansion and command substitution on
+     the prompt string. */
+  if (promptvars || posixly_correct)
+    {
+      last_exit_value = last_command_exit_value;
+      list = expand_prompt_string (result, Q_DOUBLE_QUOTES, 0);
+      free (result);
+      result = string_list (list);
+      dispose_words (list);
+      last_command_exit_value = last_exit_value;
+    }
+  else
+    {
+      t = dequote_string (result);
+      free (result);
+      result = t;
+    }
+
+  dstack = save_dstack;
+
+  return (result);
+}
+
+/************************************************
+ *						*
+ *		ERROR HANDLING			*
+ *						*
+ ************************************************/
+
+/* Report a syntax error, and restart the parser.  Call here for fatal
+   errors. */
+int
+yyerror (msg)
+     const char *msg;
+{
+  report_syntax_error ((char *)NULL);
+  reset_parser ();
+  return (0);
+}
+
+static char *
+error_token_from_token (tok)
+     int tok;
+{
+  char *t;
+
+  if (t = find_token_in_alist (tok, word_token_alist, 0))
+    return t;
+
+  if (t = find_token_in_alist (tok, other_token_alist, 0))
+    return t;
+
+  t = (char *)NULL;
+  /* This stuff is dicy and needs closer inspection */
+  switch (current_token)
+    {
+    case WORD:
+    case ASSIGNMENT_WORD:
+      if (yylval.word)
+	t = savestring (yylval.word->word);
+      break;
+    case NUMBER:
+      t = itos (yylval.number);
+      break;
+    case ARITH_CMD:
+      if (yylval.word_list)
+        t = string_list (yylval.word_list);
+      break;
+    case ARITH_FOR_EXPRS:
+      if (yylval.word_list)
+	t = string_list_internal (yylval.word_list, " ; ");
+      break;
+    case COND_CMD:
+      t = (char *)NULL;		/* punt */
+      break;
+    }
+
+  return t;
+}
+
+static char *
+error_token_from_text ()
+{
+  char *msg, *t;
+  int token_end, i;
+
+  t = shell_input_line;
+  i = shell_input_line_index;
+  token_end = 0;
+  msg = (char *)NULL;
+
+  if (i && t[i] == '\0')
+    i--;
+
+  while (i && (whitespace (t[i]) || t[i] == '\n'))
+    i--;
+
+  if (i)
+    token_end = i + 1;
+
+  while (i && (member (t[i], " \n\t;|&") == 0))
+    i--;
+
+  while (i != token_end && (whitespace (t[i]) || t[i] == '\n'))
+    i++;
+
+  /* Return our idea of the offending token. */
+  if (token_end || (i == 0 && token_end == 0))
+    {
+      if (token_end)
+	msg = substring (t, i, token_end);
+      else	/* one-character token */
+	{
+	  msg = (char *)xmalloc (2);
+	  msg[0] = t[i];
+	  msg[1] = '\0';
+	}
+    }
+
+  return (msg);
+}
+
+static void
+print_offending_line ()
+{
+  char *msg;
+  int token_end;
+
+  msg = savestring (shell_input_line);
+  token_end = strlen (msg);
+  while (token_end && msg[token_end - 1] == '\n')
+    msg[--token_end] = '\0';
+
+  parser_error (line_number, "`%s'", msg);
+  free (msg);
+}
+
+/* Report a syntax error with line numbers, etc.
+   Call here for recoverable errors.  If you have a message to print,
+   then place it in MESSAGE, otherwise pass NULL and this will figure
+   out an appropriate message for you. */
+static void
+report_syntax_error (message)
+     char *message;
+{
+  char *msg;
+
+  if (message)
+    {
+      parser_error (line_number, "%s", message);
+      if (interactive && EOF_Reached)
+	EOF_Reached = 0;
+      last_command_exit_value = EX_USAGE;
+      return;
+    }
+
+  /* If the line of input we're reading is not null, try to find the
+     objectionable token.  First, try to figure out what token the
+     parser's complaining about by looking at current_token. */
+  if (current_token != 0 && EOF_Reached == 0 && (msg = error_token_from_token (current_token)))
+    {
+      parser_error (line_number, _("syntax error near unexpected token `%s'"), msg);
+      free (msg);
+
+      if (interactive == 0)
+	print_offending_line ();
+
+      last_command_exit_value = EX_USAGE;
+      return;
+    }
+
+  /* If looking at the current token doesn't prove fruitful, try to find the
+     offending token by analyzing the text of the input line near the current
+     input line index and report what we find. */
+  if (shell_input_line && *shell_input_line)
+    {
+      msg = error_token_from_text ();
+      if (msg)
+	{
+	  parser_error (line_number, _("syntax error near `%s'"), msg);
+	  free (msg);
+	}
+
+      /* If not interactive, print the line containing the error. */
+      if (interactive == 0)
+        print_offending_line ();
+    }
+  else
+    {
+      msg = EOF_Reached ? _("syntax error: unexpected end of file") : _("syntax error");
+      parser_error (line_number, "%s", msg);
+      /* When the shell is interactive, this file uses EOF_Reached
+	 only for error reporting.  Other mechanisms are used to
+	 decide whether or not to exit. */
+      if (interactive && EOF_Reached)
+	EOF_Reached = 0;
+    }
+
+  last_command_exit_value = EX_USAGE;
+}
+
+/* ??? Needed function. ??? We have to be able to discard the constructs
+   created during parsing.  In the case of error, we want to return
+   allocated objects to the memory pool.  In the case of no error, we want
+   to throw away the information about where the allocated objects live.
+   (dispose_command () will actually free the command.) */
+static void
+discard_parser_constructs (error_p)
+     int error_p;
+{
+}
+
+/************************************************
+ *						*
+ *		EOF HANDLING			*
+ *						*
+ ************************************************/
+
+/* Do that silly `type "bye" to exit' stuff.  You know, "ignoreeof". */
+
+/* A flag denoting whether or not ignoreeof is set. */
+int ignoreeof = 0;
+
+/* The number of times that we have encountered an EOF character without
+   another character intervening.  When this gets above the limit, the
+   shell terminates. */
+int eof_encountered = 0;
+
+/* The limit for eof_encountered. */
+int eof_encountered_limit = 10;
+
+/* If we have EOF as the only input unit, this user wants to leave
+   the shell.  If the shell is not interactive, then just leave.
+   Otherwise, if ignoreeof is set, and we haven't done this the
+   required number of times in a row, print a message. */
+static void
+handle_eof_input_unit ()
+{
+  if (interactive)
+    {
+      /* shell.c may use this to decide whether or not to write out the
+	 history, among other things.  We use it only for error reporting
+	 in this file. */
+      if (EOF_Reached)
+	EOF_Reached = 0;
+
+      /* If the user wants to "ignore" eof, then let her do so, kind of. */
+      if (ignoreeof)
+	{
+	  if (eof_encountered < eof_encountered_limit)
+	    {
+	      fprintf (stderr, _("Use \"%s\" to leave the shell.\n"),
+		       login_shell ? "logout" : "exit");
+	      eof_encountered++;
+	      /* Reset the parsing state. */
+	      last_read_token = current_token = '\n';
+	      /* Reset the prompt string to be $PS1. */
+	      prompt_string_pointer = (char **)NULL;
+	      prompt_again ();
+	      return;
+	    }
+	}
+
+      /* In this case EOF should exit the shell.  Do it now. */
+      reset_parser ();
+      exit_builtin ((WORD_LIST *)NULL);
+    }
+  else
+    {
+      /* We don't write history files, etc., for non-interactive shells. */
+      EOF_Reached = 1;
+    }
+}
+
+/************************************************
+ *						*
+ *	STRING PARSING FUNCTIONS		*
+ *						*
+ ************************************************/
+
+/* It's very important that these two functions treat the characters
+   between ( and ) identically. */
+
+static WORD_LIST parse_string_error;
+
+/* Take a string and run it through the shell parser, returning the
+   resultant word list.  Used by compound array assignment. */
+WORD_LIST *
+parse_string_to_word_list (s, flags, whom)
+     char *s;
+     int flags;
+     const char *whom;
+{
+  WORD_LIST *wl;
+  int tok, orig_current_token, orig_line_number, orig_input_terminator;
+  int orig_line_count;
+  int old_echo_input, old_expand_aliases;
+#if defined (HISTORY)
+  int old_remember_on_history, old_history_expansion_inhibited;
+#endif
+
+#if defined (HISTORY)
+  old_remember_on_history = remember_on_history;
+#  if defined (BANG_HISTORY)
+  old_history_expansion_inhibited = history_expansion_inhibited;
+#  endif
+  bash_history_disable ();
+#endif
+
+  orig_line_number = line_number;
+  orig_line_count = current_command_line_count;
+  orig_input_terminator = shell_input_line_terminator;
+  old_echo_input = echo_input_at_read;
+  old_expand_aliases = expand_aliases;
+
+  push_stream (1);
+  last_read_token = WORD;		/* WORD to allow reserved words here */
+  current_command_line_count = 0;
+  echo_input_at_read = expand_aliases = 0;
+
+  with_input_from_string (s, whom);
+  wl = (WORD_LIST *)NULL;
+
+  if (flags & 1)
+    parser_state |= PST_COMPASSIGN|PST_REPARSE;
+
+  while ((tok = read_token (READ)) != yacc_EOF)
+    {
+      if (tok == '\n' && *bash_input.location.string == '\0')
+	break;
+      if (tok == '\n')		/* Allow newlines in compound assignments */
+	continue;
+      if (tok != WORD && tok != ASSIGNMENT_WORD)
+	{
+	  line_number = orig_line_number + line_number - 1;
+	  orig_current_token = current_token;
+	  current_token = tok;
+	  yyerror (NULL);	/* does the right thing */
+	  current_token = orig_current_token;
+	  if (wl)
+	    dispose_words (wl);
+	  wl = &parse_string_error;
+	  break;
+	}
+      wl = make_word_list (yylval.word, wl);
+    }
+
+  last_read_token = '\n';
+  pop_stream ();
+
+#if defined (HISTORY)
+  remember_on_history = old_remember_on_history;
+#  if defined (BANG_HISTORY)
+  history_expansion_inhibited = old_history_expansion_inhibited;
+#  endif /* BANG_HISTORY */
+#endif /* HISTORY */
+
+  echo_input_at_read = old_echo_input;
+  expand_aliases = old_expand_aliases;
+
+  current_command_line_count = orig_line_count;
+  shell_input_line_terminator = orig_input_terminator;
+
+  if (flags & 1)
+    parser_state &= ~(PST_COMPASSIGN|PST_REPARSE);
+
+  if (wl == &parse_string_error)
+    {
+      last_command_exit_value = EXECUTION_FAILURE;
+      if (interactive_shell == 0 && posixly_correct)
+	jump_to_top_level (FORCE_EOF);
+      else
+	jump_to_top_level (DISCARD);
+    }
+
+  return (REVERSE_LIST (wl, WORD_LIST *));
+}
+
+static char *
+parse_compound_assignment (retlenp)
+     int *retlenp;
+{
+  WORD_LIST *wl, *rl;
+  int tok, orig_line_number, orig_token_size, orig_last_token, assignok;
+  char *saved_token, *ret;
+
+  saved_token = token;
+  orig_token_size = token_buffer_size;
+  orig_line_number = line_number;
+  orig_last_token = last_read_token;
+
+  last_read_token = WORD;	/* WORD to allow reserved words here */
+
+  token = (char *)NULL;
+  token_buffer_size = 0;
+
+  assignok = parser_state&PST_ASSIGNOK;		/* XXX */
+
+  wl = (WORD_LIST *)NULL;	/* ( */
+  parser_state |= PST_COMPASSIGN;
+
+  while ((tok = read_token (READ)) != ')')
+    {
+      if (tok == '\n')			/* Allow newlines in compound assignments */
+	{
+	  if (SHOULD_PROMPT ())
+	    prompt_again ();
+	  continue;
+	}
+      if (tok != WORD && tok != ASSIGNMENT_WORD)
+	{
+	  current_token = tok;	/* for error reporting */
+	  if (tok == yacc_EOF)	/* ( */
+	    parser_error (orig_line_number, _("unexpected EOF while looking for matching `)'"));
+	  else
+	    yyerror(NULL);	/* does the right thing */
+	  if (wl)
+	    dispose_words (wl);
+	  wl = &parse_string_error;
+	  break;
+	}
+      wl = make_word_list (yylval.word, wl);
+    }
+
+  FREE (token);
+  token = saved_token;
+  token_buffer_size = orig_token_size;
+
+  parser_state &= ~PST_COMPASSIGN;
+
+  if (wl == &parse_string_error)
+    {
+      last_command_exit_value = EXECUTION_FAILURE;
+      last_read_token = '\n';	/* XXX */
+      if (interactive_shell == 0 && posixly_correct)
+	jump_to_top_level (FORCE_EOF);
+      else
+	jump_to_top_level (DISCARD);
+    }
+
+  last_read_token = orig_last_token;		/* XXX - was WORD? */
+
+  if (wl)
+    {
+      rl = REVERSE_LIST (wl, WORD_LIST *);
+      ret = string_list (rl);
+      dispose_words (rl);
+    }
+  else
+    ret = (char *)NULL;
+
+  if (retlenp)
+    *retlenp = (ret && *ret) ? strlen (ret) : 0;
+
+  if (assignok)
+    parser_state |= PST_ASSIGNOK;
+
+  return ret;
+}
+
+/************************************************
+ *						*
+ *   SAVING AND RESTORING PARTIAL PARSE STATE   *
+ *						*
+ ************************************************/
+
+sh_parser_state_t *
+save_parser_state (ps)
+     sh_parser_state_t *ps;
+{
+#if defined (ARRAY_VARS)
+  SHELL_VAR *v;
+#endif
+
+  if (ps == 0)
+    ps = (sh_parser_state_t *)xmalloc (sizeof (sh_parser_state_t));
+  if (ps == 0)
+    return ((sh_parser_state_t *)NULL);
+
+  ps->parser_state = parser_state;
+  ps->token_state = save_token_state ();
+
+  ps->input_line_terminator = shell_input_line_terminator;
+  ps->eof_encountered = eof_encountered;
+
+  ps->current_command_line_count = current_command_line_count;
+
+#if defined (HISTORY)
+  ps->remember_on_history = remember_on_history;
+#  if defined (BANG_HISTORY)
+  ps->history_expansion_inhibited = history_expansion_inhibited;
+#  endif
+#endif
+
+  ps->last_command_exit_value = last_command_exit_value;
+#if defined (ARRAY_VARS)
+  v = find_variable ("PIPESTATUS");
+  if (v && array_p (v) && array_cell (v))
+    ps->pipestatus = array_copy (array_cell (v));
+  else
+    ps->pipestatus = (ARRAY *)NULL;
+#endif
+
+  ps->last_shell_builtin = last_shell_builtin;
+  ps->this_shell_builtin = this_shell_builtin;
+
+  ps->expand_aliases = expand_aliases;
+  ps->echo_input_at_read = echo_input_at_read;
+
+  return (ps);
+}
+
+void
+restore_parser_state (ps)
+     sh_parser_state_t *ps;
+{
+#if defined (ARRAY_VARS)
+  SHELL_VAR *v;
+#endif
+
+  if (ps == 0)
+    return;
+
+  parser_state = ps->parser_state;
+  if (ps->token_state)
+    {
+      restore_token_state (ps->token_state);
+      free (ps->token_state);
+    }
+
+  shell_input_line_terminator = ps->input_line_terminator;
+  eof_encountered = ps->eof_encountered;
+
+  current_command_line_count = ps->current_command_line_count;
+
+#if defined (HISTORY)
+  remember_on_history = ps->remember_on_history;
+#  if defined (BANG_HISTORY)
+  history_expansion_inhibited = ps->history_expansion_inhibited;
+#  endif
+#endif
+
+  last_command_exit_value = ps->last_command_exit_value;
+#if defined (ARRAY_VARS)
+  v = find_variable ("PIPESTATUS");
+  if (v && array_p (v) && array_cell (v))
+    {
+      array_dispose (array_cell (v));
+      var_setarray (v, ps->pipestatus);
+    }
+#endif
+
+  last_shell_builtin = ps->last_shell_builtin;
+  this_shell_builtin = ps->this_shell_builtin;
+
+  expand_aliases = ps->expand_aliases;
+  echo_input_at_read = ps->echo_input_at_read;
+}
+
+/************************************************
+ *						*
+ *	MULTIBYTE CHARACTER HANDLING		*
+ *						*
+ ************************************************/
+
+#if defined (HANDLE_MULTIBYTE)
+static void
+set_line_mbstate ()
+{
+  int i, previ, len, c;
+  mbstate_t mbs, prevs;
+  size_t mbclen;
+
+  if (shell_input_line == NULL)
+    return;
+  len = strlen (shell_input_line);	/* XXX - shell_input_line_len ? */
+  FREE (shell_input_line_property);
+  shell_input_line_property = (char *)xmalloc (len + 1);
+
+  memset (&prevs, '\0', sizeof (mbstate_t));
+  for (i = previ = 0; i < len; i++)
+    {
+      mbs = prevs;
+
+      c = shell_input_line[i];
+      if (c == EOF)
+	{
+	  int j;
+	  for (j = i; j < len; j++)
+	    shell_input_line_property[j] = 1;
+	  break;
+	}
+
+      mbclen = mbrlen (shell_input_line + previ, i - previ + 1, &mbs);
+      if (mbclen == 1 || mbclen == (size_t)-1)
+	{
+	  mbclen = 1;
+	  previ = i + 1;
+	}
+      else if (mbclen == (size_t)-2)
+        mbclen = 0;
+      else if (mbclen > 1)
+	{
+	  mbclen = 0;
+	  previ = i + 1;
+	  prevs = mbs;
+	}
+      else
+	{
+	  /* XXX - what to do if mbrlen returns 0? (null wide character) */
+	  int j;
+	  for (j = i; j < len; j++)
+	    shell_input_line_property[j] = 1;
+	  break;
+	}
+
+      shell_input_line_property[i] = mbclen;
+    }
+}
+#endif /* HANDLE_MULTIBYTE */
diff -Nru bash-4.0-orig/patchlevel.h bash-4.0/patchlevel.h
--- bash-4.0-orig/patchlevel.h	2009-01-04 20:32:40.000000000 +0100
+++ bash-4.0/patchlevel.h	2009-12-08 18:06:16.000000000 +0100
@@ -25,6 +25,6 @@
    regexp `^#define[ 	]*PATCHLEVEL', since that's what support/mkversion.sh
    looks for to find the patch level (for the sccs version string). */
 
-#define PATCHLEVEL 0
+#define PATCHLEVEL 35
 
 #endif /* _PATCHLEVEL_H_ */
diff -Nru bash-4.0-orig/pathnames.h bash-4.0/pathnames.h
--- bash-4.0-orig/pathnames.h	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/pathnames.h	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,33 @@
+/* pathnames.h -- absolute filenames that bash wants for various defaults. */
+
+/* Copyright (C) 1987-2009 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Bash is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#if !defined (_PATHNAMES_H_)
+#define _PATHNAMES_H_
+
+/* The default file for hostname completion. */
+#define DEFAULT_HOSTS_FILE "/etc/hosts"
+
+/* The default login shell startup file. */
+#define SYS_PROFILE "/etc/profile"
+
+/* The default location of the bash debugger initialization/startup file. */
+#define DEBUGGER_START_FILE	"@DEBUGGER_START_FILE@"
+
+#endif /* _PATHNAMES_H */
diff -Nru bash-4.0-orig/pbuild.xml bash-4.0/pbuild.xml
--- bash-4.0-orig/pbuild.xml	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/pbuild.xml	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,337 @@
+<!--
+
+This file is part of the yaosp build system
+
+Copyright (c) 2009 Zoltan Kovacs
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of version 2 of the GNU General Public License
+as published by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+-->
+
+<build default="all">
+    <array name="files">
+        <item>shell.c</item>
+        <item>eval.c</item>
+        <item>y.tab.c</item>
+        <item>general.c</item>
+        <item>make_cmd.c</item>
+        <item>print_cmd.c</item>
+        <item>dispose_cmd.c</item>
+        <item>execute_cmd.c</item>
+        <item>variables.c</item>
+        <item>copy_cmd.c</item>
+        <item>error.c</item>
+        <item>expr.c</item>
+        <item>flags.c</item>
+        <item>jobs.c</item>
+        <item>subst.c</item>
+        <item>hashcmd.c</item>
+        <item>hashlib.c</item>
+        <item>mailcheck.c</item>
+        <item>trap.c</item>
+        <item>input.c</item>
+        <item>unwind_prot.c</item>
+        <item>pathexp.c</item>
+        <item>sig.c</item>
+        <item>test.c</item>
+        <item>version.c</item>
+        <item>alias.c</item>
+        <item>array.c</item>
+        <item>arrayfunc.c</item>
+        <item>assoc.c</item>
+        <item>braces.c</item>
+        <item>bracecomp.c</item>
+        <item>bashhist.c</item>
+        <item>bashline.c</item>
+        <item>list.c</item>
+        <item>stringlib.c</item>
+        <item>locale.c</item>
+        <item>findcmd.c</item>
+        <item>redir.c</item>
+        <item>pcomplete.c</item>
+        <item>pcomplib.c</item>
+        <item>syntax.c</item>
+        <item>xmalloc.c</item>
+        <item>lib/sh/clktck.c</item>
+        <item>lib/sh/clock.c</item>
+        <item>lib/sh/getenv.c</item>
+        <item>lib/sh/oslib.c</item>
+        <item>lib/sh/setlinebuf.c</item>
+        <item>lib/sh/strnlen.c</item>
+        <item>lib/sh/itos.c</item>
+        <item>lib/sh/zread.c</item>
+        <item>lib/sh/zwrite.c</item>
+        <item>lib/sh/shtty.c</item>
+        <item>lib/sh/shmatch.c</item>
+        <item>lib/sh/eaccess.c</item>
+        <item>lib/sh/netconn.c</item>
+        <item>lib/sh/netopen.c</item>
+        <item>lib/sh/timeval.c</item>
+        <item>lib/sh/makepath.c</item>
+        <item>lib/sh/pathcanon.c</item>
+        <item>lib/sh/pathphys.c</item>
+        <item>lib/sh/tmpfile.c</item>
+        <item>lib/sh/stringlist.c</item>
+        <item>lib/sh/stringvec.c</item>
+        <item>lib/sh/spell.c</item>
+        <item>lib/sh/shquote.c</item>
+        <item>lib/sh/strtrans.c</item>
+        <item>lib/sh/strindex.c</item>
+        <item>lib/sh/snprintf.c</item>
+        <item>lib/sh/mailstat.c</item>
+        <item>lib/sh/fmtulong.c</item>
+        <item>lib/sh/fmtullong.c</item>
+        <item>lib/sh/fmtumax.c</item>
+        <item>lib/sh/xstrchr.c</item>
+        <item>lib/sh/zcatfd.c</item>
+        <item>lib/sh/zmapfd.c</item>
+        <item>lib/sh/winsize.c</item>
+        <item>lib/sh/wcsdup.c</item>
+        <item>lib/sh/fpurge.c</item>
+        <item>lib/sh/zgetline.c</item>
+        <item>lib/sh/mbscmp.c</item>
+        <item>lib/sh/uconvert.c</item>
+        <item>lib/sh/ufuncs.c</item>
+        <item>lib/sh/casemod.c</item>
+        <item>lib/sh/fdprintf.c</item>
+        <item>lib/sh/input_avail.c</item>
+        <item>lib/glob/glob.c</item>
+        <item>lib/glob/strmatch.c</item>
+        <item>lib/glob/smatch.c</item>
+        <item>lib/glob/xmbsrtowcs.c</item>
+    </array>
+
+    <array name="files_builtins">
+        <item>builtins/builtins.c</item>
+        <item>builtins/alias.c</item>
+        <item>builtins/bind.c</item>
+        <item>builtins/break.c</item>
+        <item>builtins/builtin.c</item>
+        <item>builtins/caller.c</item>
+        <item>builtins/cd.c</item>
+        <item>builtins/colon.c</item>
+        <item>builtins/command.c</item>
+        <item>builtins/common.c</item>
+        <item>builtins/declare.c</item>
+        <item>builtins/echo.c</item>
+        <item>builtins/enable.c</item>
+        <item>builtins/eval.c</item>
+        <item>builtins/evalfile.c</item>
+        <item>builtins/evalstring.c</item>
+        <item>builtins/exec.c</item>
+        <item>builtins/exit.c</item>
+        <item>builtins/fc.c</item>
+        <item>builtins/fg_bg.c</item>
+        <item>builtins/hash.c</item>
+        <item>builtins/help.c</item>
+        <item>builtins/history.c</item>
+        <item>builtins/jobs.c</item>
+        <item>builtins/kill.c</item>
+        <item>builtins/let.c</item>
+        <item>builtins/mapfile.c</item>
+        <item>builtins/pushd.c</item>
+        <item>builtins/read.c</item>
+        <item>builtins/return.c</item>
+        <item>builtins/set.c</item>
+        <item>builtins/setattr.c</item>
+        <item>builtins/shift.c</item>
+        <item>builtins/source.c</item>
+        <item>builtins/suspend.c</item>
+        <item>builtins/test.c</item>
+        <item>builtins/times.c</item>
+        <item>builtins/trap.c</item>
+        <item>builtins/type.c</item>
+        <item>builtins/ulimit.c</item>
+        <item>builtins/umask.c</item>
+        <item>builtins/wait.c</item>
+        <item>builtins/getopts.c</item>
+        <item>builtins/shopt.c</item>
+        <item>builtins/printf.c</item>
+        <item>builtins/getopt.c</item>
+        <item>builtins/bashgetopt.c</item>
+        <item>builtins/complete.c</item>
+    </array>
+
+    <array name="files_readline">
+        <item>lib/readline/readline.c</item>
+        <item>lib/readline/vi_mode.c</item>
+        <item>lib/readline/funmap.c</item>
+        <item>lib/readline/keymaps.c</item>
+        <item>lib/readline/parens.c</item>
+        <item>lib/readline/search.c</item>
+        <item>lib/readline/rltty.c</item>
+        <item>lib/readline/complete.c</item>
+        <item>lib/readline/bind.c</item>
+        <item>lib/readline/isearch.c</item>
+        <item>lib/readline/display.c</item>
+        <item>lib/readline/signals.c</item>
+        <item>lib/readline/util.c</item>
+        <item>lib/readline/kill.c</item>
+        <item>lib/readline/undo.c</item>
+        <item>lib/readline/macro.c</item>
+        <item>lib/readline/input.c</item>
+        <item>lib/readline/callback.c</item>
+        <item>lib/readline/terminal.c</item>
+        <item>lib/readline/text.c</item>
+        <item>lib/readline/nls.c</item>
+        <item>lib/readline/misc.c</item>
+        <item>lib/readline/history.c</item>
+        <item>lib/readline/histexpand.c</item>
+        <item>lib/readline/histfile.c</item>
+        <item>lib/readline/histsearch.c</item>
+        <item>lib/readline/savestring.c</item>
+        <item>lib/readline/mbutil.c</item>
+        <item>lib/readline/tilde.c</item>
+        <item>lib/readline/compat.c</item>
+    </array>
+
+    <target name="clean">
+        <delete>objs/builtins/*</delete>
+        <rmdir>objs/builtins</rmdir>
+        <delete>objs/readline/*</delete>
+        <rmdir>objs/readline</rmdir>
+        <delete>objs/*</delete>
+        <rmdir>objs</rmdir>
+    </target>
+
+    <target name="prepare" type="private">
+        <mkdir>objs</mkdir>
+        <mkdir>objs/readline</mkdir>
+        <mkdir>objs/builtins</mkdir>
+    </target>
+
+    <target name="compile">
+        <call target="prepare"/>
+
+        <echo>Compiling bash 4.0</echo>
+
+        <for var="i" array="${files}">
+            <echo>-> ${i}</echo>
+            <gcc>
+                <input>${i}</input>
+                <output>objs/filename(${i}).o</output>
+                <include>../../../include</include>
+                <include>../../../../build/crosscompiler/lib/gcc/i686-pc-yaosp/4.3.3/include</include>
+                <include>./</include>
+                <include>./include</include>
+                <include>./lib</include>
+                <flag>-c</flag>
+                <flag>-O2</flag>
+                <flag>-m32</flag>
+                <flag>-Wall</flag>
+                <flag>-nostdinc</flag>
+                <flag>-nostdlib</flag>
+                <flag>-fno-builtin</flag>
+                <flag>-fno-strict-aliasing</flag>
+                <define key="HAVE_CONFIG_H"/>
+                <define key="SHELL"/>
+                <define key="_POSIX_VERSION"/>
+                <define key="CONF_MACHTYPE">"i686-pc-yaosp"</define>
+                <define key="CONF_HOSTTYPE">"i386"</define>
+                <define key="CONF_OSTYPE">"yaosp"</define>
+                <define key="LOCALEDIR">"/yaosp/system/locale"</define>
+                <define key="PACKAGE">"bash"</define>
+                <define key="MUST_UNBLOCK_CHLD"/>
+            </gcc>
+        </for>
+
+        <for var="i" array="${files_builtins}">
+            <echo>-> ${i}</echo>
+            <gcc>
+                <input>${i}</input>
+                <output>objs/builtins/filename(${i}).o</output>
+                <include>../../../include</include>
+                <include>../../../../build/crosscompiler/lib/gcc/i686-pc-yaosp/4.3.3/include</include>
+                <include>./</include>
+                <include>./include</include>
+                <include>./lib</include>
+                <flag>-c</flag>
+                <flag>-O2</flag>
+                <flag>-m32</flag>
+                <flag>-Wall</flag>
+                <flag>-nostdinc</flag>
+                <flag>-nostdlib</flag>
+                <flag>-fno-builtin</flag>
+                <flag>-fno-strict-aliasing</flag>
+                <define key="HAVE_CONFIG_H"/>
+                <define key="SHELL"/>
+                <define key="_POSIX_VERSION"/>
+                <define key="CONF_MACHTYPE">"i686-pc-yaosp"</define>
+                <define key="CONF_HOSTTYPE">"i386"</define>
+                <define key="CONF_OSTYPE">"yaosp"</define>
+                <define key="LOCALEDIR">"/yaosp/system/locale"</define>
+                <define key="PACKAGE">"bash"</define>
+            </gcc>
+        </for>
+
+        <for var="i" array="${files_readline}">
+            <echo>-> ${i}</echo>
+            <gcc>
+                <input>${i}</input>
+                <output>objs/readline/filename(${i}).o</output>
+                <include>../../../include</include>
+                <include>../../../../build/crosscompiler/lib/gcc/i686-pc-yaosp/4.3.3/include</include>
+                <include>./</include>
+                <include>./include</include>
+                <include>./lib</include>
+                <flag>-c</flag>
+                <flag>-O2</flag>
+                <flag>-m32</flag>
+                <flag>-Wall</flag>
+                <flag>-nostdinc</flag>
+                <flag>-nostdlib</flag>
+                <flag>-fno-builtin</flag>
+                <flag>-fno-strict-aliasing</flag>
+                <define key="HAVE_CONFIG_H"/>
+                <define key="SHELL"/>
+                <define key="_POSIX_VERSION"/>
+                <define key="CONF_MACHTYPE">"i686-pc-yaosp"</define>
+                <define key="CONF_HOSTTYPE">"i386"</define>
+                <define key="CONF_OSTYPE">"yaosp"</define>
+                <define key="LOCALEDIR">"/yaosp/system/locale"</define>
+                <define key="PACKAGE">"bash"</define>
+            </gcc>
+        </for>
+
+        <echo>Linking bash 4.0</echo>
+        <echo>-> objs/bash</echo>
+
+        <gcc>
+            <input>objs/*.o</input>
+            <input>objs/builtins/*.o</input>
+            <input>objs/readline/*.o</input>
+            <input>../../../lib/start/objs/libstart.a</input>
+            <input>../../../thirdparty/ncurses-5.7/ncurses-5.7/objs/libncurses.a</input>
+            <input>../../../lib/c/objs/libc.a</input>
+            <output>objs/bash</output>
+            <flag>-m32</flag>
+            <flag>-Xlinker</flag>
+            <flag>--script=../../../../scripts/i386_app.lnk</flag>
+            <flag>-nostartfiles</flag>
+            <flag>-nodefaultlibs</flag>
+        </gcc>
+    </target>
+
+    <target name="install">
+        <echo>Installing bash binary</echo>
+
+        <copy from="objs/bash" to="../../../../build/image/application/bash"/>
+    </target>
+
+    <target name="all">
+        <call target="clean"/>
+        <call target="compile"/>
+        <call target="install"/>
+    </target>
+</build>
diff -Nru bash-4.0-orig/pcomplete.c bash-4.0/pcomplete.c
--- bash-4.0-orig/pcomplete.c	2009-02-01 23:12:31.000000000 +0100
+++ bash-4.0/pcomplete.c	2009-12-08 18:06:16.000000000 +0100
@@ -1032,6 +1032,7 @@
   cmdlist = build_arg_list (funcname, text, lwords, cw);
 
   pps = &ps;
+  save_parser_state (pps);
   begin_unwind_frame ("gen-shell-function-matches");
   add_unwind_protect (restore_parser_state, (char *)pps);
   add_unwind_protect (dispose_words, (char *)cmdlist);
@@ -1174,13 +1175,15 @@
 {
   WORD_LIST *ret;
   char *delims;
+  int i, j;
 
-#if 0
-  delims = "()<>;&| \t\n";	/* shell metacharacters break words */
-#else
-  delims = rl_completer_word_break_characters;
-#endif
+  delims = xmalloc (strlen (rl_completer_word_break_characters) + 1);
+  for (i = j = 0; rl_completer_word_break_characters[i]; i++)
+    if (rl_completer_word_break_characters[i] != '\'' && rl_completer_word_break_characters[i] != '"')
+      delims[j++] = rl_completer_word_break_characters[i];
+  delims[j] = '\0';
   ret = split_at_delims (line, llen, delims, sentinel, nwp, cwp);
+  free (delims);
   return (ret);
 }
 
diff -Nru bash-4.0-orig/shell.c bash-4.0/shell.c
--- bash-4.0-orig/shell.c	2009-01-04 20:32:41.000000000 +0100
+++ bash-4.0/shell.c	2009-12-08 18:04:03.000000000 +0100
@@ -191,7 +191,7 @@
 #endif
 
 /* The name of the .(shell)rc file. */
-static char *bashrc_file = "~/.bashrc";
+static char *bashrc_file = "/yaosp/system/config/bashrc";
 
 /* Non-zero means to act more like the Bourne shell on startup. */
 static int act_like_sh;
@@ -823,7 +823,7 @@
 
       i = 1;
       on_or_off = arg_string[0];
-      while (arg_character = arg_string[i++])
+      while ( ( arg_character = arg_string[i++] ) )
 	{
 	  switch (arg_character)
 	    {
@@ -1551,7 +1551,7 @@
     }
 #endif /* !BUFFERED_INPUT */
 }
-      
+
 
 #if !defined (PROGRAM)
 #  define PROGRAM "bash"
diff -Nru bash-4.0-orig/sig.c bash-4.0/sig.c
--- bash-4.0-orig/sig.c	2009-01-04 20:32:41.000000000 +0100
+++ bash-4.0/sig.c	2009-12-08 18:04:03.000000000 +0100
@@ -448,6 +448,48 @@
 termsig_sighandler (sig)
      int sig;
 {
+  /* If we get called twice with the same signal before handling it,
+     terminate right away. */
+  if (
+#ifdef SIGHUP
+    sig != SIGHUP &&
+#endif
+#ifdef SIGINT
+    sig != SIGINT &&
+#endif
+#ifdef SIGDANGER
+    sig != SIGDANGER &&
+#endif
+#ifdef SIGPIPE
+    sig != SIGPIPE &&
+#endif
+#ifdef SIGALRM
+    sig != SIGALRM &&
+#endif
+#ifdef SIGTERM
+    sig != SIGTERM &&
+#endif
+#ifdef SIGXCPU
+    sig != SIGXCPU &&
+#endif
+#ifdef SIGXFSZ
+    sig != SIGXFSZ &&
+#endif
+#ifdef SIGVTALRM
+    sig != SIGVTALRM &&
+#endif
+#ifdef SIGLOST
+    sig != SIGLOST &&
+#endif
+#ifdef SIGUSR1
+    sig != SIGUSR1 &&
+#endif
+#ifdef SIGUSR2
+   sig != SIGUSR2 &&
+#endif
+   sig == terminating_signal)
+    terminate_immediately = 1;
+
   terminating_signal = sig;
 
   /* XXX - should this also trigger when interrupt_immediately is set? */
diff -Nru bash-4.0-orig/signames.h bash-4.0/signames.h
--- bash-4.0-orig/signames.h	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/signames.h	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,78 @@
+/* This file was automatically created by ./mksignames.
+   Do not edit.  Edit support/signames.c instead. */
+
+/* A translation list so we can be polite to our users. */
+char *signal_names[NSIG + 4] = {
+    "EXIT",
+    "SIGHUP",
+    "SIGINT",
+    "SIGQUIT",
+    "SIGILL",
+    "SIGTRAP",
+    "SIGABRT",
+    "SIGBUS",
+    "SIGFPE",
+    "SIGKILL",
+    "SIGUSR1",
+    "SIGSEGV",
+    "SIGUSR2",
+    "SIGPIPE",
+    "SIGALRM",
+    "SIGTERM",
+    "SIGSTKFLT",
+    "SIGCHLD",
+    "SIGCONT",
+    "SIGSTOP",
+    "SIGTSTP",
+    "SIGTTIN",
+    "SIGTTOU",
+    "SIGURG",
+    "SIGXCPU",
+    "SIGXFSZ",
+    "SIGVTALRM",
+    "SIGPROF",
+    "SIGWINCH",
+    "SIGIO",
+    "SIGPWR",
+    "SIGSYS",
+    "SIGJUNK(32)",
+    "SIGJUNK(33)",
+    "SIGRTMIN",
+    "SIGRTMIN+1",
+    "SIGRTMIN+2",
+    "SIGRTMIN+3",
+    "SIGRTMIN+4",
+    "SIGRTMIN+5",
+    "SIGRTMIN+6",
+    "SIGRTMIN+7",
+    "SIGRTMIN+8",
+    "SIGRTMIN+9",
+    "SIGRTMIN+10",
+    "SIGRTMIN+11",
+    "SIGRTMIN+12",
+    "SIGRTMIN+13",
+    "SIGRTMIN+14",
+    "SIGRTMIN+15",
+    "SIGRTMAX-14",
+    "SIGRTMAX-13",
+    "SIGRTMAX-12",
+    "SIGRTMAX-11",
+    "SIGRTMAX-10",
+    "SIGRTMAX-9",
+    "SIGRTMAX-8",
+    "SIGRTMAX-7",
+    "SIGRTMAX-6",
+    "SIGRTMAX-5",
+    "SIGRTMAX-4",
+    "SIGRTMAX-3",
+    "SIGRTMAX-2",
+    "SIGRTMAX-1",
+    "SIGRTMAX",
+    "DEBUG",
+    "ERR",
+    "RETURN",
+    (char *)0x0
+};
+
+#define initialize_signames()
+
diff -Nru bash-4.0-orig/subst.c bash-4.0/subst.c
--- bash-4.0-orig/subst.c	2009-01-28 20:34:12.000000000 +0100
+++ bash-4.0/subst.c	2009-12-08 18:04:03.000000000 +0100
@@ -85,6 +85,7 @@
 
 /* Flags for the `pflags' argument to param_expand() */
 #define PF_NOCOMSUB	0x01	/* Do not perform command substitution */
+#define PF_IGNUNBOUND	0x02	/* ignore unbound vars even if -u set */
 
 /* These defs make it easier to use the editor. */
 #define LBRACE		'{'
@@ -222,6 +223,7 @@
 static int skip_double_quoted __P((char *, size_t, int));
 static char *extract_delimited_string __P((char *, int *, char *, char *, char *, int));
 static char *extract_dollar_brace_string __P((char *, int *, int, int));
+static int skip_matched_pair __P((const char *, int, int, int, int));
 
 static char *pos_params __P((char *, int, int, int));
 
@@ -262,7 +264,7 @@
 static int chk_atstar __P((char *, int, int *, int *));
 static int chk_arithsub __P((const char *, int));
 
-static WORD_DESC *parameter_brace_expand_word __P((char *, int, int));
+static WORD_DESC *parameter_brace_expand_word __P((char *, int, int, int));
 static WORD_DESC *parameter_brace_expand_indir __P((char *, int, int, int *, int *));
 static WORD_DESC *parameter_brace_expand_rhs __P((char *, char *, int, int, int *, int *));
 static void parameter_brace_expand_error __P((char *, char *));
@@ -1374,6 +1376,107 @@
 
 #define CQ_RETURN(x) do { no_longjmp_on_fatal_error = 0; return (x); } while (0)
 
+/* This function assumes s[i] == open; returns with s[ret] == close; used to
+   parse array subscripts.  FLAGS currently unused. */
+static int
+skip_matched_pair (string, start, open, close, flags)
+     const char *string;
+     int start, open, close, flags;
+{
+  int i, pass_next, backq, si, c, count;
+  size_t slen;
+  char *temp, *ss;
+  DECLARE_MBSTATE;
+
+  slen = strlen (string + start) + start;
+  no_longjmp_on_fatal_error = 1;
+
+  i = start + 1;		/* skip over leading bracket */
+  count = 1;
+  pass_next = backq = 0;
+  ss = (char *)string;
+  while (c = string[i])
+    {
+      if (pass_next)
+	{
+	  pass_next = 0;
+	  if (c == 0)
+	    CQ_RETURN(i);
+	  ADVANCE_CHAR (string, slen, i);
+	  continue;
+	}
+      else if (c == '\\')
+	{
+	  pass_next = 1;
+	  i++;
+	  continue;
+	}
+      else if (backq)
+	{
+	  if (c == '`')
+	    backq = 0;
+	  ADVANCE_CHAR (string, slen, i);
+	  continue;
+	}
+      else if (c == '`')
+	{
+	  backq = 1;
+	  i++;
+	  continue;
+	}
+      else if (c == open)
+	{
+	  count++;
+	  i++;
+	  continue;
+	}
+      else if (c == close)
+	{
+	  count--;
+	  if (count == 0)
+	    break;
+	  i++;
+	  continue;
+	}
+      else if (c == '\'' || c == '"')
+	{
+	  i = (c == '\'') ? skip_single_quoted (ss, slen, ++i)
+			  : skip_double_quoted (ss, slen, ++i);
+	  /* no increment, the skip functions increment past the closing quote. */
+	}
+      else if (c == '$' && (string[i+1] == LPAREN || string[i+1] == LBRACE))
+	{
+	  si = i + 2;
+	  if (string[si] == '\0')
+	    CQ_RETURN(si);
+
+	  if (string[i+1] == LPAREN)
+	    temp = extract_delimited_string (ss, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
+	  else
+	    temp = extract_dollar_brace_string (ss, &si, 0, SX_NOALLOC);
+	  i = si;
+	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
+	    break;
+	  i++;
+	  continue;
+	}
+      else
+	ADVANCE_CHAR (string, slen, i);
+    }
+
+  CQ_RETURN(i);
+}
+
+#if defined (ARRAY_VARS)
+int
+skipsubscript (string, start)
+     const char *string;
+     int start;
+{
+  return (skip_matched_pair (string, start, '[', ']', 0));
+}
+#endif
+
 /* Skip characters in STRING until we find a character in DELIMS, and return
    the index of that character.  START is the index into string at which we
    begin.  This is similar in spirit to strpbrk, but it returns an index into
@@ -5093,9 +5196,9 @@
    the shell, e.g., "@", "$", "*", etc.  QUOTED, if non-zero, means that
    NAME was found inside of a double-quoted expression. */
 static WORD_DESC *
-parameter_brace_expand_word (name, var_is_special, quoted)
+parameter_brace_expand_word (name, var_is_special, quoted, pflags)
      char *name;
-     int var_is_special, quoted;
+     int var_is_special, quoted, pflags;
 {
   WORD_DESC *ret;
   char *temp, *tt;
@@ -5127,7 +5230,7 @@
       strcpy (tt + 1, name);
 
       ret = param_expand (tt, &sindex, quoted, (int *)NULL, (int *)NULL,
-			  (int *)NULL, (int *)NULL, 0);
+			  (int *)NULL, (int *)NULL, pflags);
       free (tt);
     }
 #if defined (ARRAY_VARS)
@@ -5188,7 +5291,7 @@
   char *temp, *t;
   WORD_DESC *w;
 
-  w = parameter_brace_expand_word (name, var_is_special, quoted);
+  w = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND);
   t = w->word;
   /* Have to dequote here if necessary */
   if (t)
@@ -5205,7 +5308,7 @@
   if (t == 0)
     return (WORD_DESC *)NULL;
 
-  w = parameter_brace_expand_word (t, SPECIAL_VAR(t, 0), quoted);
+  w = parameter_brace_expand_word (t, SPECIAL_VAR(t, 0), quoted, 0);
   free (t);
 
   return w;
@@ -6503,7 +6606,7 @@
 	    *contains_dollar_at = 1;
 	}
       free (x);
-      free (xlist);
+      dispose_words (xlist);
       free (temp1);
       *indexp = sindex;
 
@@ -6556,7 +6659,7 @@
   if (want_indir)
     tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, quoted_dollar_atp, contains_dollar_at);
   else
-    tdesc = parameter_brace_expand_word (name, var_is_special, quoted);
+    tdesc = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND);
 
   if (tdesc)
     {
@@ -6664,13 +6767,13 @@
       return &expand_wdesc_error;
 
     case RBRACE:
-      if (var_is_set == 0 && unbound_vars_is_error)
+      if (var_is_set == 0 && unbound_vars_is_error && ((name[0] != '@' && name[0] != '*') || name[1]))
 	{
+	  last_command_exit_value = EXECUTION_FAILURE;
 	  err_unboundvar (name);
 	  FREE (value);
 	  FREE (temp);
 	  free (name);
-	  last_command_exit_value = EXECUTION_FAILURE;
 	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
 	}
       break;
@@ -6887,15 +6990,25 @@
     case '*':		/* `$*' */
       list = list_rest_of_args ();
 
-      if (list == 0 && unbound_vars_is_error)
+#if 0
+      /* According to austin-group posix proposal by Geoff Clare in
+	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:
+
+ 	"The shell shall write a message to standard error and
+ 	 immediately exit when it tries to expand an unset parameter
+ 	 other than the '@' and '*' special parameters."
+      */
+
+      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
 	{
 	  uerror[0] = '$';
 	  uerror[1] = '*';
 	  uerror[2] = '\0';
-	  err_unboundvar (uerror);
 	  last_command_exit_value = EXECUTION_FAILURE;
+	  err_unboundvar (uerror);
 	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
 	}
+#endif
 
       /* If there are no command-line arguments, this should just
 	 disappear if there are other characters in the expansion,
@@ -6949,15 +7062,25 @@
     case '@':		/* `$@' */
       list = list_rest_of_args ();
 
-      if (list == 0 && unbound_vars_is_error)
+#if 0
+      /* According to austin-group posix proposal by Geoff Clare in
+	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:
+
+ 	"The shell shall write a message to standard error and
+ 	 immediately exit when it tries to expand an unset parameter
+ 	 other than the '@' and '*' special parameters."
+      */
+
+      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
 	{
 	  uerror[0] = '$';
 	  uerror[1] = '@';
 	  uerror[2] = '\0';
-	  err_unboundvar (uerror);
 	  last_command_exit_value = EXECUTION_FAILURE;
+	  err_unboundvar (uerror);
 	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
 	}
+#endif
 
       /* We want to flag the fact that we saw this.  We can't turn
 	 off quoting entirely, because other characters in the
diff -Nru bash-4.0-orig/syntax.c bash-4.0/syntax.c
--- bash-4.0-orig/syntax.c	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/syntax.c	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,269 @@
+/*
+ * This file was generated by mksyntax.  DO NOT EDIT.
+ */
+
+
+#include "config.h"
+#include "stdc.h"
+#include "syntax.h"
+
+
+int sh_syntabsiz = 256;
+int sh_syntaxtab[256] = {
+	CWORD,		/* 0 */
+	CSPECL,		/* CTLESC */
+	CWORD,		/* 2 */
+	CWORD,		/* 3 */
+	CWORD,		/* 4 */
+	CWORD,		/* 5 */
+	CWORD,		/* 6 */
+	CWORD,		/* \a */
+	CWORD,		/* \b */
+	CSHBRK|CBLANK,		/* \t */
+	CSHBRK|CBSDQUOTE,		/* \n */
+	CWORD,		/* \v */
+	CWORD,		/* \f */
+	CWORD,		/* \r */
+	CWORD,		/* 14 */
+	CWORD,		/* 15 */
+	CWORD,		/* 16 */
+	CWORD,		/* 17 */
+	CWORD,		/* 18 */
+	CWORD,		/* 19 */
+	CWORD,		/* 20 */
+	CWORD,		/* 21 */
+	CWORD,		/* 22 */
+	CWORD,		/* 23 */
+	CWORD,		/* 24 */
+	CWORD,		/* 25 */
+	CWORD,		/* 26 */
+	CWORD,		/* ESC */
+	CWORD,		/* 28 */
+	CWORD,		/* 29 */
+	CWORD,		/* 30 */
+	CWORD,		/* 31 */
+	CSHBRK|CBLANK,		/* SPC */
+	CXGLOB|CSPECVAR,		/* ! */
+	CQUOTE|CBSDQUOTE|CXQUOTE,		/* " */
+	CSPECVAR,		/* # */
+	CEXP|CBSDQUOTE|CBSHDOC|CSPECVAR,		/* $ */
+	CWORD,		/* % */
+	CSHMETA|CSHBRK,		/* & */
+	CQUOTE|CXQUOTE,		/* ' */
+	CSHMETA|CSHBRK,		/* ( */
+	CSHMETA|CSHBRK,		/* ) */
+	CGLOB|CXGLOB|CSPECVAR,		/* * */
+	CXGLOB|CSUBSTOP,		/* + */
+	CWORD,		/* , */
+	CSPECVAR|CSUBSTOP,		/* - */
+	CWORD,		/* . */
+	CWORD,		/* / */
+	CWORD,		/* 0 */
+	CWORD,		/* 1 */
+	CWORD,		/* 2 */
+	CWORD,		/* 3 */
+	CWORD,		/* 4 */
+	CWORD,		/* 5 */
+	CWORD,		/* 6 */
+	CWORD,		/* 7 */
+	CWORD,		/* 8 */
+	CWORD,		/* 9 */
+	CWORD,		/* : */
+	CSHMETA|CSHBRK,		/* ; */
+	CSHMETA|CSHBRK|CEXP,		/* < */
+	CSUBSTOP,		/* = */
+	CSHMETA|CSHBRK|CEXP,		/* > */
+	CGLOB|CXGLOB|CSPECVAR|CSUBSTOP,		/* ? */
+	CXGLOB|CSPECVAR,		/* @ */
+	CWORD,		/* A */
+	CWORD,		/* B */
+	CWORD,		/* C */
+	CWORD,		/* D */
+	CWORD,		/* E */
+	CWORD,		/* F */
+	CWORD,		/* G */
+	CWORD,		/* H */
+	CWORD,		/* I */
+	CWORD,		/* J */
+	CWORD,		/* K */
+	CWORD,		/* L */
+	CWORD,		/* M */
+	CWORD,		/* N */
+	CWORD,		/* O */
+	CWORD,		/* P */
+	CWORD,		/* Q */
+	CWORD,		/* R */
+	CWORD,		/* S */
+	CWORD,		/* T */
+	CWORD,		/* U */
+	CWORD,		/* V */
+	CWORD,		/* W */
+	CWORD,		/* X */
+	CWORD,		/* Y */
+	CWORD,		/* Z */
+	CGLOB,		/* [ */
+	CBSDQUOTE|CBSHDOC|CXQUOTE,		/* \ */
+	CGLOB,		/* ] */
+	CGLOB,		/* ^ */
+	CWORD,		/* _ */
+	CBACKQ|CQUOTE|CBSDQUOTE|CBSHDOC|CXQUOTE,		/* ` */
+	CWORD,		/* a */
+	CWORD,		/* b */
+	CWORD,		/* c */
+	CWORD,		/* d */
+	CWORD,		/* e */
+	CWORD,		/* f */
+	CWORD,		/* g */
+	CWORD,		/* h */
+	CWORD,		/* i */
+	CWORD,		/* j */
+	CWORD,		/* k */
+	CWORD,		/* l */
+	CWORD,		/* m */
+	CWORD,		/* n */
+	CWORD,		/* o */
+	CWORD,		/* p */
+	CWORD,		/* q */
+	CWORD,		/* r */
+	CWORD,		/* s */
+	CWORD,		/* t */
+	CWORD,		/* u */
+	CWORD,		/* v */
+	CWORD,		/* w */
+	CWORD,		/* x */
+	CWORD,		/* y */
+	CWORD,		/* z */
+	CWORD,		/* { */
+	CSHMETA|CSHBRK,		/* | */
+	CWORD,		/* } */
+	CWORD,		/* ~ */
+	CSPECL,		/* CTLNUL */
+	CWORD,		/* 128 */
+	CWORD,		/* 129 */
+	CWORD,		/* 130 */
+	CWORD,		/* 131 */
+	CWORD,		/* 132 */
+	CWORD,		/* 133 */
+	CWORD,		/* 134 */
+	CWORD,		/* 135 */
+	CWORD,		/* 136 */
+	CWORD,		/* 137 */
+	CWORD,		/* 138 */
+	CWORD,		/* 139 */
+	CWORD,		/* 140 */
+	CWORD,		/* 141 */
+	CWORD,		/* 142 */
+	CWORD,		/* 143 */
+	CWORD,		/* 144 */
+	CWORD,		/* 145 */
+	CWORD,		/* 146 */
+	CWORD,		/* 147 */
+	CWORD,		/* 148 */
+	CWORD,		/* 149 */
+	CWORD,		/* 150 */
+	CWORD,		/* 151 */
+	CWORD,		/* 152 */
+	CWORD,		/* 153 */
+	CWORD,		/* 154 */
+	CWORD,		/* 155 */
+	CWORD,		/* 156 */
+	CWORD,		/* 157 */
+	CWORD,		/* 158 */
+	CWORD,		/* 159 */
+	CWORD,		/* 160 */
+	CWORD,		/* 161 */
+	CWORD,		/* 162 */
+	CWORD,		/* 163 */
+	CWORD,		/* 164 */
+	CWORD,		/* 165 */
+	CWORD,		/* 166 */
+	CWORD,		/* 167 */
+	CWORD,		/* 168 */
+	CWORD,		/* 169 */
+	CWORD,		/* 170 */
+	CWORD,		/* 171 */
+	CWORD,		/* 172 */
+	CWORD,		/* 173 */
+	CWORD,		/* 174 */
+	CWORD,		/* 175 */
+	CWORD,		/* 176 */
+	CWORD,		/* 177 */
+	CWORD,		/* 178 */
+	CWORD,		/* 179 */
+	CWORD,		/* 180 */
+	CWORD,		/* 181 */
+	CWORD,		/* 182 */
+	CWORD,		/* 183 */
+	CWORD,		/* 184 */
+	CWORD,		/* 185 */
+	CWORD,		/* 186 */
+	CWORD,		/* 187 */
+	CWORD,		/* 188 */
+	CWORD,		/* 189 */
+	CWORD,		/* 190 */
+	CWORD,		/* 191 */
+	CWORD,		/* 192 */
+	CWORD,		/* 193 */
+	CWORD,		/* 194 */
+	CWORD,		/* 195 */
+	CWORD,		/* 196 */
+	CWORD,		/* 197 */
+	CWORD,		/* 198 */
+	CWORD,		/* 199 */
+	CWORD,		/* 200 */
+	CWORD,		/* 201 */
+	CWORD,		/* 202 */
+	CWORD,		/* 203 */
+	CWORD,		/* 204 */
+	CWORD,		/* 205 */
+	CWORD,		/* 206 */
+	CWORD,		/* 207 */
+	CWORD,		/* 208 */
+	CWORD,		/* 209 */
+	CWORD,		/* 210 */
+	CWORD,		/* 211 */
+	CWORD,		/* 212 */
+	CWORD,		/* 213 */
+	CWORD,		/* 214 */
+	CWORD,		/* 215 */
+	CWORD,		/* 216 */
+	CWORD,		/* 217 */
+	CWORD,		/* 218 */
+	CWORD,		/* 219 */
+	CWORD,		/* 220 */
+	CWORD,		/* 221 */
+	CWORD,		/* 222 */
+	CWORD,		/* 223 */
+	CWORD,		/* 224 */
+	CWORD,		/* 225 */
+	CWORD,		/* 226 */
+	CWORD,		/* 227 */
+	CWORD,		/* 228 */
+	CWORD,		/* 229 */
+	CWORD,		/* 230 */
+	CWORD,		/* 231 */
+	CWORD,		/* 232 */
+	CWORD,		/* 233 */
+	CWORD,		/* 234 */
+	CWORD,		/* 235 */
+	CWORD,		/* 236 */
+	CWORD,		/* 237 */
+	CWORD,		/* 238 */
+	CWORD,		/* 239 */
+	CWORD,		/* 240 */
+	CWORD,		/* 241 */
+	CWORD,		/* 242 */
+	CWORD,		/* 243 */
+	CWORD,		/* 244 */
+	CWORD,		/* 245 */
+	CWORD,		/* 246 */
+	CWORD,		/* 247 */
+	CWORD,		/* 248 */
+	CWORD,		/* 249 */
+	CWORD,		/* 250 */
+	CWORD,		/* 251 */
+	CWORD,		/* 252 */
+	CWORD,		/* 253 */
+	CWORD,		/* 254 */
+	CWORD,		/* 255 */
+};
diff -Nru bash-4.0-orig/trap.c bash-4.0/trap.c
--- bash-4.0-orig/trap.c	2009-01-16 23:07:53.000000000 +0100
+++ bash-4.0/trap.c	2009-12-08 18:04:03.000000000 +0100
@@ -755,7 +755,7 @@
 	}
 
       flags = SEVAL_NONINT|SEVAL_NOHIST;
-      if (sig != DEBUG_TRAP && sig != RETURN_TRAP)
+      if (sig != DEBUG_TRAP && sig != RETURN_TRAP && sig != ERROR_TRAP)
 	flags |= SEVAL_RESETLINE;
       if (function_code == 0)
 	parse_and_execute (trap_command, tag, flags);
@@ -798,12 +798,36 @@
 run_debug_trap ()
 {
   int trap_exit_value;
+  pid_t save_pgrp;
+  int save_pipe[2];
 
   /* XXX - question:  should the DEBUG trap inherit the RETURN trap? */
   trap_exit_value = 0;
   if ((sigmodes[DEBUG_TRAP] & SIG_TRAPPED) && ((sigmodes[DEBUG_TRAP] & SIG_IGNORED) == 0) && ((sigmodes[DEBUG_TRAP] & SIG_INPROGRESS) == 0))
     {
+#if defined (JOB_CONTROL)
+      save_pgrp = pipeline_pgrp;
+      pipeline_pgrp = 0;
+      save_pipeline (1);
+#  if defined (PGRP_PIPE)
+      save_pgrp_pipe (save_pipe, 1);
+#  endif
+      stop_making_children ();
+#endif
+
       trap_exit_value = _run_trap_internal (DEBUG_TRAP, "debug trap");
+
+#if defined (JOB_CONTROL)
+      pipeline_pgrp = save_pgrp;
+      restore_pipeline (1);
+#  if defined (PGRP_PIPE)
+      close_pgrp_pipe ();
+      restore_pgrp_pipe (save_pipe);
+#  endif
+      if (pipeline_pgrp > 0)
+	give_terminal_to (pipeline_pgrp, 1);
+      notify_and_cleanup ();
+#endif
       
 #if defined (DEBUGGER)
       /* If we're in the debugger and the DEBUG trap returns 2 while we're in
diff -Nru bash-4.0-orig/variables.c bash-4.0/variables.c
--- bash-4.0-orig/variables.c	2009-01-04 20:32:46.000000000 +0100
+++ bash-4.0/variables.c	2009-12-08 18:04:03.000000000 +0100
@@ -252,6 +252,7 @@
 
 static int visible_var __P((SHELL_VAR *));
 static int visible_and_exported __P((SHELL_VAR *));
+static int export_environment_candidate __P((SHELL_VAR *));
 static int local_and_exported __P((SHELL_VAR *));
 static int variable_in_context __P((SHELL_VAR *));
 #if defined (ARRAY_VARS)
@@ -375,10 +376,17 @@
 	}
 #  endif
 #endif
+#if 0
       else if (legal_identifier (name))
+#else
+      else
+#endif
 	{
 	  temp_var = bind_variable (name, string, 0);
-	  VSETATTR (temp_var, (att_exported | att_imported));
+	  if (legal_identifier (name))
+	    VSETATTR (temp_var, (att_exported | att_imported));
+	  else
+	    VSETATTR (temp_var, (att_exported | att_imported | att_invisible));
 	  array_needs_making = 1;
 	}
 
@@ -2209,7 +2217,7 @@
 	}
       else if (assoc_p (entry))
 	{
-	  assoc_insert (assoc_cell (entry), "0", newval);
+	  assoc_insert (assoc_cell (entry), savestring ("0"), newval);
 	  free (newval);
 	}
       else
@@ -3082,6 +3090,16 @@
   return (invisible_p (var) == 0 && exported_p (var));
 }
 
+/* Candidate variables for the export environment are either valid variables
+   with the export attribute or invalid variables inherited from the initial
+   environment and simply passed through. */
+static int
+export_environment_candidate (var)
+     SHELL_VAR *var;
+{
+  return (exported_p (var) && (invisible_p (var) == 0 || imported_p (var)));
+}
+
 /* Return non-zero if VAR is a local variable in the current context and
    is exported. */
 static int
@@ -3438,7 +3456,11 @@
   char **list;
   SHELL_VAR **vars;
 
+#if 0
   vars = map_over (visible_and_exported, vcxt);
+#else
+  vars = map_over (export_environment_candidate, vcxt);
+#endif
 
   if (vars == 0)
     return (char **)NULL;
diff -Nru bash-4.0-orig/version.h bash-4.0/version.h
--- bash-4.0-orig/version.h	1970-01-01 01:00:00.000000000 +0100
+++ bash-4.0/version.h	2009-12-08 18:04:03.000000000 +0100
@@ -0,0 +1,17 @@
+/* Version control for the shell.  This file gets changed when you say
+   `make version.h' to the Makefile.  It is created by mkversion. */
+
+/* The distribution version number of this shell. */
+#define DISTVERSION "4.0"
+
+/* The last built version of this shell. */
+#define BUILDVERSION 1
+
+/* The release status of this shell. */
+#define RELSTATUS "release"
+
+/* The default shell compatibility-level (the current version) */
+#define DEFAULT_COMPAT_LEVEL 40
+
+/* A version string for use by sccs and the what command. */
+#define SCCSVERSION "@(#)Bash version 4.0.0(1) release GNU"
diff -Nru bash-4.0-orig/y.tab.c bash-4.0/y.tab.c
--- bash-4.0-orig/y.tab.c	2009-01-08 15:30:24.000000000 +0100
+++ bash-4.0/y.tab.c	2009-12-08 18:04:03.000000000 +0100
@@ -1,24 +1,23 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton implementation for Bison's Yacc-like parsers in C
+/* A Bison parser, made by GNU Bison 2.4.1.  */
 
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
    Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
+   
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -29,7 +28,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
@@ -47,7 +46,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.3"
+#define YYBISON_VERSION "2.4.1"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -55,116 +54,21 @@
 /* Pure parsers.  */
 #define YYPURE 0
 
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
+/* Push parsers.  */
+#define YYPUSH 0
 
+/* Pull parsers.  */
+#define YYPULL 1
 
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     IF = 258,
-     THEN = 259,
-     ELSE = 260,
-     ELIF = 261,
-     FI = 262,
-     CASE = 263,
-     ESAC = 264,
-     FOR = 265,
-     SELECT = 266,
-     WHILE = 267,
-     UNTIL = 268,
-     DO = 269,
-     DONE = 270,
-     FUNCTION = 271,
-     COPROC = 272,
-     COND_START = 273,
-     COND_END = 274,
-     COND_ERROR = 275,
-     IN = 276,
-     BANG = 277,
-     TIME = 278,
-     TIMEOPT = 279,
-     WORD = 280,
-     ASSIGNMENT_WORD = 281,
-     NUMBER = 282,
-     ARITH_CMD = 283,
-     ARITH_FOR_EXPRS = 284,
-     COND_CMD = 285,
-     AND_AND = 286,
-     OR_OR = 287,
-     GREATER_GREATER = 288,
-     LESS_LESS = 289,
-     LESS_AND = 290,
-     LESS_LESS_LESS = 291,
-     GREATER_AND = 292,
-     SEMI_SEMI = 293,
-     SEMI_AND = 294,
-     SEMI_SEMI_AND = 295,
-     LESS_LESS_MINUS = 296,
-     AND_GREATER = 297,
-     AND_GREATER_GREATER = 298,
-     LESS_GREATER = 299,
-     GREATER_BAR = 300,
-     BAR_AND = 301,
-     yacc_EOF = 302
-   };
-#endif
-/* Tokens.  */
-#define IF 258
-#define THEN 259
-#define ELSE 260
-#define ELIF 261
-#define FI 262
-#define CASE 263
-#define ESAC 264
-#define FOR 265
-#define SELECT 266
-#define WHILE 267
-#define UNTIL 268
-#define DO 269
-#define DONE 270
-#define FUNCTION 271
-#define COPROC 272
-#define COND_START 273
-#define COND_END 274
-#define COND_ERROR 275
-#define IN 276
-#define BANG 277
-#define TIME 278
-#define TIMEOPT 279
-#define WORD 280
-#define ASSIGNMENT_WORD 281
-#define NUMBER 282
-#define ARITH_CMD 283
-#define ARITH_FOR_EXPRS 284
-#define COND_CMD 285
-#define AND_AND 286
-#define OR_OR 287
-#define GREATER_GREATER 288
-#define LESS_LESS 289
-#define LESS_AND 290
-#define LESS_LESS_LESS 291
-#define GREATER_AND 292
-#define SEMI_SEMI 293
-#define SEMI_AND 294
-#define SEMI_SEMI_AND 295
-#define LESS_LESS_MINUS 296
-#define AND_GREATER 297
-#define AND_GREATER_GREATER 298
-#define LESS_GREATER 299
-#define GREATER_BAR 300
-#define BAR_AND 301
-#define yacc_EOF 302
-
+/* Using locations.  */
+#define YYLSP_NEEDED 0
 
 
 
 /* Copy the first part of user declarations.  */
-#line 21 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 189 of yacc.c  */
+#line 21 "./parse.y"
 
 #include "config.h"
 
@@ -460,6 +364,9 @@
 static REDIRECTEE redir;
 
 
+/* Line 189 of yacc.c  */
+#line 369 "y.tab.c"
+
 /* Enabling traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
@@ -478,10 +385,117 @@
 # define YYTOKEN_TABLE 0
 #endif
 
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     IF = 258,
+     THEN = 259,
+     ELSE = 260,
+     ELIF = 261,
+     FI = 262,
+     CASE = 263,
+     ESAC = 264,
+     FOR = 265,
+     SELECT = 266,
+     WHILE = 267,
+     UNTIL = 268,
+     DO = 269,
+     DONE = 270,
+     FUNCTION = 271,
+     COPROC = 272,
+     COND_START = 273,
+     COND_END = 274,
+     COND_ERROR = 275,
+     IN = 276,
+     BANG = 277,
+     TIME = 278,
+     TIMEOPT = 279,
+     WORD = 280,
+     ASSIGNMENT_WORD = 281,
+     NUMBER = 282,
+     ARITH_CMD = 283,
+     ARITH_FOR_EXPRS = 284,
+     COND_CMD = 285,
+     AND_AND = 286,
+     OR_OR = 287,
+     GREATER_GREATER = 288,
+     LESS_LESS = 289,
+     LESS_AND = 290,
+     LESS_LESS_LESS = 291,
+     GREATER_AND = 292,
+     SEMI_SEMI = 293,
+     SEMI_AND = 294,
+     SEMI_SEMI_AND = 295,
+     LESS_LESS_MINUS = 296,
+     AND_GREATER = 297,
+     AND_GREATER_GREATER = 298,
+     LESS_GREATER = 299,
+     GREATER_BAR = 300,
+     BAR_AND = 301,
+     yacc_EOF = 302
+   };
+#endif
+/* Tokens.  */
+#define IF 258
+#define THEN 259
+#define ELSE 260
+#define ELIF 261
+#define FI 262
+#define CASE 263
+#define ESAC 264
+#define FOR 265
+#define SELECT 266
+#define WHILE 267
+#define UNTIL 268
+#define DO 269
+#define DONE 270
+#define FUNCTION 271
+#define COPROC 272
+#define COND_START 273
+#define COND_END 274
+#define COND_ERROR 275
+#define IN 276
+#define BANG 277
+#define TIME 278
+#define TIMEOPT 279
+#define WORD 280
+#define ASSIGNMENT_WORD 281
+#define NUMBER 282
+#define ARITH_CMD 283
+#define ARITH_FOR_EXPRS 284
+#define COND_CMD 285
+#define AND_AND 286
+#define OR_OR 287
+#define GREATER_GREATER 288
+#define LESS_LESS 289
+#define LESS_AND 290
+#define LESS_LESS_LESS 291
+#define GREATER_AND 292
+#define SEMI_SEMI 293
+#define SEMI_AND 294
+#define SEMI_SEMI_AND 295
+#define LESS_LESS_MINUS 296
+#define AND_GREATER 297
+#define AND_GREATER_GREATER 298
+#define LESS_GREATER 299
+#define GREATER_BAR 300
+#define BAR_AND 301
+#define yacc_EOF 302
+
+
+
+
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-#line 316 "/Users/chet/src/bash/src/parse.y"
 {
+
+/* Line 214 of yacc.c  */
+#line 316 "./parse.y"
+
   WORD_DESC *word;		/* the word that we read. */
   int number;			/* the number that we read. */
   WORD_LIST *word_list;
@@ -489,22 +503,23 @@
   REDIRECT *redirect;
   ELEMENT element;
   PATTERN_LIST *pattern;
-}
-/* Line 187 of yacc.c.  */
-#line 495 "y.tab.c"
-	YYSTYPE;
+
+
+
+/* Line 214 of yacc.c  */
+#line 511 "y.tab.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 
-
 /* Copy the second part of user declarations.  */
 
 
-/* Line 216 of yacc.c.  */
-#line 508 "y.tab.c"
+/* Line 264 of yacc.c  */
+#line 523 "y.tab.c"
 
 #ifdef short
 # undef short
@@ -579,14 +594,14 @@
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static int
-YYID (int i)
+YYID (int yyi)
 #else
 static int
-YYID (i)
-    int i;
+YYID (yyi)
+    int yyi;
 #endif
 {
-  return i;
+  return yyi;
 }
 #endif
 
@@ -667,9 +682,9 @@
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss;
-  YYSTYPE yyvs;
-  };
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
 
 /* The size of the maximum gap between one aligned stack and the next.  */
 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
@@ -703,12 +718,12 @@
    elements in the stack, and YYPTR gives the new location of the
    stack.  Advance YYPTR to a properly aligned location for the next
    stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
     do									\
       {									\
 	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
@@ -719,7 +734,7 @@
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  102
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   728
+#define YYLAST   714
 
 /* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  59
@@ -728,7 +743,7 @@
 /* YYNRULES -- Number of rules.  */
 #define YYNRULES  153
 /* YYNRULES -- Number of states.  */
-#define YYNSTATES  319
+#define YYNSTATES  311
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
@@ -993,76 +1008,76 @@
       42,     0,     0,   140,   141,     0,     0,   146,     0,   133,
      133,   133,   133,   133,   133,     0,   133,     0,   133,     0,
        0,     0,     0,   133,     0,   133,     0,     0,   133,    85,
-      84,    91,     0,   138,   139,     0,     0,   150,   149,   133,
-     133,    93,     0,     0,     0,   120,   121,   119,     0,   102,
-     133,     0,   133,   133,     0,     6,     0,   133,     0,    71,
-      72,   133,   133,   133,   133,     0,     0,     0,     0,    52,
-      53,     0,    86,    82,     0,     0,    95,   122,   123,   124,
-     125,   126,    81,   108,   110,   112,   103,     0,    79,   114,
-       0,     0,     0,     0,    61,     7,   133,     0,    62,     0,
-       0,     0,     0,    73,     0,   133,    74,    83,    94,   133,
-     133,   133,   133,   109,   111,   113,    80,     0,     0,   133,
-      63,    64,     0,   133,   133,    69,    70,    75,    76,     0,
-      99,     0,     0,     0,   133,   115,   104,   105,   133,   133,
-       0,     0,   133,   133,   133,   101,   106,   107,     0,     0,
-      67,    68,     0,     0,   100,    65,    66,    77,    78
+      84,    91,     0,   138,   139,   150,   149,   133,   133,    93,
+       0,     0,     0,   120,   121,   119,     0,   102,   133,     0,
+     133,   133,     0,     6,     0,   133,     0,    71,    72,   133,
+     133,   133,   133,     0,     0,     0,     0,    52,    53,     0,
+      86,    82,     0,     0,    95,   122,   123,   124,   125,   126,
+      81,   108,   110,   112,   103,     0,    79,   114,     0,     0,
+       0,     0,    61,     7,   133,     0,    62,     0,     0,     0,
+       0,    73,     0,   133,    74,    83,    94,   133,   109,   111,
+     113,    80,     0,     0,   133,    63,    64,     0,   133,   133,
+      69,    70,    75,    76,     0,    99,   133,   115,   104,   105,
+     133,   133,     0,     0,   133,   133,   133,   101,   106,   107,
+       0,     0,    67,    68,     0,     0,   100,    65,    66,    77,
+      78
 };
 
 /* YYDEFGOTO[NTERM-NUM].  */
 static const yytype_int16 yydefgoto[] =
 {
-      -1,    33,   216,    34,    35,   106,    36,    37,    38,    39,
+      -1,    33,   214,    34,    35,   106,    36,    37,    38,    39,
       40,    41,    42,    43,   190,    44,    45,    46,    47,    48,
-      49,   202,   208,   209,   210,   251,    56,    57,   124,   125,
-     109,   120,    58,    50,   163,   126,    53,    54
+      49,   200,   206,   207,   208,   249,    56,    57,   124,   125,
+     109,   120,    58,    50,    51,   126,    53,    54
 };
 
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
-#define YYPACT_NINF -188
+#define YYPACT_NINF -190
 static const yytype_int16 yypact[] =
 {
-     293,   -26,  -188,     7,    41,    43,  -188,  -188,    46,   629,
-     -17,   485,    11,    23,  -188,   675,  -188,    65,    68,    96,
-      77,   119,    92,   124,   127,   140,   143,  -188,  -188,   149,
-     154,  -188,  -188,    98,  -188,  -188,   662,  -188,   208,  -188,
-    -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,
-      24,    12,  -188,   -36,   341,  -188,  -188,   177,   389,  -188,
-     142,     8,   147,   169,   185,   148,   200,   662,   208,   181,
-     -36,   581,  -188,   146,   184,   189,   130,   192,   135,   197,
-     198,   202,   207,   209,  -188,  -188,  -188,  -188,  -188,  -188,
-    -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,
-     180,   167,  -188,  -188,  -188,  -188,   208,  -188,  -188,  -188,
-    -188,  -188,   437,   437,  -188,  -188,   581,  -188,  -188,  -188,
-    -188,   -36,  -188,  -188,  -188,   227,  -188,   -12,  -188,    20,
-    -188,  -188,  -188,  -188,   122,  -188,  -188,   179,    37,   208,
-     208,  -188,   -36,  -188,  -188,  -188,  -188,  -188,  -188,  -188,
-    -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,  -188,
-    -188,   389,   389,    53,    53,   533,   533,   -36,   224,  -188,
-    -188,  -188,  -188,  -188,  -188,    40,  -188,   171,  -188,   233,
-     190,    48,    73,  -188,   247,  -188,   239,   267,  -188,   208,
-    -188,   208,    37,  -188,  -188,   437,   437,   -36,   -36,  -188,
-    -188,  -188,   276,   389,   389,   389,   389,   389,   275,   226,
-    -188,    42,  -188,  -188,   270,  -188,   231,  -188,   230,  -188,
-    -188,  -188,  -188,  -188,  -188,   272,   389,   231,   234,  -188,
-    -188,    37,   208,  -188,   282,   287,  -188,  -188,  -188,    76,
-      76,    76,  -188,  -188,  -188,  -188,   229,    63,  -188,  -188,
-     274,   -27,   280,   241,  -188,  -188,  -188,    99,  -188,   285,
-     246,   292,   252,  -188,   227,  -188,  -188,  -188,  -188,  -188,
-    -188,  -188,  -188,  -188,  -188,  -188,  -188,   -22,   288,  -188,
-    -188,  -188,   131,  -188,  -188,  -188,  -188,  -188,  -188,   133,
-     129,   389,   389,   389,  -188,  -188,  -188,   389,  -188,  -188,
-     297,   258,  -188,  -188,  -188,  -188,  -188,   389,   302,   266,
-    -188,  -188,   308,   268,  -188,  -188,  -188,  -188,  -188
+     285,   -43,  -190,   -13,    56,    10,  -190,  -190,    32,   621,
+      43,   477,    60,    34,  -190,   661,  -190,    64,    68,    65,
+      70,   171,    80,    82,    87,    92,    98,  -190,  -190,   102,
+     110,  -190,  -190,   150,  -190,  -190,   214,  -190,   648,  -190,
+    -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,
+      53,   117,  -190,   -28,   333,  -190,  -190,   148,   381,  -190,
+     106,    17,   109,   147,   153,   111,    42,   214,   648,   154,
+     -28,   573,  -190,   116,   159,   170,   176,   172,   181,   177,
+     182,   187,   190,   198,  -190,  -190,  -190,  -190,  -190,  -190,
+    -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,
+     163,   188,  -190,  -190,  -190,  -190,   648,  -190,  -190,  -190,
+    -190,  -190,   429,   429,  -190,  -190,   573,  -190,  -190,  -190,
+    -190,   -28,  -190,  -190,  -190,   189,  -190,   -11,  -190,    73,
+    -190,  -190,  -190,  -190,   122,  -190,  -190,   195,    31,   648,
+     648,  -190,   -28,  -190,  -190,  -190,  -190,  -190,  -190,  -190,
+    -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,  -190,
+    -190,   381,   381,    83,    83,   525,   525,   -28,   221,  -190,
+    -190,  -190,  -190,  -190,  -190,    22,  -190,   161,  -190,   237,
+     173,    55,   120,  -190,   235,  -190,   249,   250,  -190,   648,
+    -190,   648,    31,  -190,  -190,   -28,   -28,  -190,  -190,  -190,
+     262,   381,   381,   381,   381,   381,   169,   194,  -190,     7,
+    -190,  -190,   255,  -190,   168,  -190,   215,  -190,  -190,  -190,
+    -190,  -190,  -190,   259,   381,   168,   219,  -190,  -190,    31,
+     648,  -190,   269,   273,  -190,  -190,  -190,   114,   114,   114,
+    -190,  -190,  -190,  -190,   205,    49,  -190,  -190,   253,   -34,
+     264,   225,  -190,  -190,  -190,   130,  -190,   267,   227,   272,
+     233,  -190,   189,  -190,  -190,  -190,  -190,  -190,  -190,  -190,
+    -190,  -190,   -29,   266,  -190,  -190,  -190,   133,  -190,  -190,
+    -190,  -190,  -190,  -190,   145,    15,  -190,  -190,  -190,   381,
+    -190,  -190,   277,   238,  -190,  -190,  -190,  -190,  -190,   381,
+     284,   244,  -190,  -190,   289,   258,  -190,  -190,  -190,  -190,
+    -190
 };
 
 /* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
-    -188,  -188,   141,   -30,   -25,   -62,   322,  -188,    -5,  -188,
-    -188,  -188,  -188,  -188,  -185,  -188,  -188,  -188,  -188,  -188,
-    -188,    49,  -188,   123,  -188,    82,  -171,    -6,  -188,  -187,
-    -188,   -58,   -32,  -188,     5,     2,    10,   329
+    -190,  -190,   121,   -31,   -21,   -63,   297,  -190,    -5,  -190,
+    -190,  -190,  -190,  -190,  -189,  -190,  -190,  -190,  -190,  -190,
+    -190,    24,  -190,   107,  -190,    69,  -174,    -6,  -190,   274,
+    -190,   -59,   -32,  -190,   -99,    19,    -3,   305
 };
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
@@ -1072,156 +1087,154 @@
 #define YYTABLE_NINF -1
 static const yytype_uint16 yytable[] =
 {
-      63,    64,    52,   132,    68,    51,   140,   233,   105,   174,
-     114,   104,   225,    69,   228,   115,   237,   238,   239,   240,
-     241,    70,   130,    55,   278,   100,   101,   127,   129,   278,
-     134,   279,    59,   138,   176,    72,   294,   123,   105,   264,
-       2,   177,   104,   110,   111,     3,   267,     4,     5,     6,
-       7,   248,   261,   262,   212,    10,   117,   118,   119,   112,
-     113,   139,   221,   131,   121,    16,    60,   249,    62,   123,
-      61,    65,   276,   107,   108,   178,   160,   191,   161,   162,
-      73,   142,   165,   166,   110,   111,   123,   223,   249,   123,
-      84,   123,    31,    85,    32,   213,   175,   123,   102,   250,
-     181,   182,    89,   222,   239,   240,   241,   169,   170,   105,
-     160,   192,   123,   283,    52,    52,   168,    93,   164,   217,
-     250,    86,   123,    87,   179,   180,   167,   232,   224,   186,
-     187,   312,   313,   189,   304,   200,   183,   203,   204,   205,
-     206,   207,   211,   184,    90,   298,    91,   302,   123,    94,
-      88,   226,    95,   226,   284,   146,   231,   147,   256,   105,
-     150,   160,   151,    52,    52,    96,   193,   194,    97,   265,
-     214,   123,   218,    92,    98,   197,   198,   185,   247,    99,
-     123,   122,   123,   135,   148,   257,   299,   189,   303,   152,
-     128,   226,   226,   234,   235,   133,   215,    52,    52,   136,
-     141,   164,   160,     2,   143,   137,   252,   253,     3,   144,
-       4,     5,     6,     7,   145,   259,   260,   149,    10,   117,
-     118,   119,   153,   154,   282,   159,   189,   155,    16,   199,
-     200,   201,   156,   289,   157,    15,   158,   188,   291,   292,
-     293,    17,    18,    19,    20,    21,   220,   297,   219,    22,
-      23,    24,    25,    26,   229,    31,   255,    32,   169,   170,
-      29,    30,   307,   290,   243,   244,   245,   273,   274,   275,
-     226,   226,   215,   296,   171,   172,   173,   300,   301,   117,
-     118,   119,   230,   236,   242,   254,   258,   263,   306,   268,
-     266,   269,   308,   309,     1,   280,     2,   281,   314,   249,
-     285,     3,   286,     4,     5,     6,     7,   287,   288,     8,
-       9,    10,   310,   295,   311,    11,    12,   315,    13,    14,
-      15,    16,   316,   317,   318,   227,    17,    18,    19,    20,
-      21,    67,   277,   246,    22,    23,    24,    25,    26,   305,
-      71,     0,    27,    28,     2,    29,    30,     0,    31,     3,
+      63,    64,   132,   231,    68,   140,    55,   105,    70,   223,
+     174,   226,    59,   163,   164,   104,   246,   273,   114,    52,
+     296,   198,   273,   115,   274,   100,   101,   127,   129,   286,
+     134,   130,   247,   138,     2,    62,   210,   105,   123,     3,
+     265,     4,     5,     6,     7,     2,   104,   259,   260,    10,
+       3,   121,     4,     5,     6,     7,   123,    65,   271,    16,
+      10,   139,   193,   194,   248,   117,   118,   119,   142,   219,
+      16,   123,   131,    69,   247,   160,   191,   211,   161,   162,
+     123,    60,   165,   166,    72,    61,    31,   176,    32,    84,
+      86,    73,    87,    85,   177,    89,   175,    31,   123,    32,
+     181,   182,   107,   108,   123,    93,   248,    94,   105,   160,
+     220,   192,    95,   167,   110,   111,   168,    96,   215,    88,
+     304,   305,   123,    97,   179,   180,   230,    98,   178,   186,
+     187,    52,    52,   189,   221,    99,   183,   201,   202,   203,
+     204,   205,   209,   184,   278,   169,   170,   290,   110,   111,
+     102,   224,   122,   224,   128,   254,   229,   133,   105,   294,
+     160,   135,   195,   196,   112,   113,   263,   136,   137,   123,
+     212,   123,   216,   141,   143,   222,   245,   185,   240,   123,
+      52,    52,   123,   255,   144,   279,   213,   189,   291,   224,
+     224,   232,   233,   253,   123,   145,    90,   149,    91,   160,
+     295,   146,   153,   147,   250,   251,   150,   154,   151,   117,
+     118,   119,   155,   257,   258,   156,   117,   118,   119,   158,
+     169,   170,   277,   157,   189,    92,   197,   198,   199,   218,
+     148,   284,   241,   242,   243,   152,   171,   172,   173,   103,
+      14,    15,   289,   268,   269,   270,   159,    17,    18,    19,
+      20,    21,   217,   188,   299,    22,    23,    24,    25,    26,
+     213,   285,   224,   224,   227,   228,    29,    30,   288,   234,
+     252,   256,   292,   293,   261,   264,   266,   267,   247,   275,
+     298,   276,   280,   281,   300,   301,     1,   282,     2,   283,
+     306,   287,   302,     3,   303,     4,     5,     6,     7,   307,
+     308,     8,     9,    10,   309,   225,    67,    11,    12,   297,
+      13,    14,    15,    16,   310,   244,    71,   272,    17,    18,
+      19,    20,    21,     0,     0,     0,    22,    23,    24,    25,
+      26,     0,     0,     0,    27,    28,     2,    29,    30,     0,
+      31,     3,    32,     4,     5,     6,     7,     0,     0,     8,
+       9,    10,     0,     0,     0,   116,     0,     0,    13,    14,
+      15,    16,     0,     0,     0,     0,    17,    18,    19,    20,
+      21,     0,     0,     0,    22,    23,    24,    25,    26,     0,
+       0,   117,   118,   119,     2,    29,    30,     0,    31,     3,
       32,     4,     5,     6,     7,     0,     0,     8,     9,    10,
-       0,     0,     0,   116,     0,     0,    13,    14,    15,    16,
+       0,     0,     0,    11,    12,     0,    13,    14,    15,    16,
        0,     0,     0,     0,    17,    18,    19,    20,    21,     0,
-       0,     0,    22,    23,    24,    25,    26,     0,     0,   117,
-     118,   119,     2,    29,    30,     0,    31,     3,    32,     4,
+       0,     0,    22,    23,    24,    25,    26,     0,     0,     0,
+     123,     0,     2,    29,    30,     0,    31,     3,    32,     4,
        5,     6,     7,     0,     0,     8,     9,    10,     0,     0,
        0,    11,    12,     0,    13,    14,    15,    16,     0,     0,
        0,     0,    17,    18,    19,    20,    21,     0,     0,     0,
-      22,    23,    24,    25,    26,     0,     0,     0,   123,     0,
+      22,    23,    24,    25,    26,   235,   236,   237,   238,   239,
        2,    29,    30,     0,    31,     3,    32,     4,     5,     6,
-       7,     0,     0,     8,     9,    10,     0,     0,     0,    11,
+       7,     0,     0,     8,     9,    10,     0,     0,   262,     0,
       12,     0,    13,    14,    15,    16,     0,     0,     0,     0,
       17,    18,    19,    20,    21,     0,     0,     0,    22,    23,
       24,    25,    26,     0,     0,     0,     0,     0,     2,    29,
       30,     0,    31,     3,    32,     4,     5,     6,     7,     0,
-       0,     8,     9,    10,     0,     0,     0,     0,    12,     0,
+       0,     8,     9,    10,     0,     0,     0,     0,     0,     0,
       13,    14,    15,    16,     0,     0,     0,     0,    17,    18,
       19,    20,    21,     0,     0,     0,    22,    23,    24,    25,
-      26,     0,     0,     0,     0,     0,     2,    29,    30,     0,
+      26,     0,     0,     0,   123,     0,     2,    29,    30,     0,
       31,     3,    32,     4,     5,     6,     7,     0,     0,     8,
        9,    10,     0,     0,     0,     0,     0,     0,    13,    14,
       15,    16,     0,     0,     0,     0,    17,    18,    19,    20,
       21,     0,     0,     0,    22,    23,    24,    25,    26,     0,
-       0,     0,   123,     0,     2,    29,    30,     0,    31,     3,
-      32,     4,     5,     6,     7,     0,     0,     8,     9,    10,
-       0,     0,     0,     0,     0,     0,    13,    14,    15,    16,
+       0,     0,     0,     0,     2,    29,    30,     0,    31,     3,
+      32,     4,     5,     6,     7,     0,     0,     0,     0,    10,
+       0,     0,     0,     0,     0,     0,    66,    14,    15,    16,
        0,     0,     0,     0,    17,    18,    19,    20,    21,     0,
        0,     0,    22,    23,    24,    25,    26,     0,     0,     0,
-       0,     0,     2,    29,    30,     0,    31,     3,    32,     4,
-       5,     6,     7,     0,     0,     0,     0,    10,     0,     0,
-       0,     0,     0,     0,    66,    14,    15,    16,     0,     0,
-       0,     0,    17,    18,    19,    20,    21,     0,     0,     0,
-      22,    23,    24,    25,    26,     0,     0,     0,     0,     0,
-       0,    29,    30,     0,    31,     0,    32,   103,    14,    15,
-       0,     0,     0,     0,     0,    17,    18,    19,    20,    21,
-       0,     0,     0,    22,    23,    24,    25,    26,    74,    75,
-      76,    77,    78,     0,    29,    30,    79,     0,     0,    80,
-      81,     0,     0,     0,     0,     0,     0,    82,    83
+       0,     0,     0,    29,    30,    15,    31,     0,    32,     0,
+       0,    17,    18,    19,    20,    21,     0,     0,     0,    22,
+      23,    24,    25,    26,    74,    75,    76,    77,    78,     0,
+      29,    30,    79,     0,     0,    80,    81,     0,     0,     0,
+       0,     0,     0,    82,    83
 };
 
 static const yytype_int16 yycheck[] =
 {
-       6,     7,     0,    61,     9,     0,    68,   192,    38,    21,
-      46,    36,   183,    30,   185,    51,   203,   204,   205,   206,
-     207,    11,    14,    49,    51,    31,    32,    59,    60,    51,
-      62,    58,    25,    65,    14,    24,    58,    49,    68,   226,
-       3,    21,    67,    31,    32,     8,   231,    10,    11,    12,
-      13,     9,   223,   224,    14,    18,    48,    49,    50,    47,
-      48,    66,    14,    55,    54,    28,    25,    25,    25,    49,
-      29,    25,     9,    49,    50,    55,   106,   139,   110,   111,
-      57,    71,   114,   115,    31,    32,    49,    14,    25,    49,
-      25,    49,    55,    25,    57,    55,   128,    49,     0,    57,
-     132,   133,    25,    55,   291,   292,   293,    31,    32,   139,
-     140,   143,    49,    14,   112,   113,   122,    25,   113,   177,
-      57,    25,    49,    27,   130,   131,   116,   189,    55,   135,
-     136,   302,   303,   138,     5,     6,    14,   169,   170,   171,
-     172,   173,   174,    21,    25,    14,    27,    14,    49,    25,
-      54,   183,    25,   185,    55,    25,   188,    27,   216,   189,
-      25,   191,    27,   161,   162,    25,   161,   162,    25,   227,
-     176,    49,   178,    54,    25,   165,   166,    55,   210,    25,
-      49,     4,    49,    14,    54,   217,    55,   192,    55,    54,
-      48,   223,   224,   199,   200,    48,    25,   195,   196,    14,
-      19,   196,   232,     3,    58,    57,   212,   213,     8,    25,
-      10,    11,    12,    13,    25,   221,   222,    25,    18,    48,
-      49,    50,    25,    25,   256,    58,   231,    25,    28,     5,
-       6,     7,    25,   265,    25,    27,    56,    58,   270,   271,
-     272,    33,    34,    35,    36,    37,    56,   279,    15,    41,
-      42,    43,    44,    45,    15,    55,    25,    57,    31,    32,
-      52,    53,   294,   269,    38,    39,    40,    38,    39,    40,
-     302,   303,    25,   279,    47,    48,    49,   283,   284,    48,
-      49,    50,    15,     7,     9,    15,    56,    15,   294,     7,
-      56,     4,   298,   299,     1,    15,     3,    56,   304,    25,
-      15,     8,    56,    10,    11,    12,    13,    15,    56,    16,
-      17,    18,    15,    25,    56,    22,    23,    15,    25,    26,
-      27,    28,    56,    15,    56,   184,    33,    34,    35,    36,
-      37,     9,   250,   210,    41,    42,    43,    44,    45,   290,
-      11,    -1,    49,    50,     3,    52,    53,    -1,    55,     8,
+       6,     7,    61,   192,     9,    68,    49,    38,    11,   183,
+      21,   185,    25,   112,   113,    36,     9,    51,    46,     0,
+       5,     6,    51,    51,    58,    31,    32,    59,    60,    58,
+      62,    14,    25,    65,     3,    25,    14,    68,    49,     8,
+     229,    10,    11,    12,    13,     3,    67,   221,   222,    18,
+       8,    54,    10,    11,    12,    13,    49,    25,     9,    28,
+      18,    66,   161,   162,    57,    48,    49,    50,    71,    14,
+      28,    49,    55,    30,    25,   106,   139,    55,   110,   111,
+      49,    25,   114,   115,    24,    29,    55,    14,    57,    25,
+      25,    57,    27,    25,    21,    25,   128,    55,    49,    57,
+     132,   133,    49,    50,    49,    25,    57,    25,   139,   140,
+      55,   143,    25,   116,    31,    32,   122,    25,   177,    54,
+     294,   295,    49,    25,   130,   131,   189,    25,    55,   135,
+     136,   112,   113,   138,    14,    25,    14,   169,   170,   171,
+     172,   173,   174,    21,    14,    31,    32,    14,    31,    32,
+       0,   183,     4,   185,    48,   214,   188,    48,   189,    14,
+     191,    14,   165,   166,    47,    48,   225,    14,    57,    49,
+     176,    49,   178,    19,    58,    55,   208,    55,     9,    49,
+     161,   162,    49,   215,    25,    55,    25,   192,    55,   221,
+     222,   197,   198,    25,    49,    25,    25,    25,    27,   230,
+      55,    25,    25,    27,   210,   211,    25,    25,    27,    48,
+      49,    50,    25,   219,   220,    25,    48,    49,    50,    56,
+      31,    32,   254,    25,   229,    54,     5,     6,     7,    56,
+      54,   263,    38,    39,    40,    54,    47,    48,    49,    25,
+      26,    27,   274,    38,    39,    40,    58,    33,    34,    35,
+      36,    37,    15,    58,   286,    41,    42,    43,    44,    45,
+      25,   267,   294,   295,    15,    15,    52,    53,   274,     7,
+      15,    56,   278,   279,    15,    56,     7,     4,    25,    15,
+     286,    56,    15,    56,   290,   291,     1,    15,     3,    56,
+     296,    25,    15,     8,    56,    10,    11,    12,    13,    15,
+      56,    16,    17,    18,    15,   184,     9,    22,    23,   285,
+      25,    26,    27,    28,    56,   208,    11,   248,    33,    34,
+      35,    36,    37,    -1,    -1,    -1,    41,    42,    43,    44,
+      45,    -1,    -1,    -1,    49,    50,     3,    52,    53,    -1,
+      55,     8,    57,    10,    11,    12,    13,    -1,    -1,    16,
+      17,    18,    -1,    -1,    -1,    22,    -1,    -1,    25,    26,
+      27,    28,    -1,    -1,    -1,    -1,    33,    34,    35,    36,
+      37,    -1,    -1,    -1,    41,    42,    43,    44,    45,    -1,
+      -1,    48,    49,    50,     3,    52,    53,    -1,    55,     8,
       57,    10,    11,    12,    13,    -1,    -1,    16,    17,    18,
-      -1,    -1,    -1,    22,    -1,    -1,    25,    26,    27,    28,
+      -1,    -1,    -1,    22,    23,    -1,    25,    26,    27,    28,
       -1,    -1,    -1,    -1,    33,    34,    35,    36,    37,    -1,
-      -1,    -1,    41,    42,    43,    44,    45,    -1,    -1,    48,
-      49,    50,     3,    52,    53,    -1,    55,     8,    57,    10,
+      -1,    -1,    41,    42,    43,    44,    45,    -1,    -1,    -1,
+      49,    -1,     3,    52,    53,    -1,    55,     8,    57,    10,
       11,    12,    13,    -1,    -1,    16,    17,    18,    -1,    -1,
       -1,    22,    23,    -1,    25,    26,    27,    28,    -1,    -1,
       -1,    -1,    33,    34,    35,    36,    37,    -1,    -1,    -1,
-      41,    42,    43,    44,    45,    -1,    -1,    -1,    49,    -1,
+      41,    42,    43,    44,    45,   201,   202,   203,   204,   205,
        3,    52,    53,    -1,    55,     8,    57,    10,    11,    12,
-      13,    -1,    -1,    16,    17,    18,    -1,    -1,    -1,    22,
+      13,    -1,    -1,    16,    17,    18,    -1,    -1,   224,    -1,
       23,    -1,    25,    26,    27,    28,    -1,    -1,    -1,    -1,
       33,    34,    35,    36,    37,    -1,    -1,    -1,    41,    42,
       43,    44,    45,    -1,    -1,    -1,    -1,    -1,     3,    52,
       53,    -1,    55,     8,    57,    10,    11,    12,    13,    -1,
-      -1,    16,    17,    18,    -1,    -1,    -1,    -1,    23,    -1,
+      -1,    16,    17,    18,    -1,    -1,    -1,    -1,    -1,    -1,
       25,    26,    27,    28,    -1,    -1,    -1,    -1,    33,    34,
       35,    36,    37,    -1,    -1,    -1,    41,    42,    43,    44,
-      45,    -1,    -1,    -1,    -1,    -1,     3,    52,    53,    -1,
+      45,    -1,    -1,    -1,    49,    -1,     3,    52,    53,    -1,
       55,     8,    57,    10,    11,    12,    13,    -1,    -1,    16,
       17,    18,    -1,    -1,    -1,    -1,    -1,    -1,    25,    26,
       27,    28,    -1,    -1,    -1,    -1,    33,    34,    35,    36,
       37,    -1,    -1,    -1,    41,    42,    43,    44,    45,    -1,
-      -1,    -1,    49,    -1,     3,    52,    53,    -1,    55,     8,
-      57,    10,    11,    12,    13,    -1,    -1,    16,    17,    18,
+      -1,    -1,    -1,    -1,     3,    52,    53,    -1,    55,     8,
+      57,    10,    11,    12,    13,    -1,    -1,    -1,    -1,    18,
       -1,    -1,    -1,    -1,    -1,    -1,    25,    26,    27,    28,
       -1,    -1,    -1,    -1,    33,    34,    35,    36,    37,    -1,
       -1,    -1,    41,    42,    43,    44,    45,    -1,    -1,    -1,
-      -1,    -1,     3,    52,    53,    -1,    55,     8,    57,    10,
-      11,    12,    13,    -1,    -1,    -1,    -1,    18,    -1,    -1,
-      -1,    -1,    -1,    -1,    25,    26,    27,    28,    -1,    -1,
-      -1,    -1,    33,    34,    35,    36,    37,    -1,    -1,    -1,
-      41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,
-      -1,    52,    53,    -1,    55,    -1,    57,    25,    26,    27,
-      -1,    -1,    -1,    -1,    -1,    33,    34,    35,    36,    37,
-      -1,    -1,    -1,    41,    42,    43,    44,    45,    33,    34,
-      35,    36,    37,    -1,    52,    53,    41,    -1,    -1,    44,
-      45,    -1,    -1,    -1,    -1,    -1,    -1,    52,    53
+      -1,    -1,    -1,    52,    53,    27,    55,    -1,    57,    -1,
+      -1,    33,    34,    35,    36,    37,    -1,    -1,    -1,    41,
+      42,    43,    44,    45,    33,    34,    35,    36,    37,    -1,
+      52,    53,    41,    -1,    -1,    44,    45,    -1,    -1,    -1,
+      -1,    -1,    -1,    52,    53
 };
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
@@ -1247,19 +1260,19 @@
       62,    91,    91,    93,    93,    91,    91,    95,    86,    31,
       32,    47,    48,    49,    21,    91,    14,    21,    55,    86,
       86,    91,    91,    14,    21,    55,    86,    86,    58,    67,
-      73,    64,    91,    93,    93,    47,    48,    95,    95,     5,
-       6,     7,    80,    91,    91,    91,    91,    91,    81,    82,
-      83,    91,    14,    55,    86,    25,    61,    90,    86,    15,
-      56,    14,    55,    14,    55,    85,    91,    61,    85,    15,
-      15,    91,    64,    73,    86,    86,     7,    88,    88,    88,
-      88,    88,     9,    38,    39,    40,    82,    91,     9,    25,
-      57,    84,    86,    86,    15,    25,    90,    91,    56,    86,
-      86,    85,    85,    15,    88,    90,    56,    73,     7,     4,
-      47,    48,    49,    38,    39,    40,     9,    84,    51,    58,
-      15,    56,    91,    14,    55,    15,    56,    15,    56,    91,
-      86,    91,    91,    91,    58,    25,    86,    91,    14,    55,
-      86,    86,    14,    55,     5,    80,    86,    91,    86,    86,
-      15,    56,    85,    85,    86,    15,    56,    15,    56
+      73,    64,    91,    93,    93,    95,    95,     5,     6,     7,
+      80,    91,    91,    91,    91,    91,    81,    82,    83,    91,
+      14,    55,    86,    25,    61,    90,    86,    15,    56,    14,
+      55,    14,    55,    85,    91,    61,    85,    15,    15,    91,
+      64,    73,    86,    86,     7,    88,    88,    88,    88,    88,
+       9,    38,    39,    40,    82,    91,     9,    25,    57,    84,
+      86,    86,    15,    25,    90,    91,    56,    86,    86,    85,
+      85,    15,    88,    90,    56,    73,     7,     4,    38,    39,
+      40,     9,    84,    51,    58,    15,    56,    91,    14,    55,
+      15,    56,    15,    56,    91,    86,    58,    25,    86,    91,
+      14,    55,    86,    86,    14,    55,     5,    80,    86,    91,
+      86,    86,    15,    56,    85,    85,    86,    15,    56,    15,
+      56
 };
 
 #define yyerrok		(yyerrstatus = 0)
@@ -1444,17 +1457,20 @@
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
 #else
 static void
-yy_stack_print (bottom, top)
-    yytype_int16 *bottom;
-    yytype_int16 *top;
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
   YYFPRINTF (stderr, "\n");
 }
 
@@ -1488,11 +1504,11 @@
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      fprintf (stderr, "   $%d = ", yyi + 1);
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 		       &(yyvsp[(yyi + 1) - (yynrhs)])
 		       		       );
-      fprintf (stderr, "\n");
+      YYFPRINTF (stderr, "\n");
     }
 }
 
@@ -1772,10 +1788,8 @@
 	break;
     }
 }
-
 
 /* Prevent warnings from -Wmissing-prototypes.  */
-
 #ifdef YYPARSE_PARAM
 #if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
@@ -1791,11 +1805,10 @@
 #endif /* ! YYPARSE_PARAM */
 
 
-
-/* The look-ahead symbol.  */
+/* The lookahead symbol.  */
 int yychar;
 
-/* The semantic value of the look-ahead symbol.  */
+/* The semantic value of the lookahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1803,9 +1816,9 @@
 
 
 
-/*----------.
-| yyparse.  |
-`----------*/
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
 
 #ifdef YYPARSE_PARAM
 #if (defined __STDC__ || defined __C99__FUNC__ \
@@ -1829,14 +1842,39 @@
 #endif
 #endif
 {
-  
-  int yystate;
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
   int yyn;
   int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Look-ahead token as an internal (translated) token number.  */
-  int yytoken = 0;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
 #if YYERROR_VERBOSE
   /* Buffer for error messages, and its allocated size.  */
   char yymsgbuf[128];
@@ -1844,51 +1882,28 @@
   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
-
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
-
-  /* The state stack.  */
-  yytype_int16 yyssa[YYINITDEPTH];
-  yytype_int16 *yyss = yyssa;
-  yytype_int16 *yyssp;
-
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  YYSTYPE *yyvsp;
-
-
-
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
-
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-
   /* The number of symbols on the RHS of the reduced rule.
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  yychar = YYEMPTY; /* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
-
   yyssp = yyss;
   yyvsp = yyvs;
 
@@ -1918,7 +1933,6 @@
 	YYSTYPE *yyvs1 = yyvs;
 	yytype_int16 *yyss1 = yyss;
 
-
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
@@ -1926,7 +1940,6 @@
 	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
-
 		    &yystacksize);
 
 	yyss = yyss1;
@@ -1949,9 +1962,8 @@
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
 	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
@@ -1962,7 +1974,6 @@
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
 
-
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
@@ -1972,6 +1983,9 @@
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
   goto yybackup;
 
 /*-----------.
@@ -1980,16 +1994,16 @@
 yybackup:
 
   /* Do appropriate processing given the current state.  Read a
-     look-ahead token if we need one and don't already have one.  */
+     lookahead token if we need one and don't already have one.  */
 
-  /* First try to decide what to do without reference to look-ahead token.  */
+  /* First try to decide what to do without reference to lookahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a look-ahead token if don't already have one.  */
+  /* Not known => get a lookahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -2021,20 +2035,16 @@
       goto yyreduce;
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
-  /* Shift the look-ahead token.  */
+  /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the shifted token unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
 
   yystate = yyn;
   *++yyvsp = yylval;
@@ -2074,7 +2084,9 @@
   switch (yyn)
     {
         case 2:
-#line 370 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 370 "./parse.y"
     {
 			  /* Case of regular command.  Discard the error
 			     safety net,and return the command just parsed. */
@@ -2088,7 +2100,9 @@
     break;
 
   case 3:
-#line 381 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 381 "./parse.y"
     {
 			  /* Case of regular command, but not a very
 			     interesting one.  Return a NULL command. */
@@ -2100,7 +2114,9 @@
     break;
 
   case 4:
-#line 390 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 390 "./parse.y"
     {
 			  /* Error during parsing.  Return NULL command. */
 			  global_command = (COMMAND *)NULL;
@@ -2118,7 +2134,9 @@
     break;
 
   case 5:
-#line 405 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 405 "./parse.y"
     {
 			  /* Case of EOF seen by itself.  Do ignoreeof or
 			     not. */
@@ -2129,17 +2147,23 @@
     break;
 
   case 6:
-#line 415 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 415 "./parse.y"
     { (yyval.word_list) = make_word_list ((yyvsp[(1) - (1)].word), (WORD_LIST *)NULL); }
     break;
 
   case 7:
-#line 417 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 417 "./parse.y"
     { (yyval.word_list) = make_word_list ((yyvsp[(2) - (2)].word), (yyvsp[(1) - (2)].word_list)); }
     break;
 
   case 8:
-#line 421 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 421 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (1, r_output_direction, redir);
@@ -2147,7 +2171,9 @@
     break;
 
   case 9:
-#line 426 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 426 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (0, r_input_direction, redir);
@@ -2155,7 +2181,9 @@
     break;
 
   case 10:
-#line 431 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 431 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_output_direction, redir);
@@ -2163,7 +2191,9 @@
     break;
 
   case 11:
-#line 436 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 436 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_input_direction, redir);
@@ -2171,7 +2201,9 @@
     break;
 
   case 12:
-#line 441 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 441 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (1, r_appending_to, redir);
@@ -2179,7 +2211,9 @@
     break;
 
   case 13:
-#line 446 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 446 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_appending_to, redir);
@@ -2187,7 +2221,9 @@
     break;
 
   case 14:
-#line 451 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 451 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (0, r_reading_until, redir);
@@ -2196,7 +2232,9 @@
     break;
 
   case 15:
-#line 457 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 457 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_reading_until, redir);
@@ -2205,7 +2243,9 @@
     break;
 
   case 16:
-#line 463 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 463 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (0, r_reading_string, redir);
@@ -2213,7 +2253,9 @@
     break;
 
   case 17:
-#line 468 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 468 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_reading_string, redir);
@@ -2221,7 +2263,9 @@
     break;
 
   case 18:
-#line 473 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 473 "./parse.y"
     {
 			  redir.dest = (yyvsp[(2) - (2)].number);
 			  (yyval.redirect) = make_redirection (0, r_duplicating_input, redir);
@@ -2229,7 +2273,9 @@
     break;
 
   case 19:
-#line 478 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 478 "./parse.y"
     {
 			  redir.dest = (yyvsp[(3) - (3)].number);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_duplicating_input, redir);
@@ -2237,7 +2283,9 @@
     break;
 
   case 20:
-#line 483 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 483 "./parse.y"
     {
 			  redir.dest = (yyvsp[(2) - (2)].number);
 			  (yyval.redirect) = make_redirection (1, r_duplicating_output, redir);
@@ -2245,7 +2293,9 @@
     break;
 
   case 21:
-#line 488 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 488 "./parse.y"
     {
 			  redir.dest = (yyvsp[(3) - (3)].number);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_duplicating_output, redir);
@@ -2253,7 +2303,9 @@
     break;
 
   case 22:
-#line 493 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 493 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (0, r_duplicating_input_word, redir);
@@ -2261,7 +2313,9 @@
     break;
 
   case 23:
-#line 498 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 498 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_duplicating_input_word, redir);
@@ -2269,7 +2323,9 @@
     break;
 
   case 24:
-#line 503 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 503 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (1, r_duplicating_output_word, redir);
@@ -2277,7 +2333,9 @@
     break;
 
   case 25:
-#line 508 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 508 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_duplicating_output_word, redir);
@@ -2285,7 +2343,9 @@
     break;
 
   case 26:
-#line 513 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 513 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection
@@ -2295,7 +2355,9 @@
     break;
 
   case 27:
-#line 520 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 520 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection
@@ -2305,7 +2367,9 @@
     break;
 
   case 28:
-#line 527 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 527 "./parse.y"
     {
 			  redir.dest = 0;
 			  (yyval.redirect) = make_redirection (1, r_close_this, redir);
@@ -2313,7 +2377,9 @@
     break;
 
   case 29:
-#line 532 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 532 "./parse.y"
     {
 			  redir.dest = 0;
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_close_this, redir);
@@ -2321,7 +2387,9 @@
     break;
 
   case 30:
-#line 537 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 537 "./parse.y"
     {
 			  redir.dest = 0;
 			  (yyval.redirect) = make_redirection (0, r_close_this, redir);
@@ -2329,7 +2397,9 @@
     break;
 
   case 31:
-#line 542 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 542 "./parse.y"
     {
 			  redir.dest = 0;
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_close_this, redir);
@@ -2337,7 +2407,9 @@
     break;
 
   case 32:
-#line 547 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 547 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (1, r_err_and_out, redir);
@@ -2345,7 +2417,9 @@
     break;
 
   case 33:
-#line 552 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 552 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (1, r_append_err_and_out, redir);
@@ -2353,7 +2427,9 @@
     break;
 
   case 34:
-#line 557 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 557 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_input_output, redir);
@@ -2361,7 +2437,9 @@
     break;
 
   case 35:
-#line 562 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 562 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (0, r_input_output, redir);
@@ -2369,7 +2447,9 @@
     break;
 
   case 36:
-#line 567 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 567 "./parse.y"
     {
 			  redir.filename = (yyvsp[(2) - (2)].word);
 			  (yyval.redirect) = make_redirection (1, r_output_force, redir);
@@ -2377,7 +2457,9 @@
     break;
 
   case 37:
-#line 572 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 572 "./parse.y"
     {
 			  redir.filename = (yyvsp[(3) - (3)].word);
 			  (yyval.redirect) = make_redirection ((yyvsp[(1) - (3)].number), r_output_force, redir);
@@ -2385,29 +2467,39 @@
     break;
 
   case 38:
-#line 579 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 579 "./parse.y"
     { (yyval.element).word = (yyvsp[(1) - (1)].word); (yyval.element).redirect = 0; }
     break;
 
   case 39:
-#line 581 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 581 "./parse.y"
     { (yyval.element).word = (yyvsp[(1) - (1)].word); (yyval.element).redirect = 0; }
     break;
 
   case 40:
-#line 583 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 583 "./parse.y"
     { (yyval.element).redirect = (yyvsp[(1) - (1)].redirect); (yyval.element).word = 0; }
     break;
 
   case 41:
-#line 587 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 587 "./parse.y"
     {
 			  (yyval.redirect) = (yyvsp[(1) - (1)].redirect);
 			}
     break;
 
   case 42:
-#line 591 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 591 "./parse.y"
     {
 			  register REDIRECT *t;
 
@@ -2419,27 +2511,37 @@
     break;
 
   case 43:
-#line 602 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 602 "./parse.y"
     { (yyval.command) = make_simple_command ((yyvsp[(1) - (1)].element), (COMMAND *)NULL); }
     break;
 
   case 44:
-#line 604 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 604 "./parse.y"
     { (yyval.command) = make_simple_command ((yyvsp[(2) - (2)].element), (yyvsp[(1) - (2)].command)); }
     break;
 
   case 45:
-#line 608 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 608 "./parse.y"
     { (yyval.command) = clean_simple_command ((yyvsp[(1) - (1)].command)); }
     break;
 
   case 46:
-#line 610 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 610 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 47:
-#line 612 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 612 "./parse.y"
     {
 			  COMMAND *tc;
 
@@ -2458,72 +2560,100 @@
     break;
 
   case 48:
-#line 628 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 628 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 49:
-#line 630 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 630 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 50:
-#line 634 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 634 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 51:
-#line 636 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 636 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 52:
-#line 638 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 638 "./parse.y"
     { (yyval.command) = make_while_command ((yyvsp[(2) - (5)].command), (yyvsp[(4) - (5)].command)); }
     break;
 
   case 53:
-#line 640 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 640 "./parse.y"
     { (yyval.command) = make_until_command ((yyvsp[(2) - (5)].command), (yyvsp[(4) - (5)].command)); }
     break;
 
   case 54:
-#line 642 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 642 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 55:
-#line 644 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 644 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 56:
-#line 646 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 646 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 57:
-#line 648 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 648 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 58:
-#line 650 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 650 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 59:
-#line 652 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 652 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 60:
-#line 654 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 654 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 61:
-#line 658 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 658 "./parse.y"
     {
 			  (yyval.command) = make_for_command ((yyvsp[(2) - (6)].word), add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), (yyvsp[(5) - (6)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2531,7 +2661,9 @@
     break;
 
   case 62:
-#line 663 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 663 "./parse.y"
     {
 			  (yyval.command) = make_for_command ((yyvsp[(2) - (6)].word), add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), (yyvsp[(5) - (6)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2539,7 +2671,9 @@
     break;
 
   case 63:
-#line 668 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 668 "./parse.y"
     {
 			  (yyval.command) = make_for_command ((yyvsp[(2) - (7)].word), add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), (yyvsp[(6) - (7)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2547,7 +2681,9 @@
     break;
 
   case 64:
-#line 673 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 673 "./parse.y"
     {
 			  (yyval.command) = make_for_command ((yyvsp[(2) - (7)].word), add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), (yyvsp[(6) - (7)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2555,7 +2691,9 @@
     break;
 
   case 65:
-#line 678 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 678 "./parse.y"
     {
 			  (yyval.command) = make_for_command ((yyvsp[(2) - (10)].word), REVERSE_LIST ((yyvsp[(5) - (10)].word_list), WORD_LIST *), (yyvsp[(9) - (10)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2563,7 +2701,9 @@
     break;
 
   case 66:
-#line 683 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 683 "./parse.y"
     {
 			  (yyval.command) = make_for_command ((yyvsp[(2) - (10)].word), REVERSE_LIST ((yyvsp[(5) - (10)].word_list), WORD_LIST *), (yyvsp[(9) - (10)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2571,7 +2711,9 @@
     break;
 
   case 67:
-#line 688 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 688 "./parse.y"
     {
 			  (yyval.command) = make_for_command ((yyvsp[(2) - (9)].word), (WORD_LIST *)NULL, (yyvsp[(8) - (9)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2579,7 +2721,9 @@
     break;
 
   case 68:
-#line 693 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 693 "./parse.y"
     {
 			  (yyval.command) = make_for_command ((yyvsp[(2) - (9)].word), (WORD_LIST *)NULL, (yyvsp[(8) - (9)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2587,7 +2731,9 @@
     break;
 
   case 69:
-#line 700 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 700 "./parse.y"
     {
 				  (yyval.command) = make_arith_for_command ((yyvsp[(2) - (7)].word_list), (yyvsp[(6) - (7)].command), arith_for_lineno);
 				  if (word_top > 0) word_top--;
@@ -2595,7 +2741,9 @@
     break;
 
   case 70:
-#line 705 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 705 "./parse.y"
     {
 				  (yyval.command) = make_arith_for_command ((yyvsp[(2) - (7)].word_list), (yyvsp[(6) - (7)].command), arith_for_lineno);
 				  if (word_top > 0) word_top--;
@@ -2603,7 +2751,9 @@
     break;
 
   case 71:
-#line 710 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 710 "./parse.y"
     {
 				  (yyval.command) = make_arith_for_command ((yyvsp[(2) - (5)].word_list), (yyvsp[(4) - (5)].command), arith_for_lineno);
 				  if (word_top > 0) word_top--;
@@ -2611,7 +2761,9 @@
     break;
 
   case 72:
-#line 715 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 715 "./parse.y"
     {
 				  (yyval.command) = make_arith_for_command ((yyvsp[(2) - (5)].word_list), (yyvsp[(4) - (5)].command), arith_for_lineno);
 				  if (word_top > 0) word_top--;
@@ -2619,7 +2771,9 @@
     break;
 
   case 73:
-#line 722 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 722 "./parse.y"
     {
 			  (yyval.command) = make_select_command ((yyvsp[(2) - (6)].word), add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), (yyvsp[(5) - (6)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2627,7 +2781,9 @@
     break;
 
   case 74:
-#line 727 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 727 "./parse.y"
     {
 			  (yyval.command) = make_select_command ((yyvsp[(2) - (6)].word), add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), (yyvsp[(5) - (6)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2635,7 +2791,9 @@
     break;
 
   case 75:
-#line 732 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 732 "./parse.y"
     {
 			  (yyval.command) = make_select_command ((yyvsp[(2) - (7)].word), add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), (yyvsp[(6) - (7)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2643,7 +2801,9 @@
     break;
 
   case 76:
-#line 737 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 737 "./parse.y"
     {
 			  (yyval.command) = make_select_command ((yyvsp[(2) - (7)].word), add_string_to_list ("\"$@\"", (WORD_LIST *)NULL), (yyvsp[(6) - (7)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2651,7 +2811,9 @@
     break;
 
   case 77:
-#line 742 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 742 "./parse.y"
     {
 			  (yyval.command) = make_select_command ((yyvsp[(2) - (10)].word), REVERSE_LIST ((yyvsp[(5) - (10)].word_list), WORD_LIST *), (yyvsp[(9) - (10)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2659,7 +2821,9 @@
     break;
 
   case 78:
-#line 747 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 747 "./parse.y"
     {
 			  (yyval.command) = make_select_command ((yyvsp[(2) - (10)].word), REVERSE_LIST ((yyvsp[(5) - (10)].word_list), WORD_LIST *), (yyvsp[(9) - (10)].command), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2667,7 +2831,9 @@
     break;
 
   case 79:
-#line 754 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 754 "./parse.y"
     {
 			  (yyval.command) = make_case_command ((yyvsp[(2) - (6)].word), (PATTERN_LIST *)NULL, word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2675,7 +2841,9 @@
     break;
 
   case 80:
-#line 759 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 759 "./parse.y"
     {
 			  (yyval.command) = make_case_command ((yyvsp[(2) - (7)].word), (yyvsp[(5) - (7)].pattern), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2683,7 +2851,9 @@
     break;
 
   case 81:
-#line 764 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 764 "./parse.y"
     {
 			  (yyval.command) = make_case_command ((yyvsp[(2) - (6)].word), (yyvsp[(5) - (6)].pattern), word_lineno[word_top]);
 			  if (word_top > 0) word_top--;
@@ -2691,27 +2861,37 @@
     break;
 
   case 82:
-#line 771 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 771 "./parse.y"
     { (yyval.command) = make_function_def ((yyvsp[(1) - (5)].word), (yyvsp[(5) - (5)].command), function_dstart, function_bstart); }
     break;
 
   case 83:
-#line 774 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 774 "./parse.y"
     { (yyval.command) = make_function_def ((yyvsp[(2) - (6)].word), (yyvsp[(6) - (6)].command), function_dstart, function_bstart); }
     break;
 
   case 84:
-#line 777 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 777 "./parse.y"
     { (yyval.command) = make_function_def ((yyvsp[(2) - (4)].word), (yyvsp[(4) - (4)].command), function_dstart, function_bstart); }
     break;
 
   case 85:
-#line 781 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 781 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 86:
-#line 783 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 783 "./parse.y"
     {
 			  COMMAND *tc;
 
@@ -2743,7 +2923,9 @@
     break;
 
   case 87:
-#line 814 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 814 "./parse.y"
     {
 			  (yyval.command) = make_subshell_command ((yyvsp[(2) - (3)].command));
 			  (yyval.command)->flags |= CMD_WANT_SUBSHELL;
@@ -2751,7 +2933,9 @@
     break;
 
   case 88:
-#line 821 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 821 "./parse.y"
     {
 			  (yyval.command) = make_coproc_command ("COPROC", (yyvsp[(2) - (2)].command));
 			  (yyval.command)->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
@@ -2759,7 +2943,9 @@
     break;
 
   case 89:
-#line 826 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 826 "./parse.y"
     {
 			  COMMAND *tc;
 
@@ -2779,7 +2965,9 @@
     break;
 
   case 90:
-#line 843 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 843 "./parse.y"
     {
 			  (yyval.command) = make_coproc_command ((yyvsp[(2) - (3)].word)->word, (yyvsp[(3) - (3)].command));
 			  (yyval.command)->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
@@ -2787,7 +2975,9 @@
     break;
 
   case 91:
-#line 848 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 848 "./parse.y"
     {
 			  COMMAND *tc;
 
@@ -2807,7 +2997,9 @@
     break;
 
   case 92:
-#line 865 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 865 "./parse.y"
     {
 			  (yyval.command) = make_coproc_command ("COPROC", clean_simple_command ((yyvsp[(2) - (2)].command)));
 			  (yyval.command)->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
@@ -2815,117 +3007,163 @@
     break;
 
   case 93:
-#line 872 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 872 "./parse.y"
     { (yyval.command) = make_if_command ((yyvsp[(2) - (5)].command), (yyvsp[(4) - (5)].command), (COMMAND *)NULL); }
     break;
 
   case 94:
-#line 874 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 874 "./parse.y"
     { (yyval.command) = make_if_command ((yyvsp[(2) - (7)].command), (yyvsp[(4) - (7)].command), (yyvsp[(6) - (7)].command)); }
     break;
 
   case 95:
-#line 876 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 876 "./parse.y"
     { (yyval.command) = make_if_command ((yyvsp[(2) - (6)].command), (yyvsp[(4) - (6)].command), (yyvsp[(5) - (6)].command)); }
     break;
 
   case 96:
-#line 881 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 881 "./parse.y"
     { (yyval.command) = make_group_command ((yyvsp[(2) - (3)].command)); }
     break;
 
   case 97:
-#line 885 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 885 "./parse.y"
     { (yyval.command) = make_arith_command ((yyvsp[(1) - (1)].word_list)); }
     break;
 
   case 98:
-#line 889 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 889 "./parse.y"
     { (yyval.command) = (yyvsp[(2) - (3)].command); }
     break;
 
   case 99:
-#line 893 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 893 "./parse.y"
     { (yyval.command) = make_if_command ((yyvsp[(2) - (4)].command), (yyvsp[(4) - (4)].command), (COMMAND *)NULL); }
     break;
 
   case 100:
-#line 895 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 895 "./parse.y"
     { (yyval.command) = make_if_command ((yyvsp[(2) - (6)].command), (yyvsp[(4) - (6)].command), (yyvsp[(6) - (6)].command)); }
     break;
 
   case 101:
-#line 897 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 897 "./parse.y"
     { (yyval.command) = make_if_command ((yyvsp[(2) - (5)].command), (yyvsp[(4) - (5)].command), (yyvsp[(5) - (5)].command)); }
     break;
 
   case 103:
-#line 902 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 902 "./parse.y"
     { (yyvsp[(2) - (2)].pattern)->next = (yyvsp[(1) - (2)].pattern); (yyval.pattern) = (yyvsp[(2) - (2)].pattern); }
     break;
 
   case 104:
-#line 906 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 906 "./parse.y"
     { (yyval.pattern) = make_pattern_list ((yyvsp[(2) - (4)].word_list), (yyvsp[(4) - (4)].command)); }
     break;
 
   case 105:
-#line 908 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 908 "./parse.y"
     { (yyval.pattern) = make_pattern_list ((yyvsp[(2) - (4)].word_list), (COMMAND *)NULL); }
     break;
 
   case 106:
-#line 910 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 910 "./parse.y"
     { (yyval.pattern) = make_pattern_list ((yyvsp[(3) - (5)].word_list), (yyvsp[(5) - (5)].command)); }
     break;
 
   case 107:
-#line 912 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 912 "./parse.y"
     { (yyval.pattern) = make_pattern_list ((yyvsp[(3) - (5)].word_list), (COMMAND *)NULL); }
     break;
 
   case 108:
-#line 916 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 916 "./parse.y"
     { (yyval.pattern) = (yyvsp[(1) - (2)].pattern); }
     break;
 
   case 109:
-#line 918 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 918 "./parse.y"
     { (yyvsp[(2) - (3)].pattern)->next = (yyvsp[(1) - (3)].pattern); (yyval.pattern) = (yyvsp[(2) - (3)].pattern); }
     break;
 
   case 110:
-#line 920 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 920 "./parse.y"
     { (yyvsp[(1) - (2)].pattern)->flags |= CASEPAT_FALLTHROUGH; (yyval.pattern) = (yyvsp[(1) - (2)].pattern); }
     break;
 
   case 111:
-#line 922 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 922 "./parse.y"
     { (yyvsp[(2) - (3)].pattern)->flags |= CASEPAT_FALLTHROUGH; (yyvsp[(2) - (3)].pattern)->next = (yyvsp[(1) - (3)].pattern); (yyval.pattern) = (yyvsp[(2) - (3)].pattern); }
     break;
 
   case 112:
-#line 924 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 924 "./parse.y"
     { (yyvsp[(1) - (2)].pattern)->flags |= CASEPAT_TESTNEXT; (yyval.pattern) = (yyvsp[(1) - (2)].pattern); }
     break;
 
   case 113:
-#line 926 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 926 "./parse.y"
     { (yyvsp[(2) - (3)].pattern)->flags |= CASEPAT_TESTNEXT; (yyvsp[(2) - (3)].pattern)->next = (yyvsp[(1) - (3)].pattern); (yyval.pattern) = (yyvsp[(2) - (3)].pattern); }
     break;
 
   case 114:
-#line 930 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 930 "./parse.y"
     { (yyval.word_list) = make_word_list ((yyvsp[(1) - (1)].word), (WORD_LIST *)NULL); }
     break;
 
   case 115:
-#line 932 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 932 "./parse.y"
     { (yyval.word_list) = make_word_list ((yyvsp[(3) - (3)].word), (yyvsp[(1) - (3)].word_list)); }
     break;
 
   case 116:
-#line 941 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 941 "./parse.y"
     {
 			  (yyval.command) = (yyvsp[(2) - (2)].command);
 			  if (need_here_doc)
@@ -2934,14 +3172,18 @@
     break;
 
   case 118:
-#line 950 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 950 "./parse.y"
     {
 			  (yyval.command) = (yyvsp[(2) - (2)].command);
 			}
     break;
 
   case 120:
-#line 957 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 957 "./parse.y"
     {
 			  if ((yyvsp[(1) - (3)].command)->type == cm_connection)
 			    (yyval.command) = connect_async_list ((yyvsp[(1) - (3)].command), (COMMAND *)NULL, '&');
@@ -2951,17 +3193,23 @@
     break;
 
   case 122:
-#line 968 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 968 "./parse.y"
     { (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), AND_AND); }
     break;
 
   case 123:
-#line 970 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 970 "./parse.y"
     { (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), OR_OR); }
     break;
 
   case 124:
-#line 972 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 972 "./parse.y"
     {
 			  if ((yyvsp[(1) - (4)].command)->type == cm_connection)
 			    (yyval.command) = connect_async_list ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), '&');
@@ -2971,37 +3219,51 @@
     break;
 
   case 125:
-#line 979 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 979 "./parse.y"
     { (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), ';'); }
     break;
 
   case 126:
-#line 981 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 981 "./parse.y"
     { (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), ';'); }
     break;
 
   case 127:
-#line 983 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 983 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 130:
-#line 991 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 991 "./parse.y"
     { (yyval.number) = '\n'; }
     break;
 
   case 131:
-#line 993 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 993 "./parse.y"
     { (yyval.number) = ';'; }
     break;
 
   case 132:
-#line 995 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 995 "./parse.y"
     { (yyval.number) = yacc_EOF; }
     break;
 
   case 135:
-#line 1009 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1009 "./parse.y"
     {
 			  (yyval.command) = (yyvsp[(1) - (1)].command);
 			  if (need_here_doc)
@@ -3017,7 +3279,9 @@
     break;
 
   case 136:
-#line 1022 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1022 "./parse.y"
     {
 			  if ((yyvsp[(1) - (2)].command)->type == cm_connection)
 			    (yyval.command) = connect_async_list ((yyvsp[(1) - (2)].command), (COMMAND *)NULL, '&');
@@ -3036,7 +3300,9 @@
     break;
 
   case 137:
-#line 1038 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1038 "./parse.y"
     {
 			  (yyval.command) = (yyvsp[(1) - (2)].command);
 			  if (need_here_doc)
@@ -3052,17 +3318,23 @@
     break;
 
   case 138:
-#line 1053 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1053 "./parse.y"
     { (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), AND_AND); }
     break;
 
   case 139:
-#line 1055 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1055 "./parse.y"
     { (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), OR_OR); }
     break;
 
   case 140:
-#line 1057 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1057 "./parse.y"
     {
 			  if ((yyvsp[(1) - (3)].command)->type == cm_connection)
 			    (yyval.command) = connect_async_list ((yyvsp[(1) - (3)].command), (yyvsp[(3) - (3)].command), '&');
@@ -3072,22 +3344,30 @@
     break;
 
   case 141:
-#line 1064 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1064 "./parse.y"
     { (yyval.command) = command_connect ((yyvsp[(1) - (3)].command), (yyvsp[(3) - (3)].command), ';'); }
     break;
 
   case 142:
-#line 1067 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1067 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 143:
-#line 1071 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1071 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 144:
-#line 1073 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1073 "./parse.y"
     {
 			  if ((yyvsp[(2) - (2)].command))
 			    (yyvsp[(2) - (2)].command)->flags |= CMD_INVERT_RETURN;
@@ -3096,7 +3376,9 @@
     break;
 
   case 145:
-#line 1079 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1079 "./parse.y"
     {
 			  if ((yyvsp[(2) - (2)].command))
 			    (yyvsp[(2) - (2)].command)->flags |= (yyvsp[(1) - (2)].number);
@@ -3105,7 +3387,9 @@
     break;
 
   case 146:
-#line 1085 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1085 "./parse.y"
     {
 			  if ((yyvsp[(3) - (3)].command))
 			    (yyvsp[(3) - (3)].command)->flags |= (yyvsp[(1) - (3)].number)|CMD_INVERT_RETURN;
@@ -3114,7 +3398,9 @@
     break;
 
   case 147:
-#line 1091 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1091 "./parse.y"
     {
 			  if ((yyvsp[(3) - (3)].command))
 			    (yyvsp[(3) - (3)].command)->flags |= (yyvsp[(2) - (3)].number)|CMD_INVERT_RETURN;
@@ -3123,7 +3409,9 @@
     break;
 
   case 148:
-#line 1097 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1097 "./parse.y"
     {
 			  ELEMENT x;
 
@@ -3143,19 +3431,23 @@
     break;
 
   case 149:
-#line 1117 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1117 "./parse.y"
     { (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), '|'); }
     break;
 
   case 150:
-#line 1119 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1119 "./parse.y"
     {
 			  /* Make cmd1 |& cmd2 equivalent to cmd1 2>&1 | cmd2 */
 			  COMMAND *tc;
 			  REDIRECTEE rd;
 			  REDIRECT *r;
 
-			  tc = (yyvsp[(1) - (4)].command);
+			  tc = (yyvsp[(1) - (4)].command)->type == cm_simple ? (COMMAND *)(yyvsp[(1) - (4)].command)->value.Simple : (yyvsp[(1) - (4)].command);
 			  rd.dest = 1;
 			  r = make_redirection (2, r_duplicating_output, rd);
 			  if (tc->redirects)
@@ -3173,23 +3465,30 @@
     break;
 
   case 151:
-#line 1141 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1141 "./parse.y"
     { (yyval.command) = (yyvsp[(1) - (1)].command); }
     break;
 
   case 152:
-#line 1145 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1145 "./parse.y"
     { (yyval.number) = CMD_TIME_PIPELINE; }
     break;
 
   case 153:
-#line 1147 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1455 of yacc.c  */
+#line 1147 "./parse.y"
     { (yyval.number) = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }
     break;
 
 
-/* Line 1267 of yacc.c.  */
-#line 3193 "y.tab.c"
+
+/* Line 1455 of yacc.c  */
+#line 3492 "y.tab.c"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
@@ -3200,7 +3499,6 @@
 
   *++yyvsp = yyval;
 
-
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
@@ -3265,7 +3563,7 @@
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse look-ahead token after an
+      /* If just tried and failed to reuse lookahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
@@ -3282,7 +3580,7 @@
 	}
     }
 
-  /* Else will try to reuse look-ahead token after shifting the error
+  /* Else will try to reuse lookahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -3339,9 +3637,6 @@
       YY_STACK_PRINT (yyss, yyssp);
     }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
   *++yyvsp = yylval;
 
 
@@ -3366,7 +3661,7 @@
   yyresult = 1;
   goto yyreturn;
 
-#ifndef yyoverflow
+#if !defined(yyoverflow) || YYERROR_VERBOSE
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -3377,7 +3672,7 @@
 #endif
 
 yyreturn:
-  if (yychar != YYEOF && yychar != YYEMPTY)
+  if (yychar != YYEMPTY)
      yydestruct ("Cleanup: discarding lookahead",
 		 yytoken, &yylval);
   /* Do not reclaim the symbols of the rule which action triggered
@@ -3403,7 +3698,9 @@
 }
 
 
-#line 1149 "/Users/chet/src/bash/src/parse.y"
+
+/* Line 1675 of yacc.c  */
+#line 1149 "./parse.y"
 
 
 /* Initial size to allocate for tokens, and the
@@ -3873,10 +4170,11 @@
 {
   int *ret;
 
-  ret = (int *)xmalloc (3 * sizeof (int));
+  ret = (int *)xmalloc (4 * sizeof (int));
   ret[0] = last_read_token;
   ret[1] = token_before_that;
   ret[2] = two_tokens_ago;
+  ret[3] = current_token;
   return ret;
 }
 
@@ -3889,6 +4187,7 @@
   last_read_token = ts[0];
   token_before_that = ts[1];
   two_tokens_ago = ts[2];
+  current_token = ts[3];
 }
 
 /*
@@ -4135,7 +4434,7 @@
     prompt_again ();
   ret = read_a_line (remove_quoted_newline);
 #if defined (HISTORY)
-  if (remember_on_history && (parser_state & PST_HEREDOC))
+  if (ret && remember_on_history && (parser_state & PST_HEREDOC))
     {
       /* To make adding the the here-document body right, we need to rely
 	 on history_delimiting_chars() returning \n for the first line of
@@ -4926,6 +5225,7 @@
   FREE (word_desc_to_read);
   word_desc_to_read = (WORD_DESC *)NULL;
 
+  current_token = '\n';		/* XXX */
   last_read_token = '\n';
   token_to_read = '\n';
 }
@@ -5173,6 +5473,7 @@
 #define P_DQUOTE	0x04
 #define P_COMMAND	0x08	/* parsing a command, so look for comments */
 #define P_BACKQUOTE	0x10	/* parsing a backquoted command substitution */
+#define P_ARRAYSUB	0x20	/* parsing a [...] array subscript for assignment */
 
 /* Lexical state while parsing a grouping construct or $(...). */
 #define LEX_WASDOL	0x001
@@ -5185,6 +5486,7 @@
 #define LEX_INHEREDOC	0x080
 #define LEX_HEREDELIM	0x100		/* reading here-doc delimiter */
 #define LEX_STRIPDOC	0x200		/* <<- strip tabs from here doc delim */
+#define LEX_INWORD	0x400
 
 #define COMSUB_META(ch)		((ch) == ';' || (ch) == '&' || (ch) == '|')
 
@@ -5387,6 +5689,8 @@
 	      APPEND_NESTRET ();
 	      FREE (nestret);
 	    }
+	  else if ((flags & P_ARRAYSUB) && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
+	    goto parse_dollar_word;
 	}
       /* Parse an old-style command substitution within double quotes as a
 	 single word. */
@@ -5403,6 +5707,7 @@
       else if MBTEST(open != '`' && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
 	/* check for $(), $[], or ${} inside quoted string. */
 	{
+parse_dollar_word:
 	  if (open == ch)	/* undo previous increment */
 	    count--;
 	  if (ch == '(')		/* ) */
@@ -5437,7 +5742,7 @@
      int open, close;
      int *lenp, flags;
 {
-  int count, ch, peekc, tflags, lex_rwlen, lex_firstind;
+  int count, ch, peekc, tflags, lex_rwlen, lex_wlen, lex_firstind;
   int nestlen, ttranslen, start_lineno;
   char *ret, *nestret, *ttrans, *heredelim;
   int retind, retsize, rflags, hdlen;
@@ -5458,7 +5763,7 @@
   retind = 0;
 
   start_lineno = line_number;
-  lex_rwlen = 0;
+  lex_rwlen = lex_wlen = 0;
 
   heredelim = 0;
   lex_firstind = -1;
@@ -5525,6 +5830,46 @@
 	  continue;
 	}
 
+      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
+	{
+/*itrace("parse_comsub:%d: lex_passnext -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	  tflags &= ~LEX_PASSNEXT;
+	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
+	    {
+	      if (retind > 0)
+		retind--;	/* swallow previously-added backslash */
+	      continue;
+	    }
+
+	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
+	  if MBTEST(ch == CTLESC || ch == CTLNUL)
+	    ret[retind++] = CTLESC;
+	  ret[retind++] = ch;
+	  continue;
+	}
+
+      /* If this is a shell break character, we are not in a word.  If not,
+	 we either start or continue a word. */
+      if MBTEST(shellbreak (ch))
+	{
+	  tflags &= ~LEX_INWORD;
+/*itrace("parse_comsub:%d: lex_inword -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	}
+      else
+	{
+	  if (tflags & LEX_INWORD)
+	    {
+	      lex_wlen++;
+/*itrace("parse_comsub:%d: lex_inword == 1 ch = `%c' lex_wlen = %d (%d)", line_number, ch, lex_wlen, __LINE__);*/
+	    }	      
+	  else
+	    {
+/*itrace("parse_comsub:%d: lex_inword -> 1 ch = `%c' (%d)", line_number, ch, __LINE__);*/
+	      tflags |= LEX_INWORD;
+	      lex_wlen = 0;
+	    }
+	}
+
       /* Skip whitespace */
       if MBTEST(shellblank (ch) && lex_rwlen == 0)
         {
@@ -5622,9 +5967,21 @@
 }	        
 	      tflags &= ~LEX_RESWDOK;
 	    }
-	  else if (shellbreak (ch) == 0)
+	  else if MBTEST((tflags & LEX_CKCOMMENT) && ch == '#' && (lex_rwlen == 0 || ((tflags & LEX_INWORD) && lex_wlen == 0)))
+	    ;	/* don't modify LEX_RESWDOK if we're starting a comment */
+	  else if MBTEST((tflags & LEX_INCASE) && ch != '\n')
+	    /* If we can read a reserved word and we're in case, we're at the
+	       point where we can read a new pattern list or an esac.  We
+	       handle the esac case above.  If we read a newline, we want to
+	       leave LEX_RESWDOK alone.  If we read anything else, we want to
+	       turn off LEX_RESWDOK, since we're going to read a pattern list. */
 {
-	      tflags &= ~LEX_RESWDOK;
+	    tflags &= ~LEX_RESWDOK;
+/*itrace("parse_comsub:%d: lex_incase == 1 found `%c', lex_reswordok -> 0", line_number, ch);*/
+}
+	  else if MBTEST(shellbreak (ch) == 0)
+{
+	    tflags &= ~LEX_RESWDOK;
 /*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
 }
 	}
@@ -5652,36 +6009,23 @@
 		}
 	      else
 		shell_ungetc (peekc);
-	      tflags |= LEX_HEREDELIM;
-	      lex_firstind = -1;
+	      if (peekc != '<')
+		{
+		  tflags |= LEX_HEREDELIM;
+		  lex_firstind = -1;
+		}
 	      continue;
 	    }
 	  else
-	    ch = peekc;		/* fall through and continue XXX - this skips comments if peekc == '#' */
+	    ch = peekc;		/* fall through and continue XXX */
 	}
-      /* Not exactly right yet, should handle shell metacharacters, too.  If
-	 any changes are made to this test, make analogous changes to subst.c:
-	 extract_delimited_string(). */
-      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || shellblank (ret[retind - 1])))
+      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (((tflags & LEX_RESWDOK) && lex_rwlen == 0) || ((tflags & LEX_INWORD) && lex_wlen == 0)))
+{
+/*itrace("parse_comsub:%d: lex_incomment -> 1 (%d)", line_number, __LINE__);*/
 	tflags |= LEX_INCOMMENT;
+}
 
-      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
-	{
-	  tflags &= ~LEX_PASSNEXT;
-	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
-	    {
-	      if (retind > 0)
-		retind--;	/* swallow previously-added backslash */
-	      continue;
-	    }
-
-	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
-	  if MBTEST(ch == CTLESC || ch == CTLNUL)
-	    ret[retind++] = CTLESC;
-	  ret[retind++] = ch;
-	  continue;
-	}
-      else if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
+      if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
 	{
 	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
 	  ret[retind++] = CTLESC;
@@ -6506,7 +6850,7 @@
 		     ((token_index > 0 && assignment_acceptable (last_read_token) && token_is_ident (token, token_index)) ||
 		      (token_index == 0 && (parser_state&PST_COMPASSIGN))))
         {
-	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
+	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARRAYSUB);
 	  if (ttok == &matched_pair_error)
 	    return -1;		/* Bail immediately. */
 	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
@@ -6707,6 +7051,7 @@
     case '}':		/* XXX */
     case AND_AND:
     case BANG:
+    case BAR_AND:
     case DO:
     case DONE:
     case ELIF:
diff -Nru bash-4.0-orig/y.tab.h bash-4.0/y.tab.h
--- bash-4.0-orig/y.tab.h	2009-01-08 15:30:24.000000000 +0100
+++ bash-4.0/y.tab.h	2009-12-08 18:04:03.000000000 +0100
@@ -1,24 +1,23 @@
-/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton interface for Bison's Yacc-like parsers in C
+/* A Bison parser, made by GNU Bison 2.4.1.  */
 
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
    Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
+   
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
@@ -29,10 +28,11 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
+
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -138,8 +138,11 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-#line 316 "/Users/chet/src/bash/src/parse.y"
 {
+
+/* Line 1676 of yacc.c  */
+#line 316 "./parse.y"
+
   WORD_DESC *word;		/* the word that we read. */
   int number;			/* the number that we read. */
   WORD_LIST *word_list;
@@ -147,14 +150,17 @@
   REDIRECT *redirect;
   ELEMENT element;
   PATTERN_LIST *pattern;
-}
-/* Line 1489 of yacc.c.  */
-#line 153 "y.tab.h"
-	YYSTYPE;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 158 "y.tab.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
 #endif
 
 extern YYSTYPE yylval;
 
+
